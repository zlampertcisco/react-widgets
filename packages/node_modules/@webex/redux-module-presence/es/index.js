import { fromJS } from 'immutable';

function prepareStatusResponses(responses) {
  // Convert array of responses to an object
  const processed = {};
  responses.forEach(response => {
    if (!response.subject) {
      return;
    } // Undefined status means we are unable to get presence for that user.
    // Setting to false keeps us from retrying the fetch


    processed[response.subject] = response.status || false;
  });
  return processed;
}
function prepareSingleStatusResponse(response) {
  const processed = {};
  processed[response.subject] = response;
  return processed;
}

const SET_ERROR = 'presence/SET_ERROR';
const SET_PRESENCE_STATUS = 'presence/SET_PRESENCE_STATUS';
const UPDATE_MODULE_STATUS = 'presence/UPDATE_MODULE_STATUS';
const UPDATE_USER_STATUS_ERROR = 'presence/UPDATE_USER_STATUS_ERROR';

function updateStatus(status) {
  return {
    type: UPDATE_MODULE_STATUS,
    payload: {
      status
    }
  };
}

function setError(error) {
  return {
    type: SET_ERROR,
    payload: {
      error
    }
  };
}

function setPresenceStatus(status) {
  return {
    type: SET_PRESENCE_STATUS,
    payload: {
      status
    }
  };
}
/**
 * active: Indicates that the user is "active" in the system for the giventtl or until another event is received.
 * inactive: Indicates that the user should be considered "inactive" for the given ttl or until another event
 *  is received
 * dnd: Indicates a desire by the user to not be disturbed for the given ttl.A TTL= 0 indicates canceling current
 * dnd state
  * ooo: Indicates that the user is "out of office" for the given ttl.A TTL= 0 indicates canceling current ooo state
 */

/**
 * @type {('active', 'inactive', 'dnd', 'ooo')} EventType - Types of user statuses
 */

/**
 * Sets the current user's status
 * @param {EventType} eventType
 * @param {number} ttl Time To Live for the event in seconds.
 * @param {object} spark
 * @returns {Thunk}
 */


function setUserPresenceStatus(eventType, ttl, spark) {
  return dispatch => {
    dispatch(updateStatus({
      isSettingUserStatus: true
    }));
    return spark.internal.presence.setStatus(eventType, ttl).then(() => dispatch(updateStatus({
      isSettingUserStatus: false
    }))).catch(error => dispatch(setError(error)));
  };
}
/**
 * Async requests a specific user's status
 * @param {array | string} userIds
 * @param {object} spark
 * @returns {Thunk}
 */

function getCurrentPresenceStatus(userIds, spark) {
  const subjects = Array.isArray(userIds) ? userIds : [userIds];
  return dispatch => spark.internal.presence.list(subjects).then(presenceResponse => dispatch(setPresenceStatus(presenceResponse.statusList)));
}
/**
 * Fetches and subscribes to a user's presence status
 * @param {array | string} userIds
 * @param {object} spark
 * @returns {Thunk}
 */

function subscribeToPresenceUpdates(userIds, spark) {
  return (dispatch, getState) => {
    const subjects = Array.isArray(userIds) ? userIds : [userIds];
    const {
      presence
    } = getState();
    const newUserIds = subjects.filter(subject => !presence.hasIn(['items', subject]));

    if (newUserIds.length === 0) {
      return Promise.resolve();
    }

    const emptyStatuses = newUserIds.map(id => ({
      subject: id,
      status: false
    }));
    dispatch(setPresenceStatus(prepareStatusResponses(emptyStatuses))); // normal subscription ttl in seconds

    const subscriptionTtl = 600;
    return spark.internal.presence.subscribe(newUserIds, subscriptionTtl).then(presenceResponse => {
      spark.internal.mercury.on('event:apheleia.subscription_update', event => {
        dispatch(setPresenceStatus(prepareSingleStatusResponse(event.data)));
      });
      return dispatch(setPresenceStatus(prepareStatusResponses(presenceResponse.responses)));
    });
  };
}
/**
 * Tells the service to stop sending status updates
 * @param {array | string} userIds
 * @param {object} spark
 * @returns {Thunk}
 */

function unsubscribeFromPresenceUpdates(userIds, spark) {
  const subjects = Array.isArray(userIds) ? userIds : [userIds];
  return dispatch => spark.internal.presence.unsubscribe(subjects).then(() => {
    // Setting status to undefined clears the subject from items
    const clearStatus = {};
    subjects.forEach(subject => {
      clearStatus[subject] = undefined;
    });
    return dispatch(setPresenceStatus(clearStatus));
  });
}

const initialState = fromJS({
  status: {
    isError: false,
    isSettingUserStatus: false
  },
  items: {},
  error: null
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case SET_PRESENCE_STATUS:
      {
        const {
          status
        } = action.payload;
        return state.mergeDeep({
          items: fromJS(status)
        });
      }

    case UPDATE_MODULE_STATUS:
      return state.mergeDeep({
        status: action.payload.status
      });

    case SET_ERROR:
      return state.set('error', action.payload.error).setIn(['status', 'isError'], true);

    default:
      return state;
  }
}

// Indicates that the user is "active" in the system for the given ttl or until another event is received.

const PRESENCE_TYPE_ACTIVE = 'active'; // inactive:
// Indicates that the user should be considered "inactive" for the given ttl or until another event is received

const PRESENCE_TYPE_INACTIVE = 'inactive'; // dnd:
// Indicates a desire by the user to not be disturbed for the given ttl.A TTL= 0 indicates canceling current dnd state

const PRESENCE_TYPE_DND = 'dnd'; // ooo:
// Indicates that the user is "out of office" for the given ttl.A TTL= 0 indicates canceling current ooo state

const PRESENCE_TYPE_OOO = 'ooo';

export default reducer;
export { PRESENCE_TYPE_ACTIVE, PRESENCE_TYPE_DND, PRESENCE_TYPE_INACTIVE, PRESENCE_TYPE_OOO, SET_ERROR, SET_PRESENCE_STATUS, UPDATE_MODULE_STATUS, UPDATE_USER_STATUS_ERROR, getCurrentPresenceStatus, initialState, setUserPresenceStatus, subscribeToPresenceUpdates, unsubscribeFromPresenceUpdates };
//# sourceMappingURL=index.js.map
