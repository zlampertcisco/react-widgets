import { compose } from 'recompose';
import { constructWebexEnhancer, withIntl } from '@webex/webex-widget-base';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { autobind } from 'core-decorators';
import classNames from 'classnames';
import ActivityMenuHeader from '@webex/react-component-activity-menu-header';
import FileShareDisplay from '@webex/react-component-file-share-display';
import connectFileDownloader from '@webex/react-container-file-downloader';
import { createSelector } from 'reselect';
import moment from 'moment';
import conversation, { getActivitiesFromThreadAndNonThreadCollections } from '@webex/redux-module-conversation';
import { combineReducers } from 'redux';
import share from '@webex/redux-module-share';

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

function ShareListingItem({
  fileShare,
  onDownloadClick,
  type
}) {
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(FileShareDisplay, {
    actor: fileShare.actor,
    file: fileShare.item,
    isFetching: fileShare.item.isFetching,
    objectUrl: fileShare.item.objectUrl,
    onDownloadClick: onDownloadClick,
    type: type,
    timestamp: fileShare.timestamp
  }));
}

ShareListingItem.propTypes = {
  fileShare: PropTypes.shape({
    actor: PropTypes.object,
    activityId: PropTypes.string,
    item: PropTypes.object,
    timestamp: PropTypes.string
  }).isRequired,
  onDownloadClick: PropTypes.func.isRequired,
  // Injected via connectFileDownloader
  type: PropTypes.string.isRequired
};
var ShareListingItem$1 = connectFileDownloader(ShareListingItem);

const getShare = state => state.share;

const getConversationThreadActivities = state => state.conversation.get('threadActivities');

const getConversationNonThreadActivities = state => state.conversation.get('sortNonThreadActivities');
/**
 * Formats the published date to the format specified for content display
 * @param {String} dateString
 * @returns {String}
 */


function formatDate(dateString) {
  return moment(dateString).format('M/D/YY');
}
/**
 * Creates an array of "content" activities and their data from the share module
 * @param {Array} rawActivities An array of conversation activities
 * @param {Object} share The redux share module
 * @returns {Array}
 */


function getFileShareActivities(rawActivities, share) {
  const fileShares = [];
  rawActivities.filter(activity => activity.verb === 'share').forEach(activity => {
    if (activity.object.files && activity.object.files.items.length) {
      activity.object.files.items.forEach(fileItem => {
        let isFetching = false;
        let objectUrl;

        if (fileItem.image) {
          const thumbnail = fileItem.mimeType === 'image/gif' ? share.getIn(['files', fileItem.url]) : share.getIn(['files', fileItem.image.url]);

          if (thumbnail) {
            isFetching = thumbnail.get('isFetching');
            objectUrl = thumbnail.get('objectUrl');
          }
        }

        const fileShare = {
          actor: activity.actor,
          activityId: activity.id,
          item: { ...fileItem,
            isFetching,
            objectUrl
          },
          published: new Date(activity.published),
          timestamp: formatDate(activity.published)
        };
        fileShares.push(fileShare);
      });
    }
  });
  return fileShares;
}
/**
 * Combines the threaded and non threaded activities by using the convo redux module
 * helper function
 */


const getConversationActivities = createSelector([getConversationThreadActivities, getConversationNonThreadActivities], getActivitiesFromThreadAndNonThreadCollections);
const getFilesWidgetProps = createSelector([getConversationActivities, getShare], (conversationActivities, share) => {
  const fileShares = getFileShareActivities(conversationActivities, share);
  return {
    // Sort by newest content first
    fileShares: fileShares.sort((a, b) => b.published - a.published)
  };
});

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".widget-files__widgetFiles__LndpZGdl {\n  display: flex;\n  height: 100%;\n  font-family: CiscoSans, 'Helvetica Neue', Arial, sans-serif;\n  flex-direction: column;\n}\n\n.widget-files__widgetFilesMain__LndpZGdl {\n  flex: 1 1 auto;\n  overflow-y: auto;\n  padding: 10px;\n}\n";
var styles = {"widgetFiles":"widget-files__widgetFiles__LndpZGdl","widgetFilesMain":"widget-files__widgetFilesMain__LndpZGdl"};
styleInject(css_248z);

var _class;
const ownPropTypes = {
  onClickClose: PropTypes.func.isRequired,
  onClickMenu: PropTypes.func.isRequired
};
const injectedPropTypes = {
  activityTypes: PropTypes.array.isRequired,
  conversation: PropTypes.object.isRequired,
  fileShares: PropTypes.array.isRequired
};
let FilesWidget = (_class = class FilesWidget extends Component {
  handleMenuClick() {
    this.props.onClickMenu();
  }

  handleCloseClick() {
    this.props.onClickClose();
  }

  render() {
    return /*#__PURE__*/React.createElement("div", {
      className: classNames('webex-widget-files', styles.widgetFiles)
    }, /*#__PURE__*/React.createElement(ActivityMenuHeader, {
      activityTypes: this.props.activityTypes,
      onClose: this.props.onClickClose && this.handleCloseClick,
      onMenuClick: this.props.onClickMenu && this.handleMenuClick,
      title: `Files (${this.props.fileShares.length})`
    }), /*#__PURE__*/React.createElement("div", {
      className: classNames('webex-widget-files-main', styles.widgetFilesMain)
    }, this.props.fileShares.length && /*#__PURE__*/React.createElement("div", null, this.props.fileShares.map(fileShare => /*#__PURE__*/React.createElement(ShareListingItem$1, {
      fileShare: fileShare,
      key: fileShare.item.url,
      type: "file"
    }))), !this.props.fileShares.length && /*#__PURE__*/React.createElement("div", null, "No Files Found")));
  }

}, (_applyDecoratedDescriptor(_class.prototype, "handleMenuClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleMenuClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleCloseClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleCloseClick"), _class.prototype)), _class);
FilesWidget.propTypes = { ...ownPropTypes,
  ...injectedPropTypes
};
var ConnectedFiles = connect(getFilesWidgetProps)(FilesWidget);

const reducers = {
  conversation,
  share
};
combineReducers(reducers);

var messages = {};

var index = compose(constructWebexEnhancer({
  name: 'files',
  reducers
}), withIntl({
  locale: 'en',
  messages
}))(ConnectedFiles);

export default index;
//# sourceMappingURL=index.js.map
