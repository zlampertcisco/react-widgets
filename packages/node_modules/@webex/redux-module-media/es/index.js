import { first } from 'rxjs/operators';
import { Record, List, Map } from 'immutable';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { compose, lifecycle } from 'recompose';
import { setWrappedDisplayName } from '@webex/react-component-utils';

const Membership = Record({
  audioMuted: false,
  isInitiator: true,
  hydraId: '',
  id: '',
  state: '',
  videoMuted: false
});
/**
 * Constructs a call state with properties the widget uses
 *
 * @export
 * @param {any} call
 * @param {Error} rawError
 * @returns {object}
 */

function constructCallStatus(call) {
  let isConnected, isIncoming, isInitiated, isRinging;
  const {
    remoteAudioMuted,
    remoteVideoMuted
  } = call;

  try {
    // Ringing means we are calling out to 1:1 and the party hasn't answered
    isRinging = call.remoteMember && call.remoteMember.state === 'notified'; // Connected means both parties are active on a 1:1 or joined in group
    // isCall is true when the call is 1:1

    if (typeof call.isCall === 'boolean') {
      if (call.isCall) {
        isInitiated = !!call.locus;
        isConnected = !!call.remoteMember && call.remoteMember.state === 'connected' && !!call.joinedOnThisDevice;
      } else {
        // Group calls are immediately initiated
        isInitiated = true;
        isConnected = !!call.joinedOnThisDevice;
      }
    } else {
      isInitiated = false;
      isConnected = false;
    }

    isIncoming = call.direction === 'in' && !call.hasJoinedOnThisDevice;
  } catch (e) {// Do nothing
  }

  return {
    isCall: call.isCall,
    isActive: call.isActive,
    hasJoinedOnThisDevice: call.joinedOnThisDevice,
    isReceivingAudio: call.receivingAudio,
    isReceivingVideo: call.receivingVideo,
    isSendingAudio: call.sendingAudio,
    isSendingVideo: call.sendingVideo,
    isDeclined: call.me && call.me.state === 'declined',
    isInitiated,
    isConnected,
    isRinging,
    isIncoming,
    remoteAudioMuted,
    remoteVideoMuted
  };
}
function constructCallObject(call) {
  let remoteAudioStream = null;
  let remoteVideoStream = null;
  let activeParticipantsCount = 0;
  let startTime;
  const memberships = [];

  try {
    var _call$remoteMediaStre, _call$remoteMediaStre2, _call$members, _call$members$members, _call$locusInfo, _call$locusInfo$fullS;

    if (call !== null && call !== void 0 && (_call$remoteMediaStre = call.remoteMediaStream) !== null && _call$remoteMediaStre !== void 0 && _call$remoteMediaStre.getAudioTracks) {
      remoteAudioStream = new MediaStream(call.remoteMediaStream.getAudioTracks());
    }

    if (call !== null && call !== void 0 && (_call$remoteMediaStre2 = call.remoteMediaStream) !== null && _call$remoteMediaStre2 !== void 0 && _call$remoteMediaStre2.getVideoTracks) {
      remoteVideoStream = new MediaStream(call.remoteMediaStream.getVideoTracks());
    }

    if (call !== null && call !== void 0 && (_call$members = call.members) !== null && _call$members !== void 0 && (_call$members$members = _call$members.membersCollection) !== null && _call$members$members !== void 0 && _call$members$members.members) {
      Object.values(call.members.membersCollection.members).forEach(m => {
        // only count user as active participant if they are connected
        if (m.isInMeeting) {
          activeParticipantsCount += 1;
        }

        memberships.push(Membership({
          audioMuted: m.audioMuted,
          isInitiator: m.isInitiator,
          hydraId: m.personId,
          id: m.id,
          state: m.status,
          videoMuted: m.videoMuted
        }));
      });
    }

    if ((_call$locusInfo = call.locusInfo) !== null && _call$locusInfo !== void 0 && (_call$locusInfo$fullS = _call$locusInfo.fullState) !== null && _call$locusInfo$fullS !== void 0 && _call$locusInfo$fullS.lastActive) {
      var _call$locusInfo2, _call$locusInfo2$full;

      startTime = Date.parse((_call$locusInfo2 = call.locusInfo) === null || _call$locusInfo2 === void 0 ? void 0 : (_call$locusInfo2$full = _call$locusInfo2.fullState) === null || _call$locusInfo2$full === void 0 ? void 0 : _call$locusInfo2$full.lastActive);
    } else {
      startTime = Date.now();
    }
  } catch (e) {// Do nothing
  }

  return {
    instance: call,
    locusUrl: call.locusUrl,
    direction: call.direction,
    remoteMediaStream: call.remoteMediaStream,
    localMediaStream: call.localMediaStream,
    startTime,
    memberships,
    activeParticipantsCount,
    remoteAudioStream,
    remoteVideoStream,
    ...constructCallStatus(call)
  };
}

/* eslint no-use-before-define: ["error", { "functions": false }] */
const UPDATE_STATUS = 'media/UPDATE_STATUS';
const DISMISS_INCOMING_CALL = 'media/DISMISS_INCOMING_CALL';
const STORE_CALL = 'media/STORE_CALL';
const UPDATE_CALL_STATUS = 'media/UPDATE_CALL_STATUS';
const UPDATE_CALL_ERROR = 'media/UPDATE_CALL_ERROR';
const REMOVE_CALL = 'media/REMOVE_CALL';
const CHECKING_WEB_RTC_SUPPORT = 'media/CHECKING_WEB_RTC_SUPPORT';
const UPDATE_WEBRTC_SUPPORT = 'media/UPDATE_WEBRTC_SUPPORT';

const tap = promise => arg => Promise.resolve().then(promise(arg)).then(() => arg);
/* Actions */


function checkingWebRTCSupport() {
  return {
    type: CHECKING_WEB_RTC_SUPPORT
  };
}

function removeCall(id) {
  return {
    type: REMOVE_CALL,
    payload: {
      id
    }
  };
}

function storeCall({
  call,
  id,
  destination
}) {
  // check if this is a locus replaced call
  return {
    type: STORE_CALL,
    payload: {
      id,
      call: constructCallObject(call),
      destination
    }
  };
}

function updateCallError({
  call,
  error,
  id
}) {
  return {
    type: UPDATE_CALL_ERROR,
    payload: {
      id: id || call.id,
      error
    }
  };
}

function updateCallStatus({
  call,
  id,
  eventName
}) {
  return {
    type: UPDATE_CALL_STATUS,
    payload: {
      id,
      call: constructCallObject(call),
      eventName
    }
  };
}

function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}
/* Exported Actions */

/**
 * Accepts an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */


function acceptIncomingCall(incomingCall, {
  sdkAdapter,
  destinationId,
  cleanUp
}) {
  return dispatch => {
    const {
      meetingsAdapter
    } = sdkAdapter;
    return Promise.resolve().then(() => meetingsAdapter.datasource.meetings.getMeetingByType('locusUrl', incomingCall.locusUrl)).then(meeting => {
      const bye = meeting.leave; // eslint-disable-next-line no-param-reassign

      meeting.leave = (...args) => bye.bind(meeting)(...args).then(() => dispatch(removeCall(incomingCall.id))).then(() => dispatch(cleanUp())) // eslint-disable-next-line no-param-reassign
      .finally(() => {
        meeting.leave = bye.bind(meeting);
      });

      return meeting;
    }).then(meeting => meetingsAdapter.getLocalMedia(meeting.id).then(({
      localAudio,
      localVideo
    }) => meetingsAdapter.fetchMeetingTitle(destinationId).then(title => {
      meetingsAdapter.meetings[meeting.id] = {
        ID: meeting.id,
        title,
        localAudio,
        localVideo,
        localShare: null,
        remoteAudio: null,
        remoteVideo: null,
        remoteShare: null
      };
      return meeting;
    }))).then(tap(meeting => {
      processCall({
        dispatch,
        call: { ...meeting
        },
        destinationId
      });
    })).then(tap(meeting => dispatch(updateCallStatus({
      call: { ...meeting,
        hasJoinedOnThisDevice: true
      },
      id: meeting.id
    })))).then(tap(meeting => meetingsAdapter.joinMeeting(meeting.id))).catch(err => updateCallError({
      call: incomingCall,
      error: err
    }));
  };
}
/**
 * Does a spark API request for existing calls and stores them
 * @param {object} sparkInstance
 * @returns {Promise}
 */

function checkCurrentCalls(sparkInstance) {
  return dispatch => sparkInstance.phone.listActiveCalls().then(results => Promise.all(results.map(callObject => Promise.resolve(processCall({
    dispatch,
    call: callObject
  })))));
}
/**
 * Check for browser webRTC support
 *
 *  @param {object} sparkInstance
 *  @returns {Promise}
 */

function checkWebRTCSupport(sparkInstance) {
  return dispatch => {
    if (sparkInstance.phone) {
      dispatch(checkingWebRTCSupport());
      return sparkInstance.phone.isCallingSupported().then(supported => dispatch(updateWebRTCSupport(supported)));
    }

    return Promise.resolve();
  };
}
/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Thunk}
 */

function declineIncomingCall(incomingCall, {
  meetingsAdapter
}) {
  const {
    meetings
  } = meetingsAdapter.datasource;
  return dispatch => {
    const meeting = meetings.getMeetingByType('id', incomingCall.id);
    if (meeting) meeting.decline();
    dispatch(removeCall(incomingCall.id));
    return Promise.resolve();
  };
}
/**
 * Dismisses an incoming call, marking it so.
 * Note: This does not decline the call, just for tracking purposes
 * @param {string} id
 * @returns {object}
 */

function dismissIncomingCall(id) {
  return {
    type: DISMISS_INCOMING_CALL,
    payload: {
      id
    }
  };
}
/**
 * Hangs up and removes call
 * @param {object} call
 * @returns {Promise}
 */

function hangupCall({
  call,
  id
}) {
  return dispatch => {
    // Don't update call states after hangup
    call.off(); // Only call.hangup() when local user wants to hangup.
    // SDK handles .hangup() when call becomes `inactive`

    return call.hangup().then(() => dispatch(removeCall(id))).catch(() => dispatch(removeCall(id)));
  };
}
/**
 * Listens for all call events from phone plugin and handles them
 * @param {Object} sparkInstance
 * @returns {Promise}
 */

function listenForCalls(sparkInstance) {
  return dispatch => {
    dispatch(updateStatus({
      isListening: true,
      isListeningToIncoming: true
    }));
    return Promise.all([handleIncomingCalls(sparkInstance), handleCreatedCalls(sparkInstance, dispatch)]);
  };
}

const getMeeting = ({
  sdkAdapter: {
    meetingsAdapter
  },
  destination
}) => new Promise(resolve => {
  meetingsAdapter.createMeeting(destination).pipe(first()).subscribe(({
    ID
  }) => resolve(meetingsAdapter.datasource.meetings.getMeetingByType('id', ID)));
}).then(tap(meeting => meetingsAdapter.datasource.meetings.meetingCollection.set(meeting))).then(meeting => meetingsAdapter.getLocalMedia(meeting.id).then(({
  localAudio,
  localVideo
}) => meetingsAdapter.fetchMeetingTitle(destination).then(title => {
  // eslint-disable-next-line no-param-reassign
  meetingsAdapter.meetings[meeting.id] = {
    ID: meeting.id,
    title,
    localAudio,
    localVideo,
    localShare: null,
    remoteAudio: null,
    remoteVideo: null,
    remoteShare: null
  };
  return meeting;
})));
/**
 * Call a user with an email address or userId
 *
 * @export
 * @param {Object} sdkAdapter
 * @param {String} data.destination
 * @returns {Promise}
 */


function placeCall(sdkAdapter, {
  destination,
  cleanUp
}) {
  const {
    meetingsAdapter
  } = sdkAdapter;
  return dispatch => getMeeting({
    sdkAdapter,
    destination
  }).then(tap(meeting => processCall({
    dispatch,
    call: { ...meeting
    },
    destination
  }))).then(meeting => {
    const bye = meeting.leave; // eslint-disable-next-line no-param-reassign

    meeting.leave = (...args) => bye.bind(meeting)(...args).then(() => dispatch(removeCall(meeting.id))).then(() => dispatch(cleanUp())) // eslint-disable-next-line no-param-reassign
    .finally(() => {
      meeting.leave = bye.bind(meeting);
    });

    return meeting;
  }).then(tap(meeting => meetingsAdapter.joinMeeting(meeting.id)));
}
/**
 * Registers the client for media/phone
 * @param {object} sparkInstance
 * @returns {Promise}
 */

function registerClient(sparkInstance) {
  return (dispatch, getState) => {
    const {
      media
    } = getState();

    if (!media.status.isRegistered && !media.status.isRegistering) {
      dispatch(updateStatus({
        isRegistering: true
      }));
      return sparkInstance.phone.register().then(() => {
        const status = {
          isRegistered: true,
          isRegistering: false
        };
        dispatch(updateStatus(status));
        return status;
      });
    }

    return Promise.resolve(media.status);
  };
}
/**
 * Process and store a call object from outside widgets
 * @param {Object} call
 * @returns {Function}
 */

function storeExternalCall(call) {
  return dispatch => {
    const {
      id
    } = processCall({
      dispatch,
      call
    });
    return {
      id,
      call
    };
  };
}
/* Helper Functions */

/**
 * Processes a call by binding events and storing
 * @param {*} params.dispatch
 * @param {Object} params.meeting
 * @returns {Object} {id, call}
 */

function processCall({
  dispatch,
  call,
  destination
}) {
  const value = {
    call,
    id: call.id,
    destination
  };
  dispatch(storeCall(value));
  return value;
}
/**
 * Sets up event listener for the 'call:incoming' phone event
 * @param {object} sparkInstance
 * @param {object} dispatch
 * @returns {Promise}
 */


function handleIncomingCalls(sparkInstance) {
  return sparkInstance.phone.on('call:incoming', incomingCall => {
    // If we make an outbound call via the widget, when the remote party answers,
    // we get a call:incoming notification when they connect
    if (incomingCall.direction === 'out') {
      return false;
    }

    return incomingCall.acknowledge();
  });
}
/**
 * Sets up event listener for the 'meeting:added' phone event
 * @param {object} sparkInstance
 * @param {object} dispatch
 * @returns {Promise}
 */


function handleCreatedCalls(sparkInstance, dispatch) {
  const processMeeting = meeting => {
    const call = { ...meeting,
      direction: 'in',
      hasJoinedOnThisDevice: false
    };
    processCall({
      dispatch,
      call
    });
  };

  const getMeetingById = ({
    id
  }) => sparkInstance.meetings.getMeetingByType('id', id);

  sparkInstance.meetings.on('meeting:added', ({
    meeting,
    type
  }) => {
    if (['JOIN', 'INCOMING'].find(TYPE => type === TYPE)) {
      meeting.members.on('members:update', () => {
        setTimeout(() => {
          const call = {
            id: meeting.id,
            ...getMeetingById(meeting)
          };
          processMeeting(call);
        }, 0);
      });
      processMeeting(meeting);
    }
  });
  return Promise.resolve();
}

var enhancer = compose(setWrappedDisplayName('WithMedia'), connect(state => ({
  sparkInstance: state.spark.get('spark'),
  media: state.media
}), dispatch => bindActionCreators({
  checkCurrentCalls,
  checkWebRTCSupport,
  listenForCalls,
  registerClient
}, dispatch)), lifecycle({
  componentWillReceiveProps(nextProps) {
    const {
      media,
      sparkInstance
    } = nextProps;

    if (sparkInstance) {
      if (!media.webRTC.hasCheckedSupport) {
        nextProps.checkWebRTCSupport(sparkInstance);
      } else if (!media.status.isRegistered && !media.status.isRegistering) {
        nextProps.registerClient(sparkInstance);
      } else if (!media.status.isListening) {
        // Check if there are any existing calls and store them
        nextProps.checkCurrentCalls(sparkInstance); // Listen for new calls

        nextProps.listenForCalls(sparkInstance);
      }
    }
  }

}));

const ErrorObject = Record({
  name: '',
  message: ''
});
const CallRecord = Record({
  instance: null,
  activeParticipantsCount: 0,
  direction: '',
  startTime: null,
  remoteAudioStream: null,
  remoteVideoStream: null,
  remoteMediaStream: null,
  localMediaStream: null,
  error: null,
  memberships: new List(),
  locusUrl: '',
  id: '',
  isCall: false,
  isActive: false,
  isIncoming: false,
  isInitiated: false,
  isConnected: false,
  isDismissed: false,
  isDeclined: false,
  isRinging: false,
  isReceivingAudio: false,
  isReceivingVideo: false,
  isSendingAudio: false,
  isSendingVideo: false,
  remoteAudioMuted: false,
  remoteVideoMuted: false,
  hasJoinedOnThisDevice: false,
  hasError: false
});
const WebRTCStatus = Record({
  hasCheckedSupport: false,
  isSupported: null
});
const MediaStatus = Record({
  isListening: false,
  isListeningToIncoming: false,
  isRegistered: false,
  isRegistering: false
});
const InitialState = Record({
  byDestination: Map(),
  byLocusUrl: Map(),
  byId: Map(),
  webRTC: WebRTCStatus(),
  status: MediaStatus()
});
const initialState = new InitialState();
function reducer(state = initialState, action) {
  switch (action.type) {
    case UPDATE_STATUS:
      return state.mergeIn(['status'], action.payload.status);

    case STORE_CALL:
      {
        const {
          call,
          destination,
          id
        } = action.payload;

        if (id) {
          const {
            locusUrl
          } = call;
          let updatedState = state.setIn(['byId', id], CallRecord(call).set('id', id));

          if (destination) {
            updatedState = updatedState.setIn(['byDestination', destination], id);
          }

          if (locusUrl) {
            updatedState = updatedState.setIn(['byLocusUrl', locusUrl], id);
          }

          return updatedState;
        }

        return state;
      }

    case UPDATE_CALL_STATUS:
      {
        let updatedState = state;
        const {
          call,
          id
        } = action.payload;

        if (id) {
          updatedState = updatedState.mergeIn(['byId', id], call);

          if (call.instance) {
            // Need to set instance object so it isn't manipulated by immutable
            updatedState = updatedState.setIn(['byId', id, 'instance'], call.instance);
          }
        } // Handle locus replacement


        const {
          instance
        } = call;

        if (instance && instance.locus && instance.locus.url && state.getIn(['byLocusUrl', instance.locus.url]) !== id) {
          // remove old locusUrl if it exists
          const oldUrl = state.get('byLocusUrl').keyOf(id);

          if (oldUrl) {
            updatedState = updatedState.removeIn(['byLocusUrl', oldUrl]);
          } // add new URL


          updatedState = updatedState.setIn(['byLocusUrl', instance.locus.url], id);
        }

        return updatedState;
      }

    case UPDATE_CALL_ERROR:
      {
        const {
          call,
          id,
          error
        } = action.payload;

        if (id) {
          return state.mergeIn(['byId', id], call).setIn(['byId', id, 'error'], new ErrorObject(error));
        }

        return state;
      }

    case DISMISS_INCOMING_CALL:
      return state.setIn(['byId', action.payload.id, 'isDismissed'], true);

    case REMOVE_CALL:
      {
        let updatedState = state;
        const byDestinationKey = state.get('byDestination').keyOf(action.payload.id);
        const byLocusUrl = state.get('byLocusUrl').keyOf(action.payload.id); // Also need to check if locusUrl exists for any other call objects

        state.get('byId').forEach((c, id) => {
          if (c.locusUrl === byLocusUrl) {
            updatedState = updatedState.deleteIn(['byId', id]).deleteIn(['byDestination', state.get('byDestination').keyOf(id)]).deleteIn(['byId', id]);
          }
        });
        updatedState = updatedState.deleteIn(['byId', action.payload.id]).deleteIn(['byDestination', byDestinationKey]).deleteIn(['byLocusUrl', byLocusUrl]);
        return updatedState;
      }

    case CHECKING_WEB_RTC_SUPPORT:
      return state.setIn(['webRTC', 'hasCheckedSupport'], true);

    case UPDATE_WEBRTC_SUPPORT:
      return state.setIn(['webRTC', 'isSupported'], action.payload.supported);

    default:
      return state;
  }
}

export default reducer;
export { CHECKING_WEB_RTC_SUPPORT, CallRecord, DISMISS_INCOMING_CALL, REMOVE_CALL, STORE_CALL, UPDATE_CALL_ERROR, UPDATE_CALL_STATUS, UPDATE_STATUS, UPDATE_WEBRTC_SUPPORT, acceptIncomingCall, checkCurrentCalls, checkWebRTCSupport, constructCallObject, declineIncomingCall, dismissIncomingCall, enhancer, hangupCall, initialState, listenForCalls, placeCall, registerClient, storeCall, storeExternalCall };
//# sourceMappingURL=index.js.map
