import { compose, lifecycle } from 'recompose';
import { constructWebexEnhancer, withIntl } from '@webex/webex-widget-base';
import { fromJS } from 'immutable';
import { combineReducers, bindActionCreators } from 'redux';
import conversation, { deleteActivity, getActivitiesFromThreadAndNonThreadCollections, acknowledgeActivityOnServer, createConversation, getConversation as getConversation$1, loadMissingActivities, loadPreviousMessages, resetConversation } from '@webex/redux-module-conversation';
import activity, { addFiles, removeInflightActivity, retryFailedActivity } from '@webex/redux-module-activity';
import avatar, { fetchAvatarsForUsers } from '@webex/redux-module-avatar';
import flags, { fetchFlags, flagActivity, removeFlagFromServer } from '@webex/redux-module-flags';
import indicators, { setTyping } from '@webex/redux-module-indicators';
import Notifications, { reducer as reducer$1, createNotification } from '@webex/react-container-notifications';
import MessageComposer, { reducer as reducer$2 } from '@webex/react-container-message-composer';
import presence, { subscribeToPresenceUpdates, unsubscribeFromPresenceUpdates } from '@webex/redux-module-presence';
import share from '@webex/redux-module-share';
import spark from '@webex/react-redux-spark';
import features, { getFeature } from '@webex/redux-module-features';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import Dropzone from 'react-dropzone';
import classNames from 'classnames';
import { throttle, debounce, filter, has } from 'lodash';
import { autobind } from 'core-decorators';
import { FEATURES_DEVELOPER, FEATURES_WIDGET_ADAPTIVE_CARD, constructHydraId, hydraTypes, API_ACTIVITY_TYPE, API_ACTIVITY_VERB, ACTIVITY_OBJECT_CONTENT_CATEGORY_IMAGES, CARD_CONTAINS_IMAGE, constructFiles, checkMaxFileSize } from '@webex/react-component-utils';
import ConfirmationModal from '@webex/react-component-confirmation-modal';
import Cover from '@webex/react-component-cover';
import LoadingScreen from '@webex/react-component-loading-screen';
import ActivityList from '@webex/react-container-activity-list';
import ReadReceipts from '@webex/react-container-read-receipts';
import ScrollingActivity from '@webex/react-container-scrolling-activity';
import ErrorDisplay from '@webex/react-component-error-display';
import wrapConversationMercury from '@webex/react-hoc-conversation-mercury';
import { Button, Icon } from '@momentum-ui/react';
import { connectToMercury } from '@webex/redux-module-mercury';
import { createSelector } from 'reselect';
import { defineMessages } from 'react-intl';

const UPDATE_WIDGET_STATE = 'widget-message/UPDATE_WIDGET_STATE';
const SET_SCROLL_POSITION = 'widget-message/SET_SCROLL_POSITION';
const RESET_WIDGET_STATE = 'widget-message/RESET_WIDGET_STATE';
function updateWidgetState(state) {
  return {
    type: UPDATE_WIDGET_STATE,
    payload: {
      state
    }
  };
}
function setScrollPosition(scrollPosition) {
  return {
    type: SET_SCROLL_POSITION,
    payload: {
      scrollPosition
    }
  };
}
function resetWidgetState() {
  return {
    type: RESET_WIDGET_STATE
  };
}
function showScrollToBottomButton(isVisible) {
  return dispatch => {
    dispatch(updateWidgetState({
      showScrollToBottomButton: isVisible
    }));
  };
}
/**
 * Sets if the widget has been scrolled up from the bottom
 *
 * @export
 * @param {boolean} isScrolledUp
 * @returns {Thunk}
 */

function setScrolledUp(isScrolledUp) {
  return (dispatch, getState) => {
    const {
      widgetMessage
    } = getState(); // Since we are triggering this every scroll, let's not attack
    // our store if we don't need to

    if (!isScrolledUp) {
      /* eslint-disable operator-linebreak */
      if (widgetMessage.get('hasNewMessage') || widgetMessage.get('hasScrolledUp') || widgetMessage.get('showScrollToBottomButton')) {
        dispatch(updateWidgetState({
          hasNewMessage: false,
          hasScrolledUp: false,
          showScrollToBottomButton: false
        }));
      }
    }
    /* eslint-disable operator-linebreak */
    else if (!widgetMessage.get('hasScrolledUp') || !widgetMessage.get('showScrollToBottomButton')) {
        dispatch(updateWidgetState({
          hasScrolledUp: true,
          showScrollToBottomButton: true
        }));
      }
  };
}
function updateHasNewMessage(hasNew) {
  return dispatch => {
    dispatch(updateWidgetState({
      hasNewMessage: hasNew
    }));
  };
}
function confirmDeleteActivity(activityId) {
  return dispatch => {
    dispatch(updateWidgetState({
      deletingActivityId: activityId,
      showAlertModal: true
    }));
  };
}
function hideDeleteModal() {
  return dispatch => {
    dispatch(updateWidgetState({
      deletingActivityId: null,
      showAlertModal: false
    }));
  };
}
function deleteActivityAndDismiss(conversation, activity, spark) {
  return dispatch => {
    dispatch(deleteActivity(conversation, activity, spark)).then(() => {
      dispatch(hideDeleteModal());
    });
  };
}

const initialState = fromJS({
  deletingActivityId: null,
  isListeningToActivity: false,
  isListeningToBufferState: false,
  isListeningToTyping: false,
  showAlertModal: false,
  showScrollToBottomButton: false,
  hasNewMessage: false,
  scrollPosition: {},
  hasFetchedAdaptiveCardFeature: false
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case RESET_WIDGET_STATE:
      return initialState;

    case UPDATE_WIDGET_STATE:
      return state.merge(action.payload.state);

    case SET_SCROLL_POSITION:
      return state.set('scrollPosition', action.payload.scrollPosition);

    default:
      return state;
  }
}
const reducers = {
  activity,
  avatar,
  conversation,
  flags,
  indicators,
  notifications: reducer$1,
  share,
  spark,
  messageComposer: reducer$2,
  features,
  presence,
  widgetMessage: reducer
};
combineReducers(reducers);

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

const getSparkInstance = (state, props) => props.sparkInstance || state.spark.get('spark');

const getSparkState = state => state.spark.get('status');

const getConversation = state => state.conversation;

const getParticipants = state => state.conversation.get('participants');

const getConversationThreadActivities = state => state.conversation.get('threadActivities');

const getConversationNonThreadActivities = state => state.conversation.get('sortNonThreadActivities');

const getActivities = createSelector([getConversationThreadActivities, getConversationNonThreadActivities], getActivitiesFromThreadAndNonThreadCollections);

const getConversationOldestPublishedDate = state => state.conversation.get('oldestPublishedDate');

const getUsers = state => state.users;

const getFeatures$1 = state => state.features;

function constructSpace(space) {
  const lastActivityTimestamp = space.get('lastReadableActivityDate');
  const tags = space.get('tags');
  const id = space.get('id');
  return {
    id,
    type: tags && tags.includes('ONE_ON_ONE') ? 'direct' : 'group',
    lastActivityTimestamp,
    published: space.get('published'),
    isLocked: tags && tags.includes('LOCKED')
  };
}

function constructOneOnOne(space, currentUser) {
  const thisSpace = constructSpace(space);
  const currentUserEmail = currentUser.email;
  const otherUsers = space.get('participants').find(p => p.get('emailAddress') !== currentUserEmail);

  if (otherUsers) {
    thisSpace.toUser = otherUsers;
    thisSpace.name = otherUsers.get('displayName');
  }

  return thisSpace;
}

function constructGroup(space) {
  const thisSpace = constructSpace(space);
  thisSpace.name = space.get('displayName');
  const team = space.get('team');

  if (team) {
    thisSpace.teamName = team.get('displayName');
    thisSpace.teamColor = team.get('color');
    thisSpace.teamId = team.get('id');
  }

  return thisSpace;
}

const getSpace = createSelector([getConversation, getUsers], (conversation, users) => {
  const space = conversation;
  const currentUser = users.getIn(['byId', users.get('currentUserId')]);

  if (space.getIn(['status', 'isOneOnOne'])) {
    return constructOneOnOne(space, currentUser);
  }

  return constructGroup(space);
});
const getActivitiesStatus = createSelector([getConversation], conversation => conversation.get('status').toJS());
const getMessageWidgetProps = createSelector([getSparkInstance, getSparkState, getConversation, getConversationOldestPublishedDate, getParticipants, getActivities, getSpace, getActivitiesStatus, getFeatures$1], (sparkInstance, sparkState, conversation, oldestPublishedDate, participants, activities, space, activitiesStatus, features) => ({
  activities: activities.toJS(),
  activityCount: activities.count(),
  activitiesStatus,
  lastActivity: activities.last(),
  firstActivity: activities.first(),
  oldestPublishedDate,
  conversationId: conversation.get('id'),
  participants: participants.toJS(),
  space,
  sparkInstance,
  sparkState: sparkState.toJS(),
  features
}));

function getFeatures(props) {
  const {
    sparkInstance,
    widgetMessage
  } = props;
  const hasFetchedAdaptiveCardFeature = widgetMessage.get('hasFetchedAdaptiveCardFeature'); // Initial fetching of adaptive card feature

  if (!hasFetchedAdaptiveCardFeature) {
    props.updateWidgetState({
      hasFetchedAdaptiveCardFeature: true
    });
    props.getFeature(FEATURES_DEVELOPER, FEATURES_WIDGET_ADAPTIVE_CARD, sparkInstance);
  }
}

function setup(props) {
  const {
    sparkInstance,
    sparkState
  } = props;

  if (sparkInstance && sparkState.authenticated && sparkState.registered && !sparkState.hasError) {
    getFeatures(props);
  }
}
var setup$1 = compose(connect(getMessageWidgetProps, dispatch => bindActionCreators({
  connectToMercury,
  getFeature,
  updateWidgetState
}, dispatch)), lifecycle({
  componentWillMount() {
    setup(this.props);
  },

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  },

  componentWillReceiveProps(nextProps) {
    setup(nextProps, this.props);
  }

}));

var enhancers = [setup$1];

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".widget-message__banner__LmJhbm5l {\n  width: 100%;\n  height: 12px;\n  background-color: #049fd9;\n}\n\n.widget-message__activityListWrapper__LmJhbm5l {\n  position: relative;\n  display: flex;\n  width: 100%;\n  height: 0; /* Shrinks the list area so that flex can grow it to fill the space */\n  overflow: hidden;\n  flex: 1;\n  flex-direction: column;\n}\n\n.widget-message__messageComposerWrapper__LmJhbm5l {\n  flex: 0 0 auto;\n  min-height: 40px;\n  background-color: #f5f5f5;\n}\n\n.widget-message__dropzone__LmJhbm5l {\n  display: flex;\n  width: 100%;\n  overflow: hidden;\n  flex: 1 1 auto;\n  flex-direction: column;\n}\n\n.widget-message__mainArea__LmJhbm5l {\n  display: flex;\n  width: 100%;\n  overflow: hidden;\n  flex: 1 1 auto;\n  flex-direction: column;\n}\n\n.widget-message__activeDropzone__LmJhbm5l {\n  border: 0 none;\n}\n\n.widget-message__activeDropzone__LmJhbm5l .widget-message__dropzoneMessage__LmJhbm5l {\n  display: flex;\n}\n\n.widget-message__indicators__LmJhbm5l {\n  display: flex;\n  min-height: 40px;\n  padding-bottom: 20px;\n  font-size: 17px;\n  white-space: nowrap;\n  justify-content: center;\n}\n\n.widget-message__scrollToBottom__LmJhbm5l {\n  position: absolute;\n  bottom: 10px;\n  left: 50%;\n  text-align: center;\n  white-space: nowrap;\n  cursor: pointer;\n  opacity: 0.5;\n  transition: all 0.5s ease-in;\n}\n";
var styles = {"banner":"widget-message__banner__LmJhbm5l","activityListWrapper":"widget-message__activityListWrapper__LmJhbm5l","messageComposerWrapper":"widget-message__messageComposerWrapper__LmJhbm5l","dropzone":"widget-message__dropzone__LmJhbm5l","mainArea":"widget-message__mainArea__LmJhbm5l","activeDropzone":"widget-message__activeDropzone__LmJhbm5l","dropzoneMessage":"widget-message__dropzoneMessage__LmJhbm5l","indicators":"widget-message__indicators__LmJhbm5l","scrollToBottom":"widget-message__scrollToBottom__LmJhbm5l"};
styleInject(css_248z);

/*
 * WidgetMessage Messages
 *
 * This contains all the text for the FeaturePage component.
 */
var messages$1 = defineMessages({
  newMessagesMessage: {
    id: 'ciscospark.container.message.newMessages.message',
    defaultMessage: 'New Messages'
  },
  deleteAlertTitle: {
    id: 'ciscospark.container.message.deleteAlert.title',
    defaultMessage: 'Delete'
  },
  deleteAlertBody: {
    id: 'ciscospark.container.message.deleteAlert.body',
    defaultMessage: 'Are you sure you want to delete this message?'
  },
  deleteButtonLabel: {
    id: 'ciscospark.container.message.deleteAlert.confirmButton',
    defaultMessage: 'Delete'
  },
  cancelButtonLabel: {
    id: 'ciscospark.container.message.deleteAlert.cancelButton',
    defaultMessage: 'Cancel'
  },
  messageComposerPlaceholder: {
    id: 'ciscospark.container.message.messageComposer.placeholder',
    defaultMessage: 'Send a message to {displayName}'
  },
  dropzoneCoverMessage: {
    id: 'ciscospark.container.message.dropzone.coverMessage',
    defaultMessage: 'Drag and drop your files here'
  },
  errorConversation: {
    id: 'ciscospark.container.message.error.noConversation',
    defaultMessage: 'Conversation Not Available'
  },
  scrollToBottom: {
    id: 'ciscospark.container.message.scrollToBottom',
    defaultMessage: 'Click to scroll to latest messages'
  },
  sharedCards: {
    id: 'ciscospark.container.message.sharedCards',
    defaultMessage: '{cardsLength, plural, =1 {Responded with a card} other {Responded with # cards}}'
  },
  sharedPhotos: {
    id: 'ciscospark.container.message.sharedPhotos',
    defaultMessage: '{imagesLength, plural, =1 {Shared a photo} other {Shared # photos}}'
  }
});

const eventNames = {
  SPACES_READ: 'rooms:read',
  SPACES_UNREAD: 'rooms:unread',
  MESSAGES_CREATED: 'messages:created'
};
/**
 * Constructs an event detail object for messages:created
 * @export
 * @param {Object} activity from mercury
 * @param {Object} toUser
 * @returns {Object} constructed event
 */

function constructMessagesEventData(activity, toUser) {
  const roomType = activity.target.tags.includes('ONE_ON_ONE') ? 'direct' : 'group';
  let files, toPersonEmail, toPersonId;

  if (roomType === 'direct' && toUser) {
    toPersonEmail = toUser.emailAddress;
    toPersonId = constructHydraId(hydraTypes.PEOPLE, toUser.id);
  }

  let mentionedPeople = activity.object.mentions;

  if (mentionedPeople && mentionedPeople.items.length) {
    mentionedPeople = mentionedPeople.items.map(people => ({
      id: constructHydraId(hydraTypes.PEOPLE, people.id)
    }));
  } // Files need to be decrypted and converted into a usable URL


  if (activity.object.files && activity.object.files.items.length) {
    files = activity.object.files.items;
  }

  const personId = constructHydraId(hydraTypes.PEOPLE, activity.actor.id);
  return {
    actorId: personId,
    actorName: activity.actor.displayName,
    id: constructHydraId(hydraTypes.MESSAGE, activity.id),
    roomId: constructHydraId(hydraTypes.ROOM, activity.target.id),
    roomType: activity.target.tags.includes('ONE_ON_ONE') ? 'direct' : 'group',
    text: activity.object.displayName,
    html: activity.object.content,
    files,
    personId,
    personEmail: activity.actor.emailAddress,
    created: activity.published,
    mentionedPeople,
    toPersonId,
    toPersonEmail
  };
}
/**
 * Creates an room data object for DOM and event hooks
 *
 * @export
 * @param {Object} space
 * @param {Object} activity
 * @returns {Object}
 */

function constructRoomsEventData(space, activity) {
  return {
    id: constructHydraId(hydraTypes.ROOM, space.id),
    actorId: constructHydraId(hydraTypes.PEOPLE, activity.actor.id),
    actorName: activity.actor.displayName,
    title: space.name,
    type: space.type,
    isLocked: space.isLocked,
    teamId: constructHydraId(hydraTypes.TEAM, space.teamId),
    lastActivity: activity && activity.published || space.lastActivityTimestamp,
    created: space.published
  };
}

/* eslint-disable import/prefer-default-export */
/**
 * Processes a mercury event "event:conversation.activity"
 * @param {object} event
 * @param {object} eventNames
 * @param {string} currentUserId
 * @param {string} space
 * @param {object} actions
 * @param {function} actions.handleEvent
 * @param {function} actions.removeInflightActivity
 * @param {function} actions.updateHasNewMessage
 */

function handleConversationActivityEvent(event, eventNames, currentUserId, space, actions) {
  const {
    activity
  } = event.data;
  const toUser = space.toUser && space.toUser.toJS();
  const isSelf = activity.actor.id === currentUserId; // Ignore activity from other conversations

  if (activity.target && activity.target.id === space.id) {
    // Reply activities are not currently supported
    if (activity.type === API_ACTIVITY_TYPE.REPLY) {
      return;
    }

    switch (activity.verb) {
      case API_ACTIVITY_VERB.ACKNOWLEDGE:
        if (activity.object.objectType === 'activity' && isSelf) {
          actions.handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
        }

        break;

      case API_ACTIVITY_VERB.SHARE:
      case API_ACTIVITY_VERB.POST:
        if (isSelf) {
          // Remove the in flight activity that matches this
          actions.removeInflightActivity(activity.clientTempId);
        } else {
          actions.updateHasNewMessage(true);
          actions.handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
        } // Emit message:created event


        actions.handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, toUser));
        break;
    }
  }
}

var _class;
const injectedPropTypes = {
  avatar: PropTypes.object.isRequired,
  activity: PropTypes.object.isRequired,
  activitiesStatus: PropTypes.shape({
    isLoadingHistoryUp: PropTypes.bool
  }).isRequired,
  conversation: PropTypes.object.isRequired,
  composerActions: PropTypes.shape({
    attachFiles: PropTypes.bool
  }).isRequired,
  flags: PropTypes.object.isRequired,
  sparkInstance: PropTypes.object,
  widgetMessage: PropTypes.object.isRequired,
  acknowledgeActivityOnServer: PropTypes.func.isRequired,
  addFiles: PropTypes.func.isRequired,
  confirmDeleteActivity: PropTypes.func.isRequired,
  createConversation: PropTypes.func.isRequired,
  createNotification: PropTypes.func.isRequired,
  deleteActivityAndDismiss: PropTypes.func.isRequired,
  fetchAvatarsForUsers: PropTypes.func.isRequired,
  fetchFlags: PropTypes.func.isRequired,
  flagActivity: PropTypes.func.isRequired,
  getConversation: PropTypes.func.isRequired,
  hideDeleteModal: PropTypes.func.isRequired,
  loadMissingActivities: PropTypes.func.isRequired,
  loadPreviousMessages: PropTypes.func.isRequired,
  oldestPublishedDate: PropTypes.string.isRequired,
  removeFlagFromServer: PropTypes.func.isRequired,
  retryFailedActivity: PropTypes.func.isRequired,
  removeInflightActivity: PropTypes.func.isRequired,
  setScrollPosition: PropTypes.func.isRequired,
  setScrolledUp: PropTypes.func.isRequired,
  setTyping: PropTypes.func.isRequired,
  showScrollToBottomButton: PropTypes.func.isRequired,
  updateHasNewMessage: PropTypes.func.isRequired,
  updateWidgetState: PropTypes.func.isRequired,
  space: PropTypes.object.isRequired,
  features: PropTypes.object.isRequired,
  getFeature: PropTypes.func.isRequired,
  participants: PropTypes.array.isRequired,
  activities: PropTypes.object.isRequired,
  conversationId: PropTypes.string
};
const ownPropTypes = {
  destination: PropTypes.shape({
    // Email or Hydra ID
    id: PropTypes.string.isRequired,
    type: PropTypes.oneOf(['email', 'spaceId', 'userId'])
  }).isRequired,
  hasAcknowledgementsDisabled: PropTypes.bool,
  muteNotifications: PropTypes.bool,
  onEvent: PropTypes.func,
  eventNames: PropTypes.object
};

const fetchMoreActivitiesIfNecessary = ({
  activitiesStatus,
  conversation,
  firstActivity,
  loadPreviousMessages: lpm,
  sparkInstance,
  setScrollPosition: ssp,
  oldestPublishedDate
}, activityList) => {
  if (activityList !== null && activityList !== void 0 && activityList.isScrolledToTop() && firstActivity.verb !== 'create' && !activitiesStatus.isLoadingHistoryUp) {
    // Store scroll position before loading messages so the window
    // doesn't jump after they load
    ssp({
      scrollTop: activityList.getScrollTop()
    });
    lpm(conversation.get('url'), oldestPublishedDate, sparkInstance);
  }
};
/**
 * MessageWidget Container
 * @extends Component
 */


let MessageWidget = (_class = class MessageWidget extends Component {
  /**
   * Check if activity list should scroll to bottom
   *
   * @param {object} props
   * @param {object} prevProps
   * @returns {boolean}
   */
  static shouldScrollToBottom(props, prevProps) {
    const {
      activityCount
    } = props;
    const prevActivitiesCount = prevProps.activityCount;

    if (activityCount && prevActivitiesCount === 0) {
      // Always scroll to the bottom when activities first load
      return true;
    } // Otherwise, don't scroll if we have scrolled up


    let shouldScrollToBottom = true;

    if (props.widgetMessage.get('hasScrolledUp')) {
      shouldScrollToBottom = false;
    }

    return shouldScrollToBottom;
  }

  constructor(props) {
    super(props);
    this.handleScroll = throttle(this.handleScroll, 250);
    this.handleMouseMove = debounce(this.handleMouseMove, 500, {
      leading: true,
      trailing: false
    });
  }

  componentDidMount() {
    this.eventNames = Object.assign({}, eventNames, this.props.eventNames); // To support changing destinations, we must reset the stores when mounting
    // so previous conversations to other destinations aren't displayed

    this.props.resetWidgetState(); // If our widget is instantiated with all the props loaded,
    // we can setup the conversation

    this.establishConversation(this.props);
  }

  componentWillReceiveProps(nextProps) {
    // This needs to fire here because props are loaded async via redux
    this.establishConversation(nextProps, this.props);
  }

  shouldComponentUpdate(nextProps) {
    const {
      props
    } = this;
    return nextProps.conversation !== props.conversation || nextProps.flags !== props.flags || nextProps.indicators !== props.indicators || nextProps.share !== props.share || nextProps.user !== props.user || nextProps.widgetMessage !== props.widgetMessage || nextProps.activity !== props.activity || nextProps.features !== props.features;
  }

  componentWillUpdate(nextProps) {
    const {
      props
    } = this;

    if (this.activityList && nextProps.activityCount !== props.activityCount) {
      this.scrollHeight = this.activityList.getScrollHeight();
    }
  }

  componentDidUpdate(prevProps) {
    const {
      props,
      activityList
    } = this;
    const {
      formatMessage
    } = this.props.intl;
    fetchMoreActivitiesIfNecessary(props, activityList);

    if (activityList) {
      const {
        activityCount,
        firstActivity
      } = props;
      let objectType;
      const prevActivitiesCount = prevProps.activityCount;
      const previousFirstActivity = prevProps.firstActivity;
      const lastActivityFromPrev = prevProps.lastActivity;
      const lastActivityFromThis = props.lastActivity;

      if (lastActivityFromThis) {
        objectType = lastActivityFromThis.object ? lastActivityFromThis.object.objectType : undefined;
      } // If new activity comes in


      if (lastActivityFromPrev && lastActivityFromThis && activityCount !== prevActivitiesCount && lastActivityFromPrev.id !== lastActivityFromThis.id && props.currentUser.id !== lastActivityFromThis.actor.id && objectType !== 'locusSessionSummary') {
        // Send notification of new message
        const avatars = props.avatar.get('items');
        let cardsLength = 0;
        let message;

        if (lastActivityFromThis.object) {
          message = lastActivityFromThis.object.displayName;

          if (lastActivityFromThis.object.cards && lastActivityFromThis.object.cards.length > 0) {
            cardsLength = lastActivityFromThis.object.cards.length;
            const sharedCardsNotificationMessage = formatMessage(messages$1.sharedCards, {
              cardsLength
            });

            if (lastActivityFromThis.verb === API_ACTIVITY_VERB.POST) {
              message = sharedCardsNotificationMessage;
            } else if (lastActivityFromThis.verb === API_ACTIVITY_VERB.SHARE && lastActivityFromThis.object.files && lastActivityFromThis.object.files.items && lastActivityFromThis.object.contentCategory === ACTIVITY_OBJECT_CONTENT_CATEGORY_IMAGES) {
              const cardImagesLength = lastActivityFromThis.object.files.items.filter(item => item.type === CARD_CONTAINS_IMAGE).length;
              const itemsLength = lastActivityFromThis.object.files.items.length;
              const sharedPhotosNotificationMessage = formatMessage(messages$1.sharedPhotos, {
                imagesLength: itemsLength - cardImagesLength
              });
              message = cardImagesLength === itemsLength ? sharedCardsNotificationMessage : sharedPhotosNotificationMessage;
            }
          }
        }

        const details = {
          username: lastActivityFromThis.actor.displayName,
          message,
          avatar: avatars.get(lastActivityFromThis.actor.id),
          alertType: lastActivityFromThis.alertType
        };
        props.createNotification(lastActivityFromThis.id, details);
      }

      this.updateScroll(firstActivity, previousFirstActivity, prevProps.widgetMessage.get('scrollPosition').scrollTop);

      if (MessageWidget.shouldScrollToBottom(props, prevProps)) {
        activityList.scrollToBottom();
      }
    }
  }

  componentWillUnmount() {
    this.props.unsubscribeFromPresenceUpdates(this.props.participants.map(p => p.id), this.props.sparkInstance);
  }
  /**
   * Processes the activities and fetches avatars for users
   * that have not been fetched yet
   *
   * @param {Object} props
   *
   */


  static getAvatarsFromActivityActors(props) {
    const {
      sparkInstance
    } = props;
    const participants = filter(props.activities, 'actor').map(activity => activity.actor.id);

    if (participants.length === 0) {
      return;
    }

    props.fetchAvatarsForUsers(participants, sparkInstance);
  }
  /**
   * Store activity list from child component
   *
   * @param {Object} ref
   * @returns {undefined}
   */


  getActivityList(ref) {
    this.activityList = ref;
  }
  /**
   * Once a conversation has been established, setup
   * actions need to happen for app state
   *
   * @param {any} conversation
   * @param {any} nextProps
   *
   */


  setupConversationActions(conversation, nextProps) {
    const {
      flags,
      sparkInstance,
      space,
      widgetMessage,
      conversationId
    } = nextProps;
    const {
      props
    } = this;

    if (!widgetMessage.get('isListeningToActivity')) {
      this.listenToNewActivity(space, sparkInstance);
    }

    if (!widgetMessage.get('isListeningToTyping')) {
      this.listenToTypingEvents(conversationId, sparkInstance);
    }

    if (flags && !flags.getIn(['status', 'hasFetched']) && !flags.getIn(['status', 'isFetching'])) {
      nextProps.fetchFlags(sparkInstance);
    } // We only want to fetch avatars when a new activity is seen


    const {
      activityCount
    } = nextProps;
    const prevActivitiesCount = props.activityCount;

    if (activityCount && activityCount !== prevActivitiesCount) {
      MessageWidget.getAvatarsFromActivityActors(nextProps);
    }

    if (nextProps.participants) {
      const userIds = nextProps.participants.map(p => p.id);
      this.props.subscribeToPresenceUpdates(userIds, sparkInstance);
    }

    if (!widgetMessage.get('isListeningToBufferState')) {
      this.listenToBufferState(conversation.get('url'), sparkInstance);
    }
  }
  /**
   * Update scroll position when activity list changes
   * @param {object} firstActivity
   * @param {object} previousFirstActivity
   * @param {number} prevScrollTop
   */


  updateScroll(firstActivity, previousFirstActivity, prevScrollTop) {
    const {
      activityList
    } = this;
    MessageWidget.getAvatarsFromActivityActors(this.props);

    if (firstActivity && previousFirstActivity && firstActivity.id !== previousFirstActivity.id) {
      activityList.setScrollTop(activityList.getScrollHeight() - this.scrollHeight + prevScrollTop);
    }
  }
  /**
   * Attempts to fetch and establish a conversation
   *
   * @param {object} props
   * @param {object} prevProps
   *
   * @memberOf MessageWidget
   *
   */


  establishConversation(props, prevProps) {
    const {
      destination,
      sparkInstance,
      sparkState,
      conversation,
      conversationId
    } = props;
    const {
      authenticated,
      registered
    } = sparkState; // Check if Spark instance and connections have been established

    if (sparkInstance && authenticated) {
      // Check if destination has changed
      if (destination && prevProps && prevProps.destination && (destination.id !== prevProps.destination.id || destination.type !== prevProps.destination.type)) {
        props.resetConversation();
        props.resetWidgetState();
        return;
      } // Check if conversation has been retrieved


      if (registered && !conversationId && !conversation.getIn(['status', 'isFetching'])) {
        if (destination.type === destinationTypes.SPACEID) {
          props.getConversation(destination.id, sparkInstance);
        }

        if (destination.type === destinationTypes.EMAIL || destination.type === destinationTypes.USERID) {
          props.createConversation([destination.id], sparkInstance);
        }
      }
    } // Setup once we have a conversation


    if (conversationId) {
      this.setupConversationActions(conversation, props);
    }
  }
  /**
   * Setup listeners for typing events
   *
   * @param {String} conversationId
   * @param {Object} sparkInstance
   * @returns {undefined}
   */


  listenToTypingEvents(conversationId, sparkInstance) {
    const {
      props
    } = this;
    props.updateWidgetState({
      isListeningToTyping: true
    });
    sparkInstance.internal.mercury.on('event:status.start_typing', event => {
      if (event.data.conversationId === conversationId) {
        props.setTyping(event.data.actor.id, true);
      }
    });
    sparkInstance.internal.mercury.on('event:status.stop_typing', event => {
      if (event.data.conversationId === conversationId) {
        props.setTyping(event.data.actor.id, false);
      }
    });
  }
  /**
   * Setup listeners for new activities
   *
   * @param {String} space
   * @param {Object} sparkInstance
   * @returns {undefined}
   */


  listenToNewActivity(space, sparkInstance) {
    const {
      props
    } = this;
    const {
      handleEvent
    } = this;
    const {
      currentUser
    } = props;

    if (currentUser) {
      props.updateWidgetState({
        isListeningToActivity: true
      });
      sparkInstance.internal.mercury.on('event:conversation.activity', event => {
        handleConversationActivityEvent(event, this.eventNames, currentUser.id, space, {
          handleEvent,
          removeInflightActivity: props.removeInflightActivity,
          updateHasNewMessage: props.updateHasNewMessage
        });
      });
    }
  }
  /**
   * Listens for mercury buffer state events and
   * fires off actions based on them
   * @param {string} conversationUrl
   * @param {object} sparkInstance
   * @returns {undefined}
   */


  listenToBufferState(conversationUrl, sparkInstance) {
    const {
      props
    } = this;
    props.updateWidgetState({
      isListeningToBufferState: true
    });
    sparkInstance.internal.mercury.on('event:mercury.buffer_state', event => {
      const {
        lastActivity
      } = props;

      if (has(event, 'data.bufferState.conversation') && event.data.bufferState.conversation === 'UNKNOWN') {
        // Mercury does not contain enough information about the conversation, refetch
        const sinceDate = lastActivity && lastActivity.published || null;
        props.loadMissingActivities(conversationUrl, sinceDate, sparkInstance);
      }
    });
  }

  acknowledgeLastActivity() {
    const {
      props
    } = this;
    const {
      conversation,
      hasAcknowledgementsDisabled,
      lastActivity,
      sparkInstance
    } = props;

    if (conversation.get('lastAcknowledgedActivityId') !== lastActivity.id) {
      if (!hasAcknowledgementsDisabled) {
        props.acknowledgeActivityOnServer(conversation, lastActivity, sparkInstance);
      }
    }
  }
  /**
   * Scroll activityList to bottom
   *
   * @returns {undefined}
   */


  handleScrollToBottom() {
    this.activityList.scrollToBottom();
  }
  /**
   * Additional actions after submitting a message
   *
   * @returns {undefined}
   */


  handleMessageSubmit() {
    this.activityList.scrollToBottom();
  }
  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   */


  handleEvent(name, data) {
    const {
      onEvent
    } = this.props;

    if (typeof onEvent === 'function') {
      this.props.onEvent(name, data);
    }
  }

  handleMouseMove() {
    const {
      activityList
    } = this;

    if (activityList.isScrolledToBottom()) {
      this.acknowledgeLastActivity();
    }
  }
  /**
   * Flag or unflag activity by Id
   *
   * @param {String} activityId
   * @returns {undefined}
   */


  handleActivityFlag(activityId) {
    const {
      props
    } = this;
    const {
      activities,
      flags,
      sparkInstance
    } = props;
    const activity = Object.values(activities).find(act => act.id === activityId);

    if (activity) {
      const foundFlag = flags.getIn(['flags', activity.url]);

      if (foundFlag && !foundFlag.get('isInFlight')) {
        props.removeFlagFromServer(foundFlag, sparkInstance);
      } else if (!foundFlag) {
        props.flagActivity(activity, sparkInstance);
      }
    }
  }
  /**
   * Displays modal confirming activity delete
   *
   * @param {String} activityId
   * @returns {undefined}
   */


  handleActivityDelete(activityId) {
    const {
      props
    } = this;
    props.confirmDeleteActivity(activityId);
  }
  /**
   * Does the actual deletion of the activity after confirmation modal
   *
   * @returns {undefined}
   */


  handleConfirmActivityDelete() {
    const {
      props
    } = this;
    const {
      activities,
      conversation,
      sparkInstance,
      widgetMessage
    } = props;
    const activityId = widgetMessage.get('deletingActivityId');
    const activity = Object.values(activities).find(act => act.id === activityId);

    if (activity) {
      props.deleteActivityAndDismiss(conversation, activity, sparkInstance);
    } else {
      props.hideDeleteModal();
    }
  }
  /**
   * Dismisses the confirmation modal
   *
   * @returns {undefined}
   */


  handleCancelActivityDelete() {
    this.props.hideDeleteModal();
  }

  handleActivityRetry(activityId) {
    const {
      props
    } = this;
    const {
      activity,
      sparkInstance
    } = this.props;
    const failedActivity = activity.getIn(['activityFailures', activityId]);
    return props.retryFailedActivity(failedActivity, sparkInstance);
  }
  /**
   * Adds dropped file into activity store
   *
   * @param {array} acceptedFiles
   * @returns {undefined}
   */


  handleFileDrop(acceptedFiles) {
    const {
      props
    } = this;
    const {
      activity,
      conversation,
      sparkInstance
    } = props;
    const files = constructFiles(acceptedFiles);

    if (files.length && checkMaxFileSize(files, props.addError, props.removeError)) {
      props.addFiles(conversation, activity, files, sparkInstance);
    }
  }
  /**
   * Perform actions when activity list scrolls
   *
   * @returns {undefined}
   */


  handleScroll() {
    const {
      props,
      activityList
    } = this;

    if (activityList.isScrolledToBottom()) {
      props.setScrolledUp(false);

      if (document.hasFocus()) {
        this.acknowledgeLastActivity();
      }
    } else {
      props.setScrolledUp(true);
    }

    fetchMoreActivitiesIfNecessary(props, activityList);
  }
  /**
   * Renders the conversation area of the widget
   *
   * @returns {object}
   */


  render() {
    const {
      props
    } = this;
    const {
      conversation,
      conversationId,
      composerActions,
      sparkInstance,
      currentUser,
      muteNotifications,
      widgetMessage,
      features
    } = props;
    const {
      formatMessage
    } = this.props.intl;

    if (conversation && conversationId) {
      const isLoadingHistoryUp = conversation.getIn(['status', 'isLoadingHistoryUp']);
      const displayName = conversation.get('displayName');
      return /*#__PURE__*/React.createElement(Dropzone, {
        activeClassName: styles.activeDropzone,
        className: styles.dropzone,
        disabled: !composerActions.attachFiles,
        disableClick: true,
        disablePreview: true,
        onDrop: this.handleFileDrop
      }, /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-widget-message-main-area', styles.mainArea),
        onMouseMove: this.handleMouseMove
      }, /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-activity-list-wrapper', styles.activityListWrapper)
      }, /*#__PURE__*/React.createElement(ScrollingActivity, {
        isLoadingHistoryUp: isLoadingHistoryUp,
        onScroll: this.handleScroll,
        ref: this.getActivityList
      }, currentUser && /*#__PURE__*/React.createElement(ActivityList, {
        newMessagesMessage: formatMessage(messages$1.newMessagesMessage),
        onActivityDelete: this.handleActivityDelete,
        onActivityFlag: this.handleActivityFlag,
        onActivityRetry: this.handleActivityRetry,
        features: features,
        sdkInstance: sparkInstance,
        intl: this.props.intl
      }), /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-indicators', styles.indicators)
      }, /*#__PURE__*/React.createElement(ReadReceipts, null))), widgetMessage.get('showScrollToBottomButton') && /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-scroll-to-bottom', styles.scrollToBottom)
      }, /*#__PURE__*/React.createElement(Button, {
        ariaLabel: formatMessage(messages$1.scrollToBottom),
        circle: true,
        color: widgetMessage.get('hasNewMessage') ? 'blue' : '',
        onClick: this.handleScrollToBottom,
        size: 32
      }, /*#__PURE__*/React.createElement(Icon, {
        color: widgetMessage.get('hasNewMessage') ? 'white' : '',
        name: "icon-arrow-down_16"
      })))), /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-message-composer-wrapper', styles.messageComposerWrapper)
      }, /*#__PURE__*/React.createElement(MessageComposer, {
        composerActions: composerActions,
        conversation: conversation,
        onSubmit: this.handleMessageSubmit,
        placeholder: formatMessage(messages$1.messageComposerPlaceholder, {
          displayName
        }),
        showMentions: true,
        sparkInstance: sparkInstance
      }))), widgetMessage.get('showAlertModal') && /*#__PURE__*/React.createElement(ConfirmationModal, {
        actionButtonLabel: formatMessage(messages$1.deleteButtonLabel),
        body: formatMessage(messages$1.deleteAlertBody),
        cancelButtonLabel: formatMessage(messages$1.cancelButtonLabel),
        onClickActionButton: this.handleConfirmActivityDelete,
        onClickCancelButton: this.handleCancelActivityDelete,
        title: formatMessage(messages$1.deleteAlertTitle)
      }), /*#__PURE__*/React.createElement(Notifications, {
        onEvent: this.handleEvent,
        isMuted: muteNotifications
      }), /*#__PURE__*/React.createElement(Cover, {
        message: formatMessage(messages$1.dropzoneCoverMessage)
      }));
    }

    if (conversation && conversation.getIn(['status', 'error'])) {
      return /*#__PURE__*/React.createElement(ErrorDisplay, {
        secondaryTitle: conversation.getIn(['status', 'error', 'description']),
        title: formatMessage(messages$1.errorConversation)
      });
    }

    return /*#__PURE__*/React.createElement(LoadingScreen, null);
  }

}, (_applyDecoratedDescriptor(_class.prototype, "getActivityList", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "getActivityList"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "listenToBufferState", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "listenToBufferState"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "acknowledgeLastActivity", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "acknowledgeLastActivity"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleScrollToBottom", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleScrollToBottom"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleMessageSubmit", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleMessageSubmit"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleEvent", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleEvent"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleMouseMove", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleMouseMove"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleActivityFlag", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleActivityFlag"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleActivityDelete", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleActivityDelete"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleConfirmActivityDelete", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleConfirmActivityDelete"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleCancelActivityDelete", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleCancelActivityDelete"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleActivityRetry", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleActivityRetry"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleFileDrop", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleFileDrop"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleScroll", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleScroll"), _class.prototype)), _class);
MessageWidget.propTypes = { ...ownPropTypes,
  ...injectedPropTypes
};
const ConnectedMessageWidget = wrapConversationMercury(MessageWidget);
var ConnectedMessage = compose(connect(getMessageWidgetProps, dispatch => bindActionCreators({
  acknowledgeActivityOnServer,
  addFiles,
  confirmDeleteActivity,
  createConversation,
  createNotification,
  deleteActivityAndDismiss,
  fetchAvatarsForUsers,
  fetchFlags,
  flagActivity,
  getConversation: getConversation$1,
  hideDeleteModal,
  loadMissingActivities,
  loadPreviousMessages,
  removeFlagFromServer,
  removeInflightActivity,
  resetConversation,
  resetWidgetState,
  retryFailedActivity,
  setScrollPosition,
  setScrolledUp,
  setTyping,
  showScrollToBottomButton,
  subscribeToPresenceUpdates,
  unsubscribeFromPresenceUpdates,
  updateHasNewMessage,
  updateWidgetState
}, dispatch)), ...enhancers)(ConnectedMessageWidget);

var messages = {
  'ciscospark.container.message.deleteAlert.body': 'Are you sure you want to delete this message?',
  'ciscospark.container.message.deleteAlert.title': 'Delete',
  'ciscospark.container.message.deleteAlert.cancelButton': 'Cancel',
  'ciscospark.container.message.messageComposer.placeholder': 'Send a message to {displayName}',
  'ciscospark.systemMessage.conversation.youCreate': 'You created this conversation.',
  'ciscospark.systemMessage.conversation.someoneCreate': '{name} created this conversation.',
  'ciscospark.systemMessage.message.youDelete': 'You deleted your message.',
  'ciscospark.systemMessage.message.someoneDelete': '{name} deleted their own message.',
  'ciscospark.datetime.today': 'Today',
  'ciscospark.datetime.yesterday': 'Yesterday',
  'ciscospark.container.message.scrollToBottom': 'Click to scroll to latest messages',
  'ciscospark.container.message.newMessages.message': 'NEW MESSAGES',
  'ciscospark.container.message.dropzone.coverMessage': 'Drag and drop your files here',
  'ciscospark.container.message.sharedCards': '{cardsLength, plural, =1 {Responded with a card} other {Responded with # cards}}',
  'ciscospark.container.message.sharedPhotos': '{imagesLength, plural, =1 {Shared a photo} other {Shared # photos}}',
  'ciscospark.container.message.sending': 'Sending...',
  'ciscospark.container.message.sent': 'Sent',
  'ciscospark.container.message.unableToSendYourRequest': 'Unable to send your request'
};

const destinationTypes = {
  EMAIL: 'email',
  USERID: 'userId',
  SPACEID: 'spaceId'
};
var index = compose(constructWebexEnhancer({
  name: 'message',
  reducers
}), withIntl({
  locale: 'en',
  messages
}))(ConnectedMessage);

export default index;
export { destinationTypes, reducers };
//# sourceMappingURL=index.js.map
