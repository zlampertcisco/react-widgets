import { fromJS, Record } from 'immutable';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { wrapDisplayName } from 'recompose';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { addError } from '@webex/redux-module-errors';
import WebexSDKAdapter from '@webex/sdk-component-adapter';
import '@webex/plugin-logger';
import '@webex/plugin-authorization';
import '@webex/internal-plugin-mercury';
import '@webex/plugin-people';
import '@webex/internal-plugin-conversation';
import '@webex/plugin-phone';
import '@webex/plugin-rooms';
import '@webex/plugin-meetings';
import '@webex/internal-plugin-flag';
import '@webex/internal-plugin-feature';
import '@webex/internal-plugin-presence';
import '@webex/internal-plugin-search';
import '@webex/internal-plugin-team';
import Webex from '@webex/webex-core';
import LocalForageStoreAdapter from '@webex/storage-adapter-local-forage';

/* eslint-disable import/prefer-default-export */

/**
 * Gets the status booleans from different parts of the SDK instance
 *
 * @export
 * @param {Object} sdkInstance
 * @returns {Object} status
 * @returns {boolean} status.authenticated
 * @returns {boolean} status.authenticating
 * @returns {boolean} status.registered
 */
function getStatusFromInstance(sdkInstance) {
  return {
    authenticated: sdkInstance.canAuthorize,
    authenticating: sdkInstance.isAuthenticating,
    registered: sdkInstance.internal.device.registered
  };
}

const REGISTER_DEVICE_FAILURE = 'spark/REGISTER_DEVICE_FAILURE';
const UNREGISTER_DEVICE_FAILURE = 'spark/UNREGISTER_DEVICE_FAILURE';
const STORE_SPARK_INSTANCE = 'spark/STORE_SPARK_INSTANCE';
const UPDATE_SPARK_STATUS = 'spark/UPDATE_SPARK_STATUS';
const STORE_SPARK_ADAPTOR = 'spark/STORE_SPARK_ADAPTOR';

function registerDeviceFailure(error) {
  return {
    type: REGISTER_DEVICE_FAILURE,
    payload: {
      error
    }
  };
}

function updateSparkStatus(status) {
  return {
    type: UPDATE_SPARK_STATUS,
    payload: {
      status
    }
  };
}
function storeSparkInstance(spark) {
  return {
    type: STORE_SPARK_INSTANCE,
    payload: {
      status: getStatusFromInstance(spark),
      spark
    }
  };
}
const storeSparkAdaptor = adaptor => ({
  type: STORE_SPARK_ADAPTOR,
  payload: {
    adaptor
  }
});
function registerDevice(spark) {
  return dispatch => {
    dispatch(updateSparkStatus({
      registering: true
    }));
    return spark.internal.device.register().then(() => dispatch(updateSparkStatus({
      registering: false,
      registered: true
    }))).catch(error => dispatch(registerDeviceFailure(error)));
  };
}

const Status = Record({
  authenticated: false,
  authenticating: false,
  registered: false,
  registerError: false,
  registering: false,
  unregisterError: false,
  unregistering: false
});
const initialState = fromJS({
  error: null,
  spark: null,
  status: new Status()
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case UPDATE_SPARK_STATUS:
      return state.mergeDeep({
        status: action.payload.status
      });

    case STORE_SPARK_INSTANCE:
      return state.set('spark', action.payload.spark).mergeDeep({
        status: action.payload.status
      });

    case STORE_SPARK_ADAPTOR:
      return state.set('adaptor', action.payload.adaptor);

    case REGISTER_DEVICE_FAILURE:
      return state.set('error', fromJS(action.payload.error)).setIn(['status', 'registerError'], true).setIn(['status', 'registering'], false);

    case UNREGISTER_DEVICE_FAILURE:
      return state.set('error', fromJS(action.payload.error)).setIn(['status', 'unregisterError'], true).setIn(['status', 'unregistering'], false);

    default:
      return state;
  }
}

/**
 * Evaluates the federation environment variable so that
 * it can be used to configure federation.
 * @returns {boolean} whether to configure federation
 */

function configureFederation() {
  const fed = process.env.FEDERATION;

  if (fed && (fed === '0' || fed.toLowerCase() === 'false')) {
    return false;
  } // Federation is on by default.


  return true;
}
/**
 * Creates the default sdk config for the widgets
 * @param {Object} [options={}]
 * @returns {Object}
 */


function defaultConfig(options = {}) {
  return {
    appName: 'webex-widgets',
    appVersion: process.env.REACT_WEBEX_VERSION,
    device: {
      ephemeral: true
    },
    logger: {
      level: options.logLevel || process.env.NODE_ENV === 'production' ? 'silent' : 'trace'
    },
    conversation: {
      allowedInboundTags: {
        'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
        a: ['href'],
        b: [],
        blockquote: ['class'],
        strong: [],
        i: [],
        em: [],
        pre: [],
        code: [],
        br: [],
        hr: [],
        p: [],
        ul: [],
        ol: [],
        li: [],
        h1: [],
        h2: [],
        h3: []
      },
      allowedOutboundTags: {
        'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
        a: ['href'],
        b: [],
        blockquote: ['class'],
        strong: [],
        i: [],
        em: [],
        pre: [],
        code: [],
        br: [],
        hr: [],
        p: [],
        ul: [],
        ol: [],
        li: [],
        h1: [],
        h2: [],
        h3: []
      }
    },
    credentials: {
      client_id: process.env.WEBEX_CLIENT_ID,
      federation: configureFederation(),
      scope: 'spark:all spark:kms'
    },
    // Added to help load blocking during decryption
    encryption: {
      kmsInitialTimeout: 10000
    },
    meetings: {
      deviceType: 'WEB'
    },
    phone: {
      enableExperimentalGroupCallingSupport: true
    },
    storage: {
      unboundedAdapter: new LocalForageStoreAdapter('webex-react-widgets')
    }
  };
}
/**
 * Creates a sdk instance with the access token
 * @param {string} accessToken
 * @param {object} options
 * @returns {Promise<object>}
 */


function createSDKInstance(accessToken, options = {}) {
  const webexSDKInstance = new Webex({
    credentials: {
      authorization: {
        access_token: accessToken
      }
    },
    config: defaultConfig(options)
  });
  return Promise.resolve(webexSDKInstance);
}
/**
 * Creates a webex instance with the jwt token generated
 * by a guest issuer.
 * https://developer.webex.com/docs/guest-issuer
 *
 * @param {string} jwt
 * @param {object} options
 * @returns {Promise<object>}
 */

function createSDKGuestInstance(jwt, options = {}) {
  const webexSDKInstance = new Webex({
    config: defaultConfig(options)
  });
  return webexSDKInstance.authorization.requestAccessTokenFromJwt({
    jwt
  }).then(() => webexSDKInstance);
}

const injectedPropTypes = {
  spark: PropTypes.object.isRequired,
  storeSparkInstance: PropTypes.func.isRequired,
  storeSparkAdaptor: PropTypes.func.isRequired,
  updateSparkStatus: PropTypes.func.isRequired,
  addError: PropTypes.func.isRequired
};
const propTypes$1 = {
  accessToken: PropTypes.string,
  guestToken: PropTypes.string,
  sdkInstance: PropTypes.object,
  dangerouslyIgnoredRequiredPlugins: PropTypes.array,
  ...injectedPropTypes
};
const defaultProps$1 = {
  accessToken: '',
  guestToken: '',
  sdkInstance: undefined,
  dangerouslyIgnoredRequiredPlugins: []
};
const PLUGINS = ['authorization', 'logger', 'meetings', 'people', 'phone', 'rooms'];
const INTERNAL_PLUGINS = ['conversation', 'feature', 'flag', 'mercury', 'presence', 'search', 'team'];

const storeSDKAdaptor = async (sdk, props) => {
  const a = new WebexSDKAdapter(sdk);
  await a.meetingsAdapter.connect();
  props.storeSparkAdaptor(a);
};

class SparkComponent extends Component {
  constructor(props) {
    super(props);
    this.storeSDKInstance = this.storeSDKInstance.bind(this);
  }

  componentDidMount() {
    const {
      accessToken,
      guestToken,
      spark,
      sdkInstance
    } = this.props; // Get the sdk instance from redux state

    const sparkInstance = spark.get('spark'); // No instance stored, let's get one

    if (!sparkInstance) {
      // SDK Instance passed via props
      if (sdkInstance) {
        this.storeSDKInstance(sdkInstance);
      } // Guest token passed via props
      else if (guestToken) {
          createSDKGuestInstance(guestToken, this.props).then(this.storeSDKInstance);
        } // Access token passed via props
        else if (accessToken) {
            createSDKInstance(accessToken, this.props).then(this.storeSDKInstance);
          } else {
            // No valid options to create an sdk instance, throw an error
            this.props.addError({
              id: 'webex-sdk-config-props',
              displayTitle: 'Something\'s not right. Please try again',
              displaySubtitle: 'Missing initial configuration, please pass \'sdkInstance\', \'accessToken\', or \'guestToken\'',
              temporary: false
            });
          }
    } else {
      this.listenToSparkEvents(sparkInstance);
    }
  }
  /**
   * Register the device if the user has been authenticated
   * and the device is not registered yet.
   * @param {Object} sparkInstance
   */


  setupDevice(sparkInstance) {
    const {
      registering,
      registerError
    } = this.props.spark.get('status');
    const {
      authenticated,
      registered
    } = getStatusFromInstance(sparkInstance);

    if (authenticated && !registered && !registering && !registerError) {
      this.props.registerDevice(sparkInstance);
    }
  }
  /**
   * Listen to any new events and update the sprak instance
   * status accordingly
   * @param {Object} sparkInstance
   */


  listenToSparkEvents(sparkInstance) {
    sparkInstance.listenToAndRun(sparkInstance, 'change:canAuthorize', () => {
      this.props.updateSparkStatus({
        authenticated: sparkInstance.canAuthorize
      });
    });
    sparkInstance.listenToAndRun(sparkInstance, 'change:isAuthenticating', () => {
      this.props.updateSparkStatus({
        authenticating: sparkInstance.isAuthenticating
      });
    });
    sparkInstance.listenToAndRun(sparkInstance.internal.device, 'change:registered', () => {
      this.props.updateSparkStatus({
        registered: sparkInstance.internal.device.registered
      });
    });
    this.setupDevice(sparkInstance);
  }
  /**
   * Verify for the plugins, store the spark instance
   * and listen to any events
   * @param {Object} sdkInstance
   */


  storeSDKInstance(sdkInstance) {
    if (this.validateSDKInstance(sdkInstance)) {
      this.props.storeSparkInstance(sdkInstance);
      this.listenToSparkEvents(sdkInstance);
      storeSDKAdaptor(sdkInstance, this.props);
    }
  }
  /**
   * Validates the sdk instance object and plugins
   *
   * @param {Object} sdkInstance
   * @returns {boolean}
   * @memberof SparkComponent
   */


  validateSDKInstance(sdkInstance) {
    if (typeof sdkInstance !== 'object') {
      this.props.addError({
        id: 'webex-sdk-instance-prop',
        displayTitle: 'Something\'s not right. Please try again',
        displaySubtitle: 'The \'sdkInstance\' passed was invalid. Please pass a proper SDK Instance.',
        temporary: false
      });
      return false;
    }

    return this.verifyPlugins(sdkInstance);
  }
  /**
   * Verify if all the plugins have been injected
   * properly to the webex SDK instance
   * @param {Object} sdkInstance
   * @returns {boolean}
   */


  verifyPlugins(sdkInstance) {
    let contains = false;
    let verified = true;

    for (const plugin of PLUGINS) {
      if (!this.props.dangerouslyIgnoredRequiredPlugins.includes(plugin)) {
        contains = Object.prototype.hasOwnProperty.call(sdkInstance, plugin);

        if (!contains) {
          this.props.addError({
            id: 'webex-plugins-missing',
            displayTitle: 'Something\'s not right. Please try again',
            displaySubtitle: `Webex SDK instance plugin ${plugin} is not injected to the widget properly`,
            temporary: false
          });
          verified = false;
        }
      }
    }

    for (const internalPlugin of INTERNAL_PLUGINS) {
      if (!this.props.dangerouslyIgnoredRequiredPlugins.includes(internalPlugin)) {
        contains = Object.prototype.hasOwnProperty.call(sdkInstance.internal, internalPlugin);

        if (!contains) {
          this.props.addError({
            id: 'webex-internal-plugins-missing',
            displayTitle: 'Something\'s not right. Please try again',
            displaySubtitle: `Webex SDK instance internal plugin ${internalPlugin} is not injected to the widget properly`,
            temporary: false
          });
          verified = false;
        }
      }
    }

    return verified;
  }

  render() {
    return null;
  }

}
SparkComponent.propTypes = propTypes$1;
SparkComponent.defaultProps = defaultProps$1;
var SparkComponent$1 = connect(state => ({
  spark: state.spark
}), dispatch => bindActionCreators({
  updateSparkStatus,
  registerDevice,
  storeSparkInstance,
  storeSparkAdaptor,
  addError
}, dispatch))(SparkComponent);

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".react-redux-spark__wrapper__LndyYXBw {\n  position: relative;\n  display: flex;\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n}\n";
var styles = {"wrapper":"react-redux-spark__wrapper__LndyYXBw"};
styleInject(css_248z);

const propTypes = {
  accessToken: PropTypes.string,
  guestToken: PropTypes.string
};
const defaultProps = {
  accessToken: '',
  guestToken: ''
};
function injectSpark(BaseComponent) {
  function WithSpark(props) {
    return /*#__PURE__*/React.createElement("div", {
      className: styles.wrapper
    }, /*#__PURE__*/React.createElement(SparkComponent$1, props), /*#__PURE__*/React.createElement(BaseComponent, props));
  }

  WithSpark.propTypes = propTypes;
  WithSpark.defaultProps = defaultProps;
  WithSpark.displayName = wrapDisplayName(BaseComponent, 'WithSpark');
  return WithSpark;
}
const withSpark = injectSpark;

export default reducer;
export { initialState, injectSpark, withSpark };
//# sourceMappingURL=index.js.map
