import { compose, lifecycle, setDisplayName, setStatic } from 'recompose';
import sparkReducer, { withSpark } from '@webex/react-redux-spark';
import '@webex/react-component-spark-fonts';
import React, { Component } from 'react';
import { bindActionCreators, createStore, compose as compose$1, applyMiddleware, combineReducers } from 'redux';
import { connect, Provider } from 'react-redux';
import { createLogger } from 'redux-logger';
import thunk from 'redux-thunk';
import PropTypes, { shape, func } from 'prop-types';
import usersReducer, { fetchCurrentUser } from '@webex/redux-module-users';
import { setWrappedDisplayName } from '@webex/react-component-utils';
import ReactDOM from 'react-dom';
import uuid from 'uuid';
import Events from 'ampersand-events';
import { kebabCase, camelCase } from 'lodash';
import { injectIntl, IntlProvider } from 'react-intl';
import { createSelector } from 'reselect';

const REMOVE_WIDGET = 'widget-base/REMOVE_WIDGET';
function removeWidget() {
  return {
    type: REMOVE_WIDGET
  };
}
var withRemoveWidget = compose(setWrappedDisplayName('WithRemoveWidget'), connect(state => state, dispatch => bindActionCreators({
  removeWidget
}, dispatch)));

function constructReducers(reducers) {
  const rootReducers = reducers;
  rootReducers.spark = sparkReducer;
  rootReducers.users = usersReducer;
  const widgetReducer = combineReducers(rootReducers);
  return (state, action) => {
    if (action.type === REMOVE_WIDGET) {
      return undefined;
    }

    if (widgetReducer) {
      return widgetReducer(state, action);
    }

    return state;
  };
}
/**
 * HOC for injecting an initial Redux state from reducers and enhancers
 * @param {Object} options
 * @param {Object} options.reducers object of reducers
 * @returns {Function} creates a wrapped React component
 */


function withInitialState({
  reducers = {}
}) {
  // eslint-disable-reason redux devtools extension is required name (https://github.com/zalmoxisus/redux-devtools-extension#usage)
  // eslint-disable-next-line no-underscore-dangle
  const devtools = window.__REDUX_DEVTOOLS_EXTENSION__ || (() => noop => noop);

  const middlewares = [thunk];

  if (process.env.NODE_ENV !== 'production') {
    const logger = createLogger({
      level: 'info',
      duration: true,
      collapsed: false,
      logErrors: true
    });
    middlewares.push(logger);
  }

  return BaseComponent => {
    class WithInitialState extends Component {
      constructor(props) {
        super(props);
        this.widgetReducer = constructReducers(reducers);
        this.store = createStore(this.widgetReducer, compose$1(applyMiddleware(...middlewares), devtools()));
      }

      render() {
        const {
          props
        } = this; // Do not inject provider if spark object already exists in props

        if (props.spark) {
          return /*#__PURE__*/React.createElement(BaseComponent, props);
        }

        return /*#__PURE__*/React.createElement(Provider, {
          store: this.store
        }, /*#__PURE__*/React.createElement(BaseComponent, props));
      }

    }

    WithInitialState.propTypes = {
      spark: PropTypes.object
    };
    WithInitialState.defaultProps = {
      spark: undefined
    };
    return WithInitialState;
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function formatEventDetails({
  name,
  data
}) {
  const [resource, eventName] = name.split(':');
  const details = {
    resource,
    event: eventName,
    data
  };

  if (data.actorId) {
    details.actorId = data.actorId;
  }

  if (data.action) {
    details.action = data.action;
  }

  return details;
}

function BrowserWidget(el) {
  this.el = el;

  this.remove = callback => new Promise(resolve => {
    const id = this.el.getAttribute('data-uuid'); // Unmount React Component

    const removed = ReactDOM.unmountComponentAtNode(el); // Remove from widgetStore

    Reflect.deleteProperty(window.webex.widgetStore, id); // Fire callback

    if (typeof callback === 'function') {
      return callback(removed);
    }

    return resolve(removed);
  });

  function handleEvent(name, data) {
    if (this.el) {
      // Don't nest data if the event data object is already constructed
      const detail = data.data ? data : formatEventDetails({
        name,
        data
      }); // Dispatch DOM event

      const event = new CustomEvent(name, {
        detail
      });
      this.el.dispatchEvent(event); // Trigger ampersand events

      this.trigger(name, detail);
    }

    return this;
  }

  this.handleEvent = handleEvent;
  this.version = process.env.REACT_WEBEX_VERSION; // Attach event handlers to each widget

  const widgetFn = {};
  Object.keys(window.webex.widgetFn).forEach(fn => {
    const func = window.webex.widgetFn[fn];

    widgetFn[fn] = options => {
      const onEvent = (name, data) => {
        this.handleEvent(name, data);

        if (typeof options.onEvent === 'function') {
          options.onEvent(name, formatEventDetails({
            name,
            data
          }));
        }
      };

      return func.call(this, { ...options,
        onEvent: onEvent.bind(this)
      });
    };
  });
  Object.assign(this, widgetFn);
  return this;
}
/**
 * Takes a DOM element and returns a widget or initializes it as a widget element
 * @param {Element} el
 * @returns {Object}
 */


function getWidget(el) {
  /**
   * Creates a new widget object and stores it
   * @param  {object} widgetEl HTML element where a widget is mounted
   * @returns {object} widgetObject
   */
  function createNewWidget(widgetEl) {
    Object.assign(BrowserWidget.prototype, Events);
    const widgetObj = new BrowserWidget(widgetEl);
    const id = uuid.v4(); // Store ID as attribute on dom element

    widgetEl.setAttribute('data-uuid', id);
    window.webex.widgetStore[id] = widgetObj;
    return widgetObj;
  }
  /**
   * Retrieves a Widget from global widget store
   * @param  {object} widgetEl HTML element where a widget is mounted
   * @returns {object} widgetObject
   */


  function selectWidget(widgetEl) {
    // Check if element exists and is HTML Element
    if (widgetEl && widgetEl.nodeType === 1) {
      // Get ID as attribute on dom element
      const id = widgetEl.getAttribute('data-uuid'); // Add class

      widgetEl.classList.add('webex-widget'); // Get widget from store if it exists

      const widgetObj = window.webex.widgetStore[id];

      if (widgetObj) {
        return widgetObj;
      } // Otherwise create new widget store


      return createNewWidget(widgetEl);
    }

    console.warn('WARNING: webex.widget: No HTML element provided.'); // eslint-disable-line no-console

    return false;
  }

  return selectWidget(el);
}

function setupWidgetNamespace() {
  if (!window.webex) {
    window.webex = {};
  }

  if (!window.webex.widgetStore) {
    window.webex.widgetStore = {};
  }

  if (!window.webex.widgetFn) {
    window.webex.widgetFn = {};
  }

  if (!window.webex.widget || typeof window.webex.widget !== 'function') {
    window.webex.widget = getWidget;
  } // Legacy Support


  if (!window.ciscospark) {
    window.ciscospark = window.webex;
  }
}
/**
 * HOC that registers widget to browser globals
 * @param {String} name of widget to use
 * @returns {Function}
 */


function withBrowserGlobals({
  name
}) {
  // Inject widget into browser globals
  setupWidgetNamespace();
  const fnName = `${name}Widget`;
  return BaseComponent => {
    function renderWidget(options) {
      const {
        el
      } = this;
      const {
        onEvent,
        ...otherOptions
      } = options; // Instantiate Component into DOM

      ReactDOM.render( /*#__PURE__*/React.createElement(BaseComponent, _extends({
        onEvent: onEvent
      }, otherOptions)), el);
      return this;
    } // Set up this widget's init process
    // Allow dev to call window.webex.widget(EL).WIDGETNAME({options});


    if (typeof window.webex.widgetFn[fnName] === 'function') {
      // eslint-disable-reason Need to log console warning when widget already registered
      // eslint-disable-next-line no-console
      console.warn(`${name} Widget is already registered.`);
    } else {
      window.webex.widgetFn[fnName] = renderWidget; // Attach version number statically. This will need to change when we publish widgets independently

      window.webex.widgetFn[fnName].version = process.env.REACT_WEBEX_VERSION;
    }

    return BaseComponent;
  };
}

function getDataAttributes(el) {
  const data = {};

  if (el) {
    const attribs = el.attributes;

    for (let i = 0; i < attribs.length; i += 1) {
      const {
        name
      } = attribs[i];
      const {
        value
      } = attribs[i];

      if (name.startsWith('data-') && name !== 'data-toggle') {
        data[camelCase(name.replace('data-', ''))] = value;
      }
    }
  }

  return data;
}

function loadWidgets({
  name
}) {
  const widgets = document.querySelectorAll(`[data-toggle^="webex-${kebabCase(name)}"]`);

  for (const widget of widgets) {
    // grab all data attributes that are not data-toggle
    const props = getDataAttributes(widget); // Use browser globals to init widget if available

    if (window.webex.widget) {
      const widgetObj = window.webex.widget(widget);
      const widgetName = `${name}Widget`;

      if (typeof widgetObj[widgetName] === 'function') {
        widgetObj[widgetName](props);
      }
    }
  }
}

function withDataAPI({
  name
}) {
  const onDOMReady = () => {
    loadWidgets({
      name
    });
    document.removeEventListener('DOMContentLoaded', onDOMReady);
  };

  return BaseComponent => {
    // Only look for Widgets after the rest of the Widget constructor has initialized
    document.addEventListener('DOMContentLoaded', onDOMReady, false);
    return BaseComponent;
  };
}

function withIntl({
  messages,
  locale
}) {
  // eslint-disable-reason Dynamically loading locale data to lower overhead

  /* eslint-disable import/no-dynamic-require, global-require */
  if (!Intl.PluralRules) {
    require('@formatjs/intl-pluralrules/polyfill');

    require(`@formatjs/intl-pluralrules/dist/locale-data/${locale}`);
  }

  if (!Intl.RelativeTimeFormat) {
    require('@formatjs/intl-relativetimeformat/polyfill');

    require(`@formatjs/intl-relativetimeformat/dist/locale-data/${locale}`);
  }
  /* eslint-enable import/no-dynamic-require, global-require */


  return BaseComponent => {
    const WrappedComponent = injectIntl(BaseComponent);

    function WithIntl(props) {
      return /*#__PURE__*/React.createElement(IntlProvider, {
        locale: locale,
        messages: messages
      }, /*#__PURE__*/React.createElement(WrappedComponent, props));
    }

    WrappedComponent.propTypes = {
      // Grabbed from https://github.com/sharetribe/ftw-daily/blob/master/src/util/reactIntl.js#L10
      intl: shape({
        formatDate: func.isRequired,
        formatHTMLMessage: func.isRequired,
        formatMessage: func.isRequired,
        formatNumber: func.isRequired,
        formatPlural: func.isRequired,
        formatRelativeTime: func.isRequired,
        formatTime: func.isRequired
      })
    };
    return setWrappedDisplayName('WithIntl')(WithIntl);
  };
}

const getUsers = state => state.users;

const getCurrentUser = createSelector([getUsers], users => {
  const currentUserId = users.get('currentUserId');
  return {
    currentUser: users.getIn(['byId', currentUserId])
  };
});

function fetchUser(props) {
  const {
    spark,
    users
  } = props;

  if (spark && spark.getIn(['status', 'registered']) && !users.get('currentUserId')) {
    /* eslint-disable no-warning-comments */
    // TODO rename sparkInstance to sdkInstance

    /* eslint-enable no-warning-comments */
    const sparkInstance = spark.get('spark');
    props.fetchCurrentUser(sparkInstance);
  }
}

var withCurrentUser = compose(setWrappedDisplayName('WithCurrentUser'), connect(getCurrentUser, dispatch => bindActionCreators({
  fetchCurrentUser
}, dispatch)), lifecycle({
  componentDidMount() {
    fetchUser(this.props);
  },

  componentWillReceiveProps(nextProps) {
    fetchUser(nextProps);
  }

}));

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "/* stylelint-disable selector-max-attribute,selector-max-universal */\n.webex-widget,\n.webex-widget > div,\n[data-toggle^='webex-'],\n[data-toggle^='webex-'] > div {\n  position: relative;\n  display: flex;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  flex-direction: column;\n}\n\n.webex-widget-base__wrapper__Lyogc3R5 {\n  position: relative;\n  display: flex;\n  width: 100%;\n  height: inherit;\n  flex-direction: column;\n}\n\n.webex-widget *,\n.webex-widget *::after,\n.webex-widget *::before {\n  box-sizing: border-box;\n}\n\n/* stylelint enable */\n/* only change the width of the scrollbars of the widgets and their div children */\n.webex-widget > div::-webkit-scrollbar {\n  width: 4px;\n}\n\n.webex-widget > ::-webkit-scrollbar-thumb {\n  height: 50px;\n  background-color: transparent;\n  border-radius: 15px;\n  box-shadow: none;\n  background-clip: padding-box;\n  border-image-source: initial initial initial;\n  border-image-slice: initial;\n  border-image-outset: initial;\n}\n\n.webex-widget > ::-webkit-scrollbar-thumb {\n  background-color: #8a8a8a;\n}\n\n.webex-widget > ::-webkit-scrollbar-track {\n  background-color: transparent;\n}\n";
styleInject(css_248z);

/**
 * Creates an enhancer HOC that provides a store and connection to Spark
 * @param {Object} options
 * @param {Object} options.reducers Map of reducers that should be used to init a Store
 * @param {Object} options.enhancers Map of enhancers that should be used to init a Store
 * @returns {Object} React Component
 */

function constructWebexEnhancer({
  name,
  reducers,
  enhancers
}) {
  // Executes bottom to top. Bottom most HOC Will be the inner most Component
  return compose( // Instantiates Widgets into DOM with Data API (Must be at the top of compose)
  withDataAPI({
    name
  }), // Try to inject browser globals into global namespace
  withBrowserGlobals({
    name
  }), // Initialize state with react-redux Provider
  withInitialState({
    reducers,
    enhancers
  }), // Clears store on Remove
  withRemoveWidget, // Connects and Auths with Webex API
  withSpark, // Retrieves and stores current user
  withCurrentUser, // Set distinct display name
  setDisplayName(`WebexWidgetBase(${name})`), // Inject version number into component as static prop
  setStatic('version', process.env.REACT_WEBEX_VERSION));
}
/**
 * Builds a Webex widget out of a React component
 * @param {String} name unique component name to inject into the global namespace
 * @param {Object} BaseComponent React Component
 * @returns {Object} React Component
 */

function WebexWidgetBase(name, BaseComponent) {
  return constructWebexEnhancer(name)(BaseComponent);
}

export default WebexWidgetBase;
export { constructWebexEnhancer, withBrowserGlobals, withInitialState, withIntl };
//# sourceMappingURL=index.js.map
