import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { autobind } from 'core-decorators';
import { wrapDisplayName } from 'recompose';
import { fromJS } from 'immutable';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

const STORE_METRIC = 'metrics/STORE_METRIC';
const DELETE_METRIC = 'metrics/DELETE_METRIC';
const ADD_TO_QUEUE = 'metrics/ADD_TO_QUEUE';
const CLEAR_QUEUE = 'metrics/CLEAR_QUEUE';
const UPDATE_METRICS_STATUS = 'metrics/UPDATE_METRICS_STATUS';
function storeMetric(name, data) {
  return {
    type: STORE_METRIC,
    payload: {
      name,
      data
    }
  };
}
function deleteMetric(name) {
  return {
    type: DELETE_METRIC,
    payload: {
      name
    }
  };
}
function addToQueue(data) {
  return {
    type: ADD_TO_QUEUE,
    payload: {
      data
    }
  };
}
function clearQueue() {
  return {
    type: CLEAR_QUEUE
  };
}
function updateMetricsStatus(status) {
  return {
    type: UPDATE_METRICS_STATUS,
    payload: {
      status
    }
  };
}

const events = {
  WIDGET_LOAD: {
    resource: 'widget',
    event: 'load'
  },
  WIDGET_UNMOUNT: {
    resource: 'widget',
    event: 'unmount'
  }
};

const NS = 'webex-widget-';
function withSparkMetrics(widgetName) {
  const defaultFields = {
    protocol: window.location.protocol,
    hostname: window.location.hostname,
    pathname: window.location.pathname,
    widgetVersion: process.env.REACT_WEBEX_VERSION,
    iteration: 0
  };
  const defaultTags = {
    widgetName
  };
  return BaseComponent => {
    var _class;

    /* eslint-disable-reason need to refactor before adding default props */

    /* eslint-disable react/require-default-props */
    const injectedProps = {
      sparkInstance: PropTypes.object,
      sparkState: PropTypes.object,
      metricsStore: PropTypes.object,
      updateMetricsStatus: PropTypes.func,
      deleteMetric: PropTypes.func,
      storeMetric: PropTypes.func,
      addToQueue: PropTypes.func,
      clearQueue: PropTypes.func
    };
    let InjectSparkMetrics = (_class = class InjectSparkMetrics extends Component {
      static formatMetricData({
        data,
        action,
        event,
        fields,
        tags
      }) {
        return {
          type: ['operational'],
          tags: Object.assign({}, defaultTags, {
            action,
            event
          }, tags),
          fields: Object.assign({}, defaultFields, {
            data
          }, fields)
        };
      }

      constructor(props) {
        super(props);
        this.startTime = window.performance.now();
      }

      componentWillMount() {
        this.sendStartMetric({ ...events.WIDGET_LOAD,
          data: this.startTime
        });
      }

      componentWillReceiveProps(nextProps) {
        // Try to send queue on every load if there is something to send
        this.sendQueue(nextProps);
      }

      shouldComponentUpdate() {
        return true;
      }

      componentWillUnmount() {
        this.sendElapsedTime(events.WIDGET_UNMOUNT);
      }

      canSendMetric() {
        const {
          sparkInstance,
          sparkState
        } = this.props;
        return sparkInstance && sparkState.get('authenticated') && sparkState.get('registered');
      }

      hasQueuedMetrics() {
        const {
          metricsStore
        } = this.props;
        return metricsStore && metricsStore.get('queue').count();
      }

      sendMetric(metric) {
        const {
          props
        } = this;
        const {
          sparkInstance
        } = props;
        const {
          resource
        } = metric;
        const formattedData = InjectSparkMetrics.formatMetricData(metric);

        if (this.canSendMetric()) {
          try {
            return sparkInstance.internal.metrics.submitClientMetrics(`${NS}${resource}`, formattedData);
          } catch (e) {// Don't do anything
          }
        }

        return props.addToQueue(metric);
      }

      sendElapsedTime(metric) {
        if (metric) {
          const updatedMetric = Object.assign({}, metric);
          updatedMetric.data = window.performance.now() - this.startTime;
          return this.sendMetric(updatedMetric);
        }

        return Promise.resolve();
      }

      sendSavedMetric(metricName) {
        const {
          props
        } = this;
        const {
          metricsStore
        } = props;
        const metric = metricsStore.getIn(['items', metricName]);

        if (metric) {
          return this.sendMetric(metric.toJS()).then(() => props.deleteMetric(metricName));
        }

        return false;
      }

      sendQueue(props) {
        const {
          canSendMetric,
          hasQueuedMetrics,
          sendMetric
        } = this;
        const {
          metricsStore
        } = props;

        if (canSendMetric() && hasQueuedMetrics() && !metricsStore.getIn(['status', 'isSendingQueue'])) {
          props.updateMetricsStatus({
            isSendingQueue: true
          });
          return Promise.all(metricsStore.get('queue').map(metric => sendMetric(metric.toJS()))).then(() => {
            props.clearQueue();
            return props.updateMetricsStatus({
              isSendingQueue: false
            });
          });
        }

        return Promise.resolve();
      }

      sendStartMetric(metric) {
        const computedMetric = Object.assign({}, {
          action: 'start',
          data: window.performance.now()
        }, metric);
        const metricName = [metric.resource, metric.event, 'start'].join(':');
        this.props.storeMetric(metricName, computedMetric);
        return this.sendMetric(computedMetric);
      }

      sendEndMetric(metric) {
        // Grab end timestamp
        const end = window.performance.now(); // Check for starting time

        const startName = [metric.resource, metric.event, 'start'].join(':');
        const start = this.props.metricsStore.getIn(['items', startName, 'data']);

        if (start) {
          // construct and send end metric
          const endMetric = Object.assign({}, {
            action: 'end',
            data: end
          }, metric);
          const sendEnd = this.sendMetric(endMetric); // construct and send duration metric

          const durationMetric = Object.assign({}, {
            action: 'duration',
            data: end - start
          }, metric);
          const sendDuration = this.sendMetric(durationMetric);
          this.props.deleteMetric(startName);
          return Promise.all([sendEnd, sendDuration]);
        }

        return Promise.resolve();
      }

      render() {
        const {
          sendQueue,
          sendMetric,
          sendElapsedTime,
          sendStartMetric,
          sendEndMetric
        } = this;
        const metrics = {
          sendQueue,
          sendMetric,
          sendElapsedTime,
          sendStartMetric,
          sendEndMetric
        };
        return /*#__PURE__*/React.createElement(BaseComponent, _extends({}, this.props, {
          metrics: metrics
        }));
      }

    }, (_applyDecoratedDescriptor(_class.prototype, "canSendMetric", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "canSendMetric"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "hasQueuedMetrics", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "hasQueuedMetrics"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "sendMetric", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "sendMetric"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "sendElapsedTime", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "sendElapsedTime"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "sendSavedMetric", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "sendSavedMetric"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "sendQueue", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "sendQueue"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "sendStartMetric", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "sendStartMetric"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "sendEndMetric", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "sendEndMetric"), _class.prototype)), _class);
    InjectSparkMetrics.propTypes = injectedProps;
    InjectSparkMetrics.displayName = wrapDisplayName(BaseComponent, 'withSparkMetrics');
    return connect(state => ({
      metricsStore: state.metricsStore,
      sparkInstance: state.spark.get('spark'),
      sparkState: state.spark.get('status')
    }), dispatch => bindActionCreators({
      deleteMetric,
      storeMetric,
      addToQueue,
      clearQueue,
      updateMetricsStatus
    }, dispatch))(InjectSparkMetrics);
  };
}

const initialState = fromJS({
  items: {},
  queue: [],
  status: {
    isSendingQueue: false
  }
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case STORE_METRIC:
      return state.setIn(['items', action.payload.name], fromJS(action.payload.data));

    case DELETE_METRIC:
      return state.deleteIn(['items', action.payload.name]);

    case ADD_TO_QUEUE:
      {
        const newQueue = state.get('queue').push(fromJS(action.payload.data));
        return state.set('queue', newQueue);
      }

    case CLEAR_QUEUE:
      return state.set('queue', fromJS([]));

    case UPDATE_METRICS_STATUS:
      return state.mergeDeepIn(['status'], action.payload.status);

    default:
      return state;
  }
}

function injectSparkMetrics(WrappedComponent, widgetName) {
  return withSparkMetrics(widgetName)(WrappedComponent);
}

export default reducer;
export { events, injectSparkMetrics, withSparkMetrics };
//# sourceMappingURL=index.js.map
