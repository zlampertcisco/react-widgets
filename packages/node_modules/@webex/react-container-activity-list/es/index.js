import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import ActivityListComponent, { ITEM_TYPE_DAY_SEPARATOR, ITEM_TYPE_ACTIVITY, ITEM_TYPE_NEW_MESSAGE_SEPARATOR } from '@webex/react-component-activity-list';
import { createSelector } from 'reselect';
import moment from 'moment';
import { filterSync } from '@webex/helper-html';
import { getActivitiesFromThreadAndNonThreadCollections } from '@webex/redux-module-conversation';
import linkifyHtml from 'linkifyjs/html';
import linkifyStr from 'linkifyjs/string';
import React from 'react';
import classNames from 'classnames';
import { constructHydraId } from '@webex/react-component-utils';

var linkify = (activity => {
  const linkifyOptions = {
    ignoreTags: ['code', 'pre'],
    className: 'webex-activity-link'
  };

  if (activity.content) {
    return Object.assign({}, activity, {
      content: linkifyHtml(activity.content, linkifyOptions)
    });
  }

  return Object.assign({}, activity, {
    content: linkifyStr(activity.displayName, linkifyOptions)
  });
});

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "/* stylelint-disable selector-type-no-unknown  */\n.react-container-activity-list__atMention__Lyogc3R5 spark-mention {\n  color: #999;\n}\n";
var styles = {"atMention":"react-container-activity-list__atMention__Lyogc3R5"};
styleInject(css_248z);

const EVENT_NAME_MENTION_CLICKED = 'mention:clicked';
const propTypes = {
  content: PropTypes.string,
  onEvent: PropTypes.func
};
const defaultProps = {
  content: '',
  onEvent: () => {}
};

function AtMentionComponent({
  content,
  onEvent
}) {
  function isMention(target) {
    return target.tagName === 'SPARK-MENTION' && target.dataset;
  }

  function triggerEvent(e) {
    const {
      target
    } = e;

    if (isMention(target)) {
      onEvent(EVENT_NAME_MENTION_CLICKED, {
        type: target.dataset.objectType,
        id: constructHydraId(target.dataset.objectType, target.dataset.objectId)
      });
    }
  }

  function handleClick(e) {
    triggerEvent(e);
  }

  function handleKeyUp(e) {
    if (e.keyCode && e.keyCode === 13) {
      return triggerEvent(e);
    }

    return false;
  }

  return /*#__PURE__*/React.createElement("div", {
    className: classNames(styles.atMention) // eslint-disable-reason content is generated from elsewhere in the app
    // eslint-disable-next-line react/no-danger
    ,
    dangerouslySetInnerHTML: {
      __html: content
    },
    onClick: handleClick,
    onKeyUp: handleKeyUp,
    role: "presentation"
  });
}

AtMentionComponent.propTypes = propTypes;
AtMentionComponent.defaultProps = defaultProps;
var atMention = ((activity, onEvent) => {
  if (activity.mentions) {
    const component = /*#__PURE__*/React.createElement(AtMentionComponent, {
      content: activity.content,
      mentions: activity.mentions.items,
      onEvent: onEvent
    });
    return Object.assign({}, activity, {
      component
    });
  }

  return activity;
});

var defaultFormatters = ((activity, onEvent) => {
  const formatters = [linkify, atMention];
  let result = activity;
  formatters.forEach(formatter => {
    result = formatter(result, onEvent);
  });
  return result;
});

const REPLY_TYPE = 'reply';
const isReplyActivity = activity => {
  var _activity$parent;

  return ((_activity$parent = activity.parent) === null || _activity$parent === void 0 ? void 0 : _activity$parent.type) === REPLY_TYPE;
};
const VISIBLE_ACTIVITY_VERBS = {
  tombstone: {},
  share: {
    objectTypes: ['content']
  },
  post: {
    objectTypes: ['comment']
  },
  create: {
    objectTypes: ['conversation']
  },
  update: {
    objectTypes: ['locusSessionSummaryParticipant', 'locusSessionSummary']
  },
  add: {
    objectTypes: ['person']
  },
  leave: {
    objectTypes: ['person']
  }
};
const LYRA_SPACE_TYPE = 'LYRA_SPACE';
/**
 * Determines if an activity object is a visible activity
 * @param {object} activity
 * @returns {bool}
 */

function isActivityVisible(activity) {
  if (activity.object) {
    const {
      type
    } = activity.object; // Do not show activity if its object type is 'LYRA_SPACE'

    if (type === LYRA_SPACE_TYPE) {
      return false;
    }
  }

  if (!Object.prototype.hasOwnProperty.call(VISIBLE_ACTIVITY_VERBS, activity.verb)) {
    return false;
  }

  const verb = VISIBLE_ACTIVITY_VERBS[activity.verb];

  if (verb.objectTypes) {
    if (verb.objectTypes.indexOf(activity.object.objectType) === -1) {
      return false;
    }
  }

  return true;
}

const getConversationThreadActivities = state => state.conversation.get('threadActivities');

const getConversationNonThreadActivities = state => state.conversation.get('sortNonThreadActivities');

const getConversationActivities = createSelector([getConversationThreadActivities, getConversationNonThreadActivities], getActivitiesFromThreadAndNonThreadCollections);

const getAvatar = state => state.avatar;

const getUsers = state => state.users;

const getFlags = state => state.flags.get('flags');

const getSendingActivities = state => state.activity;

const getActivityFormatter = (state, props) => props.activityFormatter;

const getLastAcknowledgedActivityId = state => state.conversation.get('lastAcknowledgedActivityId');

const getOnEvent = (state, props) => props.onEvent;
/**
 * Applies safe filters activity content
 *
 * @param {Object} activityObject raw activity.object
 * @returns {Object}
 */


function filterActivity(activityObject) {
  const outputActivity = Object.assign({}, activityObject);

  if (outputActivity.content) {
    outputActivity.content = filterSync(() => {}, {
      'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
      a: ['href'],
      b: [],
      blockquote: ['class'],
      strong: [],
      i: [],
      em: [],
      pre: [],
      code: ['class'],
      br: [],
      hr: [],
      p: [],
      ul: [],
      ol: [],
      li: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: []
    }, [], outputActivity.content);
  }

  return outputActivity;
}
/**
 * Applies additional formatting to activity
 *
 * @export
 * @param {Object} activityObject
 * @returns {Object}
 */

function formatActivity(activity, activityFormatter, onEvent) {
  const activityObject = filterActivity(activity);

  if (typeof activityFormatter === 'function') {
    return activityFormatter(activityObject, defaultFormatters, onEvent);
  }

  return defaultFormatters(activityObject, onEvent);
}
/**
 * This loops through our conversation activities and computes an array
 * of 'visible activities' to be used with the ActivityList component
 */

const getActivityList = createSelector([getConversationActivities, getAvatar, getUsers, getSendingActivities, getFlags, getLastAcknowledgedActivityId, getActivityFormatter, getOnEvent], (conversationActivities, avatar, users, sendingActivities, flags, lastAcknowledgedActivityId, activityFormatter, onEvent) => {
  const avatars = avatar.get('items');
  const currentUser = users.getIn(['byId', users.get('currentUserId')]);
  const inFlightActivities = sendingActivities.get('inFlightActivities');
  const activityFailures = sendingActivities.get('activityFailures');
  const visibleActivityList = [];
  const now = moment();
  let lastActorId, lastVerb;
  const lastActivity = {};
  let shouldDisplayNewMessageMarker = false;
  conversationActivities.forEach(activity => {
    if (isActivityVisible(activity)) {
      // Insert day separator if this activity and last one happen on a different day
      const activityDay = moment(activity.published, moment.ISO_8601).endOf('day');
      const activityMinute = moment(activity.published, moment.ISO_8601).endOf('minute');
      const lastDay = lastActivity.day;
      const lastMinute = lastActivity.minute;
      const sameDay = activityDay.diff(lastDay, 'days') === 0;
      const sameMinute = activityMinute.diff(lastMinute, 'minutes') === 0;
      const isReply = isReplyActivity(activity);

      if (!isReply && lastDay && !sameDay) {
        visibleActivityList.push({
          type: ITEM_TYPE_DAY_SEPARATOR,
          fromDate: lastDay,
          key: `day-separtor-${activity.id}`,
          now,
          toDate: activityDay
        });
      }

      if (!isReply) {
        lastActivity.day = activityDay;
      }

      lastActivity.minute = activityMinute;
      lastActivity.isReply = isReply; // New message marker

      if (shouldDisplayNewMessageMarker) {
        visibleActivityList.push({
          type: ITEM_TYPE_NEW_MESSAGE_SEPARATOR,
          key: `new-messages-${activity.id}`
        });
        shouldDisplayNewMessageMarker = false;
      } // Actual visible activity item
      // additional items don't repeat user avatar and name


      const isAdditional = sameDay && sameMinute && lastActorId === activity.actor.id && lastVerb === activity.verb;
      lastActorId = activity.actor.id;
      lastVerb = activity.verb;
      const isFlagged = !!flags.count() && flags.has(activity.url);
      const isFlagPending = isFlagged && flags.getIn([activity.url, 'isInFlight']);
      let formattedActivity = activity;

      if (activity.verb === 'post') {
        formattedActivity = Object.assign({}, activity, {
          object: formatActivity(activity.object, activityFormatter, onEvent)
        });
      } // Name of the user


      let name = activity.actor.displayName;

      if (activity.verb === 'add' || activity.verb === 'leave') {
        name = activity.object.displayName;
      }

      const visibleActivity = {
        currentUser,
        type: ITEM_TYPE_ACTIVITY,
        activity: formattedActivity,
        avatarUrl: avatars.get(activity.actor.id),
        isAdditional,
        isFlagged,
        isFlagPending,
        isSelf: currentUser.id === activity.actor.id,
        name
      };
      visibleActivityList.push(visibleActivity); // Check if this is the last read activity

      const isLastAcked = lastAcknowledgedActivityId && lastAcknowledgedActivityId === activity.id;
      const isNotSelf = currentUser.id !== activity.actor.id;

      if (isLastAcked && isNotSelf) {
        shouldDisplayNewMessageMarker = true;
      }
    }
  }); // Create a "fake" activity to display in flight activities

  inFlightActivities.forEach(inFlightActivity => {
    visibleActivityList.push({
      currentUser,
      type: ITEM_TYPE_ACTIVITY,
      activity: inFlightActivity,
      avatarUrl: avatars.get(currentUser.id),
      isAdditional: false,
      isFlagged: false,
      isFlagPending: false,
      isSelf: true,
      isPending: true
    });
  }); // Create a "fake" activity to display failed activities

  activityFailures.forEach(activityFailure => {
    visibleActivityList.push({
      currentUser,
      type: ITEM_TYPE_ACTIVITY,
      activity: activityFailure,
      avatarUrl: avatars.get(currentUser.id),
      isAdditional: false,
      hasError: true,
      isFlagged: false,
      isFlagPending: false,
      isSelf: true,
      isPending: true
    });
  });
  return visibleActivityList;
});

function mapStateToProps(state, props) {
  return Object.assign({}, props, {
    activities: getActivityList(state, props)
  });
}

const ActivityList = connect(mapStateToProps)(ActivityListComponent);
const injectedPropTypes = {
  activities: PropTypes.array
};
ActivityList.propTypes = {
  activityFormatter: PropTypes.func,
  newMessagesMessage: PropTypes.string.isRequired,
  onActivityDelete: PropTypes.func.isRequired,
  onActivityFlag: PropTypes.func.isRequired,
  onActivityRetry: PropTypes.func.isRequired,
  ...injectedPropTypes
};

export default ActivityList;
//# sourceMappingURL=index.js.map
