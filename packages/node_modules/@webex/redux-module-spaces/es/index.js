import { addError } from '@webex/redux-module-errors';
import { storeActivities } from '@webex/redux-module-activities';
import { createConversationBegin, storeConversation, computeRoomProperties } from '@webex/redux-module-conversation';
import { storeUsers } from '@webex/redux-module-users';
import { SPACE_TYPE_ONE_ON_ONE, SPACE_TYPE_GROUP, MENTION_NOTIFICATIONS_ON, MENTION_NOTIFICATIONS_OFF, MESSAGE_NOTIFICATIONS_ON, MESSAGE_NOTIFICATIONS_OFF, deconstructHydraId } from '@webex/react-component-utils';
import { Record, fromJS } from 'immutable';
import { union } from 'lodash';

const TAG_ONE_ON_ONE = 'ONE_ON_ONE';
const TAG_HIDDEN = 'HIDDEN';
const TAG_LOCKED = 'LOCKED';
function constructLastestActivity(items) {
  const latest = items.find(item => ['tombstone', 'delete'].indexOf(item.verb) === -1);
  return latest;
}
/**
 * Creates team object to be stored
 *
 * @param {Object} space
 * @param {Bool} isDecrypting
 * @returns {Object} formatted space object
 */

function constructSpace(space) {
  const latestActivity = constructLastestActivity(space.activities.items);
  const s = {
    avatar: space.avatar,
    displayName: space.displayName || space.computedTitle,
    id: space.id,
    url: space.url,
    globalId: space.globalId,
    locusUrl: space.locusUrl,
    activities: space.activities.items.map(a => a.id),
    lastReadableActivityDate: space.lastReadableActivityDate,
    lastSeenActivityDate: space.lastSeenActivityDate,
    conversationWebUrl: space.conversationWebUrl,
    participants: space.participants.items,
    type: space.tags.includes(TAG_ONE_ON_ONE) ? SPACE_TYPE_ONE_ON_ONE : SPACE_TYPE_GROUP,
    published: space.published,
    tags: space.tags,
    isDecrypting: space.isDecrypting,
    isHidden: space.tags.includes(TAG_HIDDEN),
    isLocked: space.tags.includes(TAG_LOCKED),
    isMentionNotificationsOn: space.tags && space.tags.includes(MENTION_NOTIFICATIONS_ON) ? true : undefined,
    isMentionNotificationsOff: space.tags && space.tags.includes(MENTION_NOTIFICATIONS_OFF) ? true : undefined,
    isMessageNotificationsOn: space.tags && space.tags.includes(MESSAGE_NOTIFICATIONS_ON) ? true : undefined,
    isMessageNotificationsOff: space.tags && space.tags.includes(MESSAGE_NOTIFICATIONS_OFF) ? true : undefined
  }; // Left spaces will still show up sometimes with empty activities

  if (!space.lastReadableActivityDate && space.published) {
    s.lastReadableActivityDate = space.published;
  }

  if (latestActivity) {
    s.latestActivity = latestActivity.id;
  }

  if (space.team) {
    s.team = space.team.id;
  }

  return s;
}
function constructSpaces(spaces) {
  return spaces.map(space => constructSpace(space));
}
/**
 * Converts a hydra room object to a conversation space object
 * (as much as possible)
 *
 * @param {object} room
 * @param {string} room.id ex: "Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0"
 * @param {string} room.title ex: "Project Unicorn - Sprint 0"
 * @param {string} room.type ex: "group"
 * @param {string} room.isLocked ex: true
 * @param {string} room.teamId ex: "Y2lzY29zcGFyazovL3VzL1JPT00vNjRlNDVhZTAtYzQ2Yi0xMWU1LTlkZjktMGQ0MWUzNDIxOTcz"
 * @param {string} room.lastActivity ex: "2016-04-21T19:12:48.920Z"
 * @param {string} room.creatorId ex: "Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY"
 * @param {string} room.created ex: "2016-04-21T19:01:55.966Z
 *
 * @returns {object} converted space object
 */

function constructSpaceFromHydraRoom(room) {
  const {
    id: globalId
  } = room;
  const {
    id,
    cluster
  } = deconstructHydraId(globalId);
  const team = room.teamId ? {
    id: deconstructHydraId(room.teamId).id
  } : '';
  const type = room.type === 'direct' ? SPACE_TYPE_ONE_ON_ONE : SPACE_TYPE_GROUP;
  const tags = room.isLocked ? [TAG_LOCKED] : [];
  return {
    id,
    cluster,
    globalId,
    type,
    team,
    tags,
    displayName: room.title,
    lastReadableActivityDate: room.lastActivity,
    isDecrypting: false,
    activities: {
      items: []
    },
    participants: {
      items: []
    }
  };
}

const STORE_SPACES = 'spaces/STORE_SPACES';
const UPDATE_SPACE_WITH_ACTIVITY = 'spaces/UPDATE_SPACE_WITH_ACTIVITY';
const UPDATE_SPACE_READ = 'spaces/UPDATE_SPACE_READ';
const ADD_SPACE_TAGS = 'spaces/ADD_SPACE_TAGS';
const REMOVE_SPACE_TAGS = 'spaces/REMOVE_SPACE_TAGS';
const REMOVE_SPACE = 'spaces/REMOVE_SPACE';
const STORE_SPACE = 'spaces/STORE_SPACE';
const STORE_INITIAL_SPACE = 'spaces/STORE_INITIAL_SPACE'; // The options to pass to convo service when fetching multiple spaces (for recents)

const spacesConversationOptions = {
  personRefresh: false,
  participantsLimit: 0,
  activitiesLimit: 0,
  computeTitleIfEmpty: true,
  globalId: true,
  paginate: true
};
/**
 * Updates the last seen date of a space
 * @param {String} spaceId
 * @param {String} lastSeenDate
 * @returns {Object}
 */

function updateSpaceRead(spaceId, lastSeenDate) {
  return {
    type: UPDATE_SPACE_READ,
    payload: {
      lastSeenDate,
      spaceId
    }
  };
}
/**
 * Adds to a space's tags with the provided array
 *
 * @export
 * @param {String} spaceId
 * @param {Array} tags
 * @returns {Object}
 */

function addSpaceTags(spaceId, tags) {
  return {
    type: ADD_SPACE_TAGS,
    payload: {
      spaceId,
      tags
    }
  };
}
/**
 * Removes from a space's tags the provided array
 *
 * @export
 * @param {String} spaceId
 * @param {Array} tags
 * @returns {Object}
 */

function removeSpaceTags(spaceId, tags) {
  return {
    type: REMOVE_SPACE_TAGS,
    payload: {
      spaceId,
      tags
    }
  };
}
function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}
function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces: constructSpaces(spaces)
    }
  };
}

function storeInitialSpace(id) {
  return {
    type: STORE_INITIAL_SPACE,
    payload: {
      id
    }
  };
}
/**
 * Adds a rate limit error to the errors module
 * @param {function} dispatch
 * @param {String} name
 */


function addLoadError(dispatch, name) {
  dispatch(addError({
    code: name,
    id: 'redux-module-spaces-load',
    displayTitle: 'Something\'s not right',
    displaySubtitle: `Unable to load spaces. Please try again later. [${name}]`,
    temporary: false
  }));
}

function decryptSpace(space) {
  if (typeof space.decrypt === 'function') {
    return space.decrypt().then(s => Promise.resolve(s));
  }

  return Promise.resolve(new Error('Space cannot be decrypted'));
}
/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @param {Boolean} isReadable if the activity is a readable activity
 * @returns {Object} action
 */


function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity.id,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}
/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} space - represents the space to fetch.
 *   Contains a 'url' or an 'id' and 'cluster'
 * @returns {function} thunk
 */

function fetchSpace(sparkInstance, space) {
  return dispatch => {
    dispatch(storeInitialSpace(space.id)); // This dispatch was moved here to maintain the legacy conversation redux
    // store values for usage within 'widget-message'. This dispatch clears and
    // initializes the redux store's 'conversation' value.

    dispatch(createConversationBegin());
    return sparkInstance.internal.conversation.get(space, {
      activitiesLimit: 40,
      participantsLimit: -1,
      participantAckFilter: 'all',
      includeParticipants: true,
      globalId: true,
      latestActivity: true
    }).then(fullSpace => {
      dispatch(storeUsers(fullSpace.participants.items));
      dispatch(storeActivities(fullSpace.activities.items));
      dispatch(storeSpaces([fullSpace])); // This dispatch was moved here to maintain the legacy conversation
      // redux store values for usage within 'widget-message'. This dispatch
      // stores the conversation details in the redux store's 'conversation'
      // value.

      dispatch(storeConversation(computeRoomProperties(fullSpace, sparkInstance)));
      return Promise.resolve(constructSpace(fullSpace));
    }).catch(err => {
      addLoadError(dispatch, err.name);
      throw err;
    });
  };
}
/**
 * Fetches spaces encrypted, stores encrypted spaces, then decrypts them.
 * This provides a better first time UX due to the fact that users can
 * see the decryption progress of each space.
 *
 * @export
 * @param {object} sparkInstance
 * @param {object} [options={}]
 * @returns {function} thunk
 */

function fetchSpacesEncrypted(sparkInstance, options = {}) {
  const listOptions = Object.assign({
    deferDecrypt: true
  }, spacesConversationOptions, options);
  return dispatch => sparkInstance.internal.conversation.list(listOptions).then(items => {
    const spaces = items.map(space => {
      const decryptPromise = decryptSpace(space).then(decryptedSpace => {
        if (decryptedSpace) {
          const s = Object.assign({}, decryptedSpace, {
            isDecrypting: false
          });
          dispatch(storeSpaces([s]));
          return Promise.resolve(constructSpace(s));
        }

        return Promise.resolve(new Error('Space was not decrypted correctly'));
      });
      return Object.assign({}, space, {
        isDecrypting: true,
        decryptPromise
      });
    });
    dispatch(storeSpaces(spaces));
    return Promise.resolve(spaces);
  }).catch(err => {
    addLoadError(dispatch, err.name);
    throw err;
  });
}
/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @returns {Function} thunk
 */

function fetchSpaces(sparkInstance, options = {}) {
  const listOptions = Object.assign({}, spacesConversationOptions, options);
  return dispatch => sparkInstance.internal.conversation.list(listOptions).then(spaces => {
    dispatch(storeSpaces(spaces));
    const constructedSpaces = spaces.map(constructSpace);
    return Promise.resolve(constructedSpaces);
  }).catch(err => {
    addLoadError(dispatch, err.name);
    throw err;
  });
}
function fetchSpacesHydra(sparkInstance, options = {}) {
  const defaultHydraOptions = {
    max: 100,
    sortBy: 'lastactivity'
  };
  const listOptions = Object.assign({}, defaultHydraOptions, options);
  return dispatch => sparkInstance.rooms.list(listOptions).then(rooms => {
    const spaces = rooms.items.map(constructSpaceFromHydraRoom);
    dispatch(storeSpaces(spaces));
    const constructedSpaces = spaces.map(constructSpace);
    return Promise.resolve(constructedSpaces);
  }).catch(err => {
    addLoadError(dispatch, err.name);
    throw err;
  });
}

const Space = Record({
  latestActivity: null,
  avatar: '',
  displayName: '',
  id: null,
  globalId: null,
  url: '',
  locusUrl: '',
  activities: [],
  lastReadableActivityDate: '',
  lastSeenActivityDate: '',
  lastActivityTimestamp: '',
  conversationWebUrl: '',
  participants: [],
  type: '',
  published: '',
  tags: [],
  team: null,
  isDecrypting: false,
  isLocked: false,
  isHidden: false,
  isFetching: false
});
const initialState = fromJS({
  byId: {}
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case ADD_SPACE_TAGS:
      {
        const {
          spaceId,
          tags
        } = action.payload;

        if (state.hasIn(['byId', spaceId])) {
          const originalTags = state.getIn(['byId', spaceId, 'tags']);
          return state.setIn(['byId', spaceId, 'tags'], union(originalTags, tags));
        }

        return state;
      }

    case REMOVE_SPACE:
      return state.deleteIn(['byId', action.payload.id]);

    case REMOVE_SPACE_TAGS:
      {
        const {
          spaceId,
          tags
        } = action.payload;

        if (state.hasIn(['byId', spaceId])) {
          const modifiedTags = state.getIn(['byId', spaceId, 'tags']);
          tags.forEach(t => {
            const index = modifiedTags.indexOf(t);

            if (index !== -1) {
              modifiedTags.splice(index, 1);
            }
          });
          return state.setIn(['byId', spaceId, 'tags'], modifiedTags);
        }

        return state;
      }

    case STORE_INITIAL_SPACE:
      {
        const {
          id
        } = action.payload;
        return state.setIn(['byId', id], new Space({
          id,
          isFetching: true
        }));
      }

    case STORE_SPACES:
      {
        const spaces = {};
        action.payload.spaces.forEach(s => {
          spaces[s.id] = new Space(s);
        });
        return state.mergeDeepIn(['byId'], spaces);
      }

    case UPDATE_SPACE_WITH_ACTIVITY:
      {
        const {
          space
        } = action.payload;

        if (state.hasIn(['byId', space.id])) {
          return state.mergeDeepIn(['byId', space.id], space);
        }

        return state;
      }

    case UPDATE_SPACE_READ:
      {
        const {
          lastSeenDate,
          spaceId
        } = action.payload;
        return state.setIn(['byId', spaceId, 'lastSeenActivityDate'], lastSeenDate);
      }

    default:
      return state;
  }
}

export default reducer;
export { ADD_SPACE_TAGS, REMOVE_SPACE, REMOVE_SPACE_TAGS, STORE_INITIAL_SPACE, STORE_SPACE, STORE_SPACES, UPDATE_SPACE_READ, UPDATE_SPACE_WITH_ACTIVITY, addSpaceTags, fetchSpace, fetchSpaces, fetchSpacesEncrypted, fetchSpacesHydra, initialState, removeSpace, removeSpaceTags, storeSpaces, updateSpaceRead, updateSpaceWithActivity };
//# sourceMappingURL=index.js.map
