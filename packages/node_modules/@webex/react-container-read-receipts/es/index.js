import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import classNames from 'classnames';
import { fetchAvatarsForUsers } from '@webex/redux-module-avatar';
import TypingAvatar from '@webex/react-component-typing-avatar';
import Badge from '@webex/react-component-badge';
import { createSelector } from 'reselect';
import { orderBy } from 'lodash';
import { getActivitiesFromThreadAndNonThreadCollections } from '@webex/redux-module-conversation';

const getConversationThreadActivities = state => state.conversation.get('threadActivities');

const getConversationNonThreadActivities = state => state.conversation.get('sortNonThreadActivities');

const getActivities = createSelector([getConversationThreadActivities, getConversationNonThreadActivities], getActivitiesFromThreadAndNonThreadCollections);

const getParticipants = state => state.conversation.get('participants');

const getUsers = state => state.users;

const getTypingIndicators = state => state.indicators.get('typing');

const getSpark = (state, ownProps) => ownProps.sparkInstance || state.spark.get('spark');

const READ_RECEIPTS_SHOWN_LIMIT = 10;
const getCurrentUser = createSelector([getUsers], users => users.getIn(['byId', users.get('currentUserId')]));
const getReadReceipts = createSelector([getCurrentUser, getActivities, getParticipants, getTypingIndicators], (currentUser, activities, participants, typing) => {
  const activity = activities.last();
  const readParticipants = participants.filter(participant => activity && currentUser && participant.get('id') !== currentUser.id && participant.getIn(['roomProperties', 'lastSeenActivityUUID']) === activity.id).toJS();
  const mappedParticipants = readParticipants.map(participant => {
    const participantId = participant.id; // Typing events don't give us user IDs, only emails.

    const isTyping = typing.has(participant.emailAddress);
    return {
      displayName: participant.displayName,
      isTyping,
      userId: participantId
    };
  });
  const sortedParticipants = orderBy(mappedParticipants, 'isTyping', 'desc');
  const visibleUsers = sortedParticipants.slice(0, READ_RECEIPTS_SHOWN_LIMIT);
  const hiddenUsers = sortedParticipants.slice(READ_RECEIPTS_SHOWN_LIMIT);
  return {
    hiddenUsers,
    visibleUsers
  };
});
const getReadReceiptsProps = createSelector([getReadReceipts, getSpark], (readReceipts, sparkInstance) => ({
  readReceipts,
  sparkInstance
}));

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".react-container-read-receipts__readReceipts__LnJlYWRS {\n  display: flex;\n  flex-direction: row;\n}\n";
var styles = {"readReceipts":"react-container-read-receipts__readReceipts__LnJlYWRS"};
styleInject(css_248z);

const injectedPropTypes = {
  fetchAvatarsForUsers: PropTypes.func.isRequired,
  readReceipts: PropTypes.shape({
    hiddenUsers: PropTypes.array,
    visibleUsers: PropTypes.array
  }),
  sparkInstance: PropTypes.object
};
const propTypes = { ...injectedPropTypes
};
class ReadReceipts extends Component {
  componentWillReceiveProps(nextProps) {
    const {
      visibleUsers
    } = this.props.readReceipts;
    const nextUsers = nextProps.readReceipts.visibleUsers;

    if (visibleUsers !== nextUsers) {
      this.props.fetchAvatarsForUsers(nextUsers.map(user => user.userId), this.props.sparkInstance);
    }
  }

  shouldComponentUpdate(nextProps) {
    const {
      props
    } = this;
    return nextProps.readReceipts !== props.readReceipts;
  }

  render() {
    const {
      hiddenUsers,
      visibleUsers
    } = this.props.readReceipts;
    const readReceipts = visibleUsers.map(user => /*#__PURE__*/React.createElement(TypingAvatar, {
      avatarId: user.userId,
      isTyping: user.isTyping,
      key: user.userId,
      name: user.displayName
    }));

    if (hiddenUsers.length) {
      const badgeTooltip = hiddenUsers.slice(0, 10).map(u => /*#__PURE__*/React.createElement("p", {
        key: u.userId
      }, u.displayName));

      if (hiddenUsers.length > 10) {
        const remainingHidden = `+${hiddenUsers.length - 10}`;
        badgeTooltip.push( /*#__PURE__*/React.createElement("p", null, remainingHidden));
      }

      readReceipts.push( /*#__PURE__*/React.createElement(Badge, {
        key: `${hiddenUsers.length}-remaining`,
        tooltip: badgeTooltip
      }, `+${hiddenUsers.length}`));
    }

    return /*#__PURE__*/React.createElement("div", {
      className: classNames('webex-read-receipts', styles.readReceipts)
    }, readReceipts);
  }

}
ReadReceipts.propTypes = propTypes;
var index = connect(getReadReceiptsProps, dispatch => bindActionCreators({
  fetchAvatarsForUsers
}, dispatch))(ReadReceipts);

export default index;
export { ReadReceipts };
//# sourceMappingURL=index.js.map
