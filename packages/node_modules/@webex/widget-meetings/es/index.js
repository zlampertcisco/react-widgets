import { compose, lifecycle, withHandlers } from 'recompose';
import { constructWebexEnhancer, withIntl } from '@webex/webex-widget-base';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { createSelector } from 'reselect';
import users, { PENDING_STATUS, getUser } from '@webex/redux-module-users';
import meetings, { buildDestinationLookup, addMediaToMeeting, createAndJoinMeeting, leaveMeeting } from '@webex/redux-module-meetings';
import avatar from '@webex/redux-module-avatar';
import errors$1, { addError, removeError } from '@webex/redux-module-errors';
import mercury, { connectToMercury } from '@webex/redux-module-mercury';
import presence from '@webex/redux-module-presence';
import { bindActionCreators } from 'redux';
import { defineMessages } from 'react-intl';
import classNames from 'classnames';
import LoadingScreen from '@webex/react-component-loading-screen';
import ErrorDisplay from '@webex/react-component-error-display';
import Video from '@webex/react-component-video';
import ButtonControls from '@webex/react-component-button-controls';
import PresenceAvatar from '@webex/react-container-presence-avatar';

const getErrors = state => state.errors;

const getMeetings = state => state.meetings;

const getSDKState = state => state.spark.get('status');

const getSDKInstance = state => state.spark.get('spark');

const getMercuryStatus = state => state.mercury.get('status');

const getUsers = state => state.users;

const getOwnProps = (state, ownProps) => ownProps;

const getMeetingDetails = createSelector([getMeetings, getSDKInstance, getOwnProps], (meetings, sdkInstance, props) => {
  let meeting;
  let meetingStatus = {};
  let meetingMedia = {};
  const {
    destinationId,
    destinationType
  } = props;
  const meetingId = meetings.getIn(['byDestination', buildDestinationLookup({
    destinationType,
    destinationId
  })]);

  if (meetingId) {
    // Get the meeting status from the store
    meetingStatus = meetings.getIn(['byId', meetingId]); // Get the meeting object from the SDK collection

    meeting = sdkInstance.meetings.meetingCollection.meetings[meetingId];

    if (meeting && meetingStatus.joined) {
      // Get the meeting media from the meeting instance
      let remoteVideoStream;

      if (meetingStatus.hasRemoteVideo || meetingStatus.hasRemoteAudio) {
        remoteVideoStream = meeting.mediaProperties.remoteStream;
      }

      meetingMedia = {
        // Only local tracks are in the SDK, so create a stream from it
        localVideoStream: meetingStatus.hasLocalMedia && new MediaStream([meeting.mediaProperties.videoTrack]),
        remoteVideoStream
      };
    }
  }

  return {
    meeting,
    meetingMedia,
    meetingStatus
  };
});
const getDestinationDetails = createSelector([getUsers, getOwnProps], (users, props) => {
  let avatarId, displayName;

  if (props.destinationType === destinationTypes.EMAIL) {
    // Get User ID from store
    const userId = users.getIn(['byEmail', props.destinationId]);

    if (userId && userId !== PENDING_STATUS) {
      avatarId = userId; // Get Display name from store

      const user = users.getIn(['byId', userId]);

      if (user) {
        ({
          displayName
        } = user);
      }
    }
  }

  const destination = {
    id: avatarId,
    avatarImage: '',
    displayName
  };
  return destination;
});
const getMeetingsWidgetProps = createSelector([getSDKState, getSDKInstance, getMercuryStatus, getDestinationDetails, getErrors, getMeetingDetails], (sdkState, sdkInstance, mercuryStatusRedux, destination, errors, meetingDetails) => {
  let error; // Check error store for an error

  if (errors.get('hasError')) {
    error = errors.get('errors').first();
  } // Mercury Status isn't a Redux Record yet, convert to js


  const mercuryStatus = mercuryStatusRedux.toJS(); // Meetings Widget is ready when SDK has device registered and websockets are connected

  const isReady = sdkState.authenticated && sdkState.registered && !sdkState.hasError && mercuryStatus.hasConnected && destination.displayName && !error;
  const {
    meeting,
    meetingMedia,
    meetingStatus
  } = meetingDetails;
  return {
    destination,
    error,
    isReady,
    meeting,
    meetingMedia,
    meetingStatus,
    mercuryStatus,
    sdkState,
    sdkInstance
  };
});

/*
 * WidgetRecents Messages
 *
 * This contains all the text for the FeaturePage component.
 */
var messages$1 = defineMessages({
  errorBadToken: {
    id: 'webex.container.meetings.error.badtoken',
    defaultMessage: 'Error: Bad or Invalid Access Token'
  },
  missingDestination: {
    id: 'webex.container.meetings.error.missingDestination',
    defaultMessage: 'Error: Destination ID and Type Required'
  },
  unableToLoad: {
    id: 'webex.container.meetings.error.unabletoload',
    defaultMessage: 'Unable to Load Meeting'
  },
  unknownError: {
    id: 'webex.container.meetings.error.unknown',
    defaultMessage: 'There was a problem loading meeting'
  }
});

function checkForSDKErrors(props) {
  const {
    errors,
    sdkState,
    sdkInstance
  } = props;
  const {
    formatMessage
  } = props.intl;
  const registerErrorId = 'sdk.register';

  if (sdkState.registerError && (!errors.get('hasError') || !errors.get('errors').has(registerErrorId))) {
    const error = sdkInstance.get('error');
    let displaySubtitle = formatMessage(messages$1.unknownError);

    if (error.statusCode === 401) {
      displaySubtitle = formatMessage(messages$1.errorBadToken);
    }

    props.addError({
      id: registerErrorId,
      displayTitle: formatMessage(messages$1.unableToLoad),
      displaySubtitle,
      temporary: false,
      code: error.statusCode
    });
  }
}

function checkForPropsErrors(props) {
  const {
    destinationId,
    destinationType,
    errors
  } = props;
  const {
    formatMessage
  } = props.intl;
  const missingDestinationErrorId = 'meetings.missingDestination';

  if ((!destinationId || !destinationType) && (!errors.get('hasError') || !errors.get('errors').has(missingDestinationErrorId))) {
    props.addError({
      id: missingDestinationErrorId,
      displayTitle: formatMessage(messages$1.missingDestination),
      temporary: false
    });
  }
}

var errors = compose(connect(state => state, dispatch => bindActionCreators({
  addError,
  removeError
}, dispatch)), lifecycle({
  componentWillMount() {
    checkForSDKErrors(this.props);
    checkForPropsErrors(this.props);
  },

  componentWillReceiveProps: nextProps => {
    checkForSDKErrors(nextProps);
    checkForPropsErrors(nextProps);
  }
}));

function fetchDestinationDetails(props) {
  const {
    sdkInstance,
    users
  } = props;

  if (!props.destinationId || !props.destinationType) {
    // This situation handled in errors.js
    return;
  }

  if (props.destinationType === destinationTypes.EMAIL) {
    // Get User ID
    const userID = users.getIn(['byEmail', props.destinationId]); // If it doesn't have a user id, start the request to get it

    if (!userID) {
      props.getUser({
        email: props.destinationId
      }, sdkInstance);
    }
  }
}
/**
 * Connects to the websocket server (mercury)
 * @param {object} props
 */


function connectWebsocket(props) {
  const {
    sdkInstance,
    mercuryStatus
  } = props;

  if (!mercuryStatus.hasConnected && !mercuryStatus.connecting && !mercuryStatus.connected && sdkInstance.internal.device.registered) {
    props.connectToMercury(sdkInstance);
  }
}
/**
 * The main setup process that proceeds through a series of events
 * based on the state of the application.
 *
 * @export
 * @param {*} props
 */


function setup(props) {
  const {
    mercuryStatus,
    sdkInstance,
    sdkState
  } = props; // We cannot do anything until the sdk is ready

  if (sdkInstance && sdkState.authenticated && sdkState.registered && !sdkState.hasError) {
    if (!mercuryStatus.connected) {
      connectWebsocket(props);
    } else {
      fetchDestinationDetails(props);
    }
  }
}
var setup$1 = compose(connect(getMeetingsWidgetProps, dispatch => bindActionCreators({
  connectToMercury,
  getUser
}, dispatch)), lifecycle({
  componentWillMount() {
    setup(this.props);
  },

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  },

  componentWillReceiveProps(nextProps) {
    setup(nextProps, this.props);
  }

}));

var enhancers = [errors, setup$1];

function handleStartMeeting(props) {
  return () => {
    const {
      destinationId,
      destinationType,
      sdkInstance
    } = props;
    props.createAndJoinMeeting({
      destinationId,
      destinationType
    }, sdkInstance).then(meeting => {
      // The store will get our meeting object from the sdk
      const meetingId = meeting.id;
      const receiveVideo = true;
      const receiveAudio = true;
      const receiveShare = true;
      const sendVideo = true;
      const sendAudio = true;
      const sendShare = false;
      props.addMediaToMeeting({
        meetingId,
        receiveVideo,
        receiveAudio,
        receiveShare,
        sendVideo,
        sendAudio,
        sendShare
      }, sdkInstance);
    });
  };
}

function handleLeaveMeeting(props) {
  return () => {
    const {
      destinationId,
      destinationType,
      sdkInstance
    } = props;
    props.leaveMeeting({
      destinationId,
      destinationType
    }, sdkInstance);
  };
}

var handlers = compose(connect(null, dispatch => bindActionCreators({
  addMediaToMeeting,
  createAndJoinMeeting,
  leaveMeeting
}, dispatch)), withHandlers({
  onLeaveMeeting: handleLeaveMeeting,
  onStartMeeting: handleStartMeeting
}));

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$3 = ".widget-meetings__localVideo__LmxvY2Fs {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 150px;\n  height: 84px;\n  padding: 10px;\n  cursor: pointer;\n  transition: transform 160ms linear;\n}\n\n.widget-meetings__meetingControls__LmxvY2Fs {\n  position: absolute;\n  bottom: 24px;\n  left: 0;\n  width: 100%;\n  margin: 0 auto;\n  text-align: center;\n  transition: all 160ms linear;\n  box-sizing: border-box;\n}\n";
var styles$2 = {"localVideo":"widget-meetings__localVideo__LmxvY2Fs","meetingControls":"widget-meetings__meetingControls__LmxvY2Fs"};
styleInject(css_248z$3);

const propTypes$2 = {
  localVideoStream: PropTypes.object,
  onLeaveClick: PropTypes.func.isRequired,
  remoteVideoStream: PropTypes.object
};
const defaultProps$2 = {
  localVideoStream: undefined,
  remoteVideoStream: undefined
};

function ActiveMeeting({
  localVideoStream,
  remoteVideoStream,
  onLeaveClick
}) {
  const controls = [];
  controls.push({
    accessibilityLabel: 'Hangup',
    buttonType: 'cancel',
    callControl: true,
    onClick: onLeaveClick
  });
  return /*#__PURE__*/React.createElement("div", null, localVideoStream && /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$2.localVideo, 'webex-meeting-active-local-video')
  }, /*#__PURE__*/React.createElement(Video, {
    audioMuted: true,
    srcObject: localVideoStream
  })), remoteVideoStream && remoteVideoStream.active && /*#__PURE__*/React.createElement(Video, {
    srcObject: remoteVideoStream
  }), /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$2.meetingControls, 'webex-meeting-active-controls')
  }, /*#__PURE__*/React.createElement(ButtonControls, {
    buttons: controls,
    showLabels: false
  })));
}

ActiveMeeting.propTypes = propTypes$2;
ActiveMeeting.defaultProps = defaultProps$2;

var css_248z$2 = ".widget-meetings__meetingInactiveContainer__Lm1lZXRp {\n  position: relative;\n  display: flex;\n  width: 100%;\n  margin: auto;\n  text-align: center;\n  flex: 1 1 auto;\n  align-items: center;\n  flex-direction: column;\n}\n\n.widget-meetings__personName__Lm1lZXRp {\n  width: 100%;\n  margin: 10px;\n  overflow: hidden;\n  font-size: 32px;\n  color: #707071;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.widget-meetings__meetingControls__Lm1lZXRp {\n  z-index: 100;\n  text-align: center;\n}\n\n.widget-meetings__meetingControls__Lm1lZXRp .widget-meetings__meetingButton__Lm1lZXRp {\n  background-color: #30d557;\n}\n\n.widget-meetings__meetingControls__Lm1lZXRp .widget-meetings__meetingButton__Lm1lZXRp:hover {\n  background-color: #2ac44f;\n}\n";
var styles$1 = {"meetingInactiveContainer":"widget-meetings__meetingInactiveContainer__Lm1lZXRp","personName":"widget-meetings__personName__Lm1lZXRp","meetingControls":"widget-meetings__meetingControls__Lm1lZXRp","meetingButton":"widget-meetings__meetingButton__Lm1lZXRp"};
styleInject(css_248z$2);

const propTypes$1 = {
  avatarId: PropTypes.string,
  avatarImage: PropTypes.string,
  joinButtonAriaLabel: PropTypes.string,
  joinButtonLabel: PropTypes.string,
  displayName: PropTypes.string,
  onJoinClick: PropTypes.func
};
const defaultProps$1 = {
  avatarId: '',
  avatarImage: '',
  joinButtonAriaLabel: 'Join Meeting',
  joinButtonLabel: 'Join',
  displayName: 'Unknown',
  onJoinClick: () => {}
};

function InactiveMeeting({
  avatarId,
  avatarImage,
  onJoinClick,
  joinButtonAriaLabel,
  joinButtonLabel,
  displayName
}) {
  const buttons = [{
    label: joinButtonLabel,
    accessibilityLabel: joinButtonAriaLabel,
    buttonClassName: styles$1.meetingButton,
    buttonType: 'camera',
    onClick: onJoinClick
  }];
  return /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$1.meetingInactiveContainer, 'webex-meeting-inactive-container')
  }, /*#__PURE__*/React.createElement(PresenceAvatar, {
    avatarId: avatarId,
    image: avatarImage,
    name: displayName,
    size: 84
  }), /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$1.personName, 'webex-meeting-person-name')
  }, displayName), /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$1.meetingControls, 'webex-meeting-controls-container')
  }, /*#__PURE__*/React.createElement(ButtonControls, {
    buttons: buttons,
    showLabels: true
  })));
}

InactiveMeeting.propTypes = propTypes$1;
InactiveMeeting.defaultProps = defaultProps$1;

var css_248z$1 = "$brand-font-folder: \"~@momentum-ui/core/fonts\";\n$icon-font-path: \"~@momentum-ui/icons/fonts\";\n\n@import '~@momentum-ui/core/scss/momentum-ui-components';\n";
styleInject(css_248z$1);

var css_248z = ".widget-meetings__meetingsWidget__Lm1lZXRp {\n  display: flex;\n  height: 100%;\n  flex-direction: column;\n}\n\n.widget-meetings__errorWrapper__Lm1lZXRp {\n  position: absolute;\n  z-index: 1000;\n  width: 100%;\n  height: 100%;\n}\n";
var styles = {"meetingsWidget":"widget-meetings__meetingsWidget__Lm1lZXRp","errorWrapper":"widget-meetings__errorWrapper__Lm1lZXRp"};
styleInject(css_248z);

const propTypes = {
  destination: PropTypes.shape({
    avatarId: PropTypes.string,
    avatarImage: PropTypes.string,
    callButtonAriaLabel: PropTypes.string,
    callButtonLabel: PropTypes.string,
    displayName: PropTypes.string,
    joinButtonAriaLabel: PropTypes.string,
    joinButtonLabel: PropTypes.string
  }),
  error: PropTypes.shape({
    displayTitle: PropTypes.string,
    displaySubtitle: PropTypes.string,
    temporary: PropTypes.bool
  }),
  isReady: PropTypes.bool,
  meeting: PropTypes.object,
  meetingMedia: PropTypes.shape({
    localVideoStream: PropTypes.object,
    remoteVideoStream: PropTypes.object
  }),
  meetingStatus: PropTypes.object,
  onJoinClick: PropTypes.func.isRequired,
  onLeaveClick: PropTypes.func.isRequired
};
const defaultProps = {
  destination: {},
  error: undefined,
  isReady: false,
  meeting: undefined,
  meetingMedia: {},
  meetingStatus: {}
};

function MeetingsWidget(props) {
  const {
    destination,
    error,
    isReady,
    meeting,
    meetingMedia,
    meetingStatus,
    onJoinClick,
    onLeaveClick
  } = props;
  let main;

  if (error) {
    const {
      displayTitle,
      displaySubtitle,
      temporary
    } = error;
    main = /*#__PURE__*/React.createElement("div", {
      className: classNames(['webex-meetings-widget-error', styles.errorWrapper])
    }, /*#__PURE__*/React.createElement(ErrorDisplay, {
      secondaryTitle: displaySubtitle,
      title: displayTitle,
      transparent: temporary
    }));
  } else if (isReady) {
    if (meeting && meetingStatus.joined) {
      main = /*#__PURE__*/React.createElement(ActiveMeeting, {
        localVideoStream: meetingMedia.localVideoStream,
        onLeaveClick: onLeaveClick,
        remoteVideoStream: meetingMedia.remoteVideoStream
      });
    } else {
      main = /*#__PURE__*/React.createElement(InactiveMeeting, {
        avatarId: destination.avatarId,
        onJoinClick: onJoinClick,
        avatarImage: destination.avatarImage,
        joinButtonAriaLabel: destination.joinButtonAriaLabel,
        joinButtonLabel: destination.joinButtonLabel,
        displayName: destination.displayName
      });
    }
  } else {
    main = /*#__PURE__*/React.createElement(LoadingScreen, null);
  }

  return /*#__PURE__*/React.createElement("div", {
    className: classNames(['webex-meetings-widget', 'md', styles.meetingsWidget])
  }, main);
}

MeetingsWidget.propTypes = propTypes;
MeetingsWidget.defaultProps = defaultProps;

const injectedPropTypes = {
  destination: PropTypes.shape({
    avatarId: PropTypes.string,
    avatarImage: PropTypes.string,
    callButtonAriaLabel: PropTypes.string,
    callButtonLabel: PropTypes.string,
    displayName: PropTypes.string
  }),
  error: PropTypes.shape({
    displayTitle: PropTypes.string,
    displaySubtitle: PropTypes.string,
    temporary: PropTypes.bool
  }),
  isReady: PropTypes.bool,
  meeting: PropTypes.object,
  meetingMedia: PropTypes.shape({
    localVideoStream: PropTypes.object,
    remoteVideoStream: PropTypes.object
  }),
  meetingStatus: PropTypes.object
}; // Action props from handlers.js

const handlerPropTypes = {
  onLeaveMeeting: PropTypes.func,
  onStartMeeting: PropTypes.func
}; // Props via the main react component

const ownPropTypes = {
  destinationId: PropTypes.string.isRequired,
  destinationType: PropTypes.oneOf(['email', 'spaceId', 'userId', 'sip', 'pstn']).isRequired
};
class ConnectedMeetingsWidget extends Component {
  // Component missing functionality?
  // We are utilizing the "lifecycle" methods from recompose to reduce the
  // amount of code in the main component.
  // These files live in the "enhancers" folder.
  // Note: these could be eventually replaced by react hooks,
  // but are enhancers for consistency with the other widgets.
  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  render() {
    const {
      destination,
      error,
      isReady,
      meeting,
      meetingMedia,
      meetingStatus
    } = this.props;
    return /*#__PURE__*/React.createElement(MeetingsWidget, {
      destination: destination,
      error: error,
      isReady: isReady,
      meeting: meeting,
      meetingMedia: meetingMedia,
      meetingStatus: meetingStatus,
      onJoinClick: this.props.onStartMeeting,
      onLeaveClick: this.props.onLeaveMeeting
    });
  }

}
ConnectedMeetingsWidget.propTypes = { ...injectedPropTypes,
  ...handlerPropTypes,
  ...ownPropTypes
};
var ConnectedMeetingsWidget$1 = compose(connect(getMeetingsWidgetProps), ...enhancers, handlers)(ConnectedMeetingsWidget);

const reducers = {
  avatar,
  errors: errors$1,
  meetings,
  mercury,
  presence,
  users
};

var messages = {};

const destinationTypes = {
  SIP: 'sip',
  EMAIL: 'email',
  USERID: 'userId',
  SPACEID: 'spaceId',
  PSTN: 'pstn'
};
var index = compose(constructWebexEnhancer({
  name: 'meetings',
  reducers
}), withIntl({
  locale: 'en',
  messages
}))(ConnectedMeetingsWidget$1);

export default index;
export { destinationTypes, reducers };
//# sourceMappingURL=index.js.map
