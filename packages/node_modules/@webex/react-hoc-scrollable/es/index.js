import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { autobind } from 'core-decorators';
import { getDisplayName } from '@webex/react-component-utils';

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".react-hoc-scrollable__scrollable__LnNjcm9s {\n  overflow: hidden;\n  overflow-y: scroll;\n  flex: 1;\n}\n";
var styles = {"scrollable":"react-hoc-scrollable__scrollable__LnNjcm9s"};
styleInject(css_248z);

const propTypes = {
  onScroll: PropTypes.func
};
const defaultProps = {
  onScroll: () => {}
};
function injectScrollable(WrappedComponent) {
  var _class;

  let ScrollableComponent = (_class = class ScrollableComponent extends Component {
    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    }

    getNode(node) {
      this.node = node;
    }

    getScrollHeight() {
      return this.node.scrollHeight;
    }

    getScrollTop() {
      return this.node.scrollTop;
    }

    setScrollTop(top) {
      this.node.scrollTop = top;
    }

    scrollToBottom() {
      const {
        node
      } = this;
      node.scrollTop = node.scrollHeight;
    }

    isScrolledToTop() {
      return this.node.scrollTop < 100;
    }

    isScrolledToBottom() {
      const {
        node
      } = this;
      return node.scrollHeight - node.offsetHeight - node.scrollTop < 150;
    }

    render() {
      return /*#__PURE__*/React.createElement("div", {
        className: styles.scrollable,
        onScroll: this.props.onScroll,
        ref: this.getNode
      }, /*#__PURE__*/React.createElement(WrappedComponent, this.props));
    }

  }, (_applyDecoratedDescriptor(_class.prototype, "getNode", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "getNode"), _class.prototype)), _class);
  ScrollableComponent.propTypes = propTypes;
  ScrollableComponent.defaultProps = defaultProps;
  ScrollableComponent.displayName = `ScrollableComponent(${getDisplayName(WrappedComponent)})`;
  ScrollableComponent.WrappedComponent = WrappedComponent;
  return ScrollableComponent;
}

export default injectScrollable;
//# sourceMappingURL=index.js.map
