import uuid from 'uuid';
import moment from 'moment';
import { base64, constructHydraId as constructHydraId$1, deconstructHydraId } from '@webex/common';
export { deconstructHydraId } from '@webex/common';
import { escapeSync } from '@webex/helper-html';
import { setDisplayName, wrapDisplayName } from 'recompose';
import * as AdaptiveCard from 'adaptivecards';
import MDTextInput from '@webex/react-component-md-text-input';
import MDToggleInput from '@webex/react-component-md-toggle-input';
import MDChoiceSetInput from '@webex/react-component-md-choiceset-input';
import { createMessageObject } from '@webex/redux-module-activity';
import ReactDOM from 'react-dom';

const API_ACTIVITY_VERB = {
  ACKNOWLEDGE: 'acknowledge',
  ADD: 'add',
  ADD_MICROAPP_INSTANCE: 'addMicroappInstance',
  ARCHIVE: 'archive',
  ASSIGN: 'assign',
  ASSIGN_MODERATOR: 'assignModerator',
  CANCEL: 'cancel',
  CREATE: 'create',
  DECLINE: 'decline',
  DELETE: 'delete',
  FAVORITE: 'favorite',
  GAP: 'gap',
  HIDE: 'hide',
  LEAVE: 'leave',
  LOCK: 'lock',
  MUTE: 'mute',
  POST: 'post',
  REMOVE: 'remove',
  SCHEDULE: 'schedule',
  SET: 'set',
  SHARE: 'share',
  START: 'start',
  TAG: 'tag',
  TERMINATE: 'terminate',
  TOMBSTONE: 'tombstone',
  UNARCHIVE: 'unarchive',
  UNASSIGN: 'unassign',
  UNASSIGN_MODERATOR: 'unassignModerator',
  UNFAVORITE: 'unfavorite',
  UNHIDE: 'unhide',
  UNLOCK: 'unlock',
  UNMUTE: 'unmute',
  UNSET: 'unset',
  UNTAG: 'untag',
  UPDATE: 'update',
  UPDATEKEY: 'updateKey'
};
const API_ACTIVITY_TYPE = {
  REPLY: 'reply'
};
const MENTION_NOTIFICATIONS_ON = 'MENTION_NOTIFICATIONS_ON';
const MENTION_NOTIFICATIONS_OFF = 'MENTION_NOTIFICATIONS_OFF';
const MESSAGE_NOTIFICATIONS_ON = 'MESSAGE_NOTIFICATIONS_ON';
const MESSAGE_NOTIFICATIONS_OFF = 'MESSAGE_NOTIFICATIONS_OFF';
const NOTIFICATIONS_GLOBAL = 'NOTIFICATIONS_GLOBAL';
const NOTIFICATIONS_OFF = 'NOTIFICATIONS_OFF';
const NOTIFICATIONS_MENTIONS = 'NOTIFICATIONS_MENTIONS';
const NOTIFICATIONS_ALL = 'NOTIFICATIONS_ALL';
const EMAIL_NOTIFICATIONS_MENTIONS = 'EMAIL_NOTIFICATIONS_MENTIONS';
const EMAIL_NOTIFICATIONS_ONE_TO_ONES = 'EMAIL_NOTIFICATIONS_ONE_TO_ONES';
const EMAIL_NOTIFICATIONS_DIGEST_EMAILS = 'EMAIL_NOTIFICATIONS_DIGEST_EMAILS';
const NOTIFICATIONS_BADGE_NONE = 'NOTIFICATIONS_BADGE_NONE';
const NOTIFICATIONS_BADGE_UNREAD = 'NOTIFICATIONS_BADGE_UNREAD';
const NOTIFICATIONS_BADGE_MENTION = 'NOTIFICATIONS_BADGE_MENTION';
const NOTIFICATIONS_BADGE_MUTE = 'NOTIFICATIONS_BADGE_MUTE';
const NOTIFICATIONS_BADGE_UNMUTE = 'NOTIFICATIONS_BADGE_UNMUTE';
const FEATURES_USER = 'user';
const FEATURES_GROUP_MESSAGE_NOTIFICATIONS = 'group-message-notifications';
const FEATURES_MENTION_NOTIFICATIONS = 'mention-notifications';
const SPACE_TYPE_ONE_ON_ONE = 'direct';
const SPACE_TYPE_GROUP = 'group';
const TAG_MUTED = 'MUTED';
const CARD_ATTACHMENT_TYPE = 'AdaptiveCard';
const CARD_CONTAINS_IMAGE = 'cardReference';
const ACTIVITY_CARDS = 'cards';
const ACTIVITY_OBJECT_CONTENT_CATEGORY_IMAGES = 'images';
const ADAPTIVE_CARD_OPEN_URL_ACTION = 'Action.OpenUrl';
const ADAPTIVE_CARD_SUBMIT_ACTION = 'Action.Submit';
const FEATURES_DEVELOPER = 'developer';
const FEATURES_WIDGET_ADAPTIVE_CARD = 'WIDGET_ADAPTIVE_CARD';
const FEATURES_WIDGET_ADAPTIVE_CARD_OFF = 'WIDGET_ADAPTIVE_CARD_OFF';
const FEATURES_WIDGET_ADAPTIVE_CARD_ON = 'WIDGET_ADAPTIVE_CARD_ON';
const DEFAULT_VALUE_CHECK_BOX = 'Choose';
const TEXT_INPUT_ELEMENT = 'Input.Text';
const TOGGLE_INPUT_ELEMENT = 'Input.Toggle';
const CHOICE_SET_INPUT_ELEMENT = 'Input.ChoiceSet';
const SUCCESS = 'SUCCESS';
const FAILURE = 'FAILURE';
const PENDING = 'PENDING';
const FILE_TYPES = {
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'spreadsheet',
  'application/pdf': 'pdf',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'presentation',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'doc',
  'application/vnd.ms-excel': 'spreadsheet',
  'application/octet-stream': 'binary',
  'application/zip': 'zip'
};
const FILE_ATTACHMENT_MAX_SIZE = 150000000; // 150 MB threshold limit

const ADAPTIVE_CARD_HOST_CONFIG = {
  hostCapabilities: {
    capabilities: null
  },
  choiceSetInputValueSeparator: ',',
  supportsInteractivity: true,
  fontFamily: 'CiscoSansTT Regular',
  spacing: {
    small: 4,
    default: 12,
    medium: 12,
    large: 12,
    extraLarge: 16,
    padding: 12
  },
  fontSizes: {
    small: 12,
    default: 14,
    medium: 16,
    large: 20,
    extraLarge: 24
  },
  fontWeights: {
    lighter: 300,
    default: 400,
    bolder: 700
  },
  imageSizes: {
    small: 40,
    medium: 80,
    large: 160
  },
  containerStyles: {
    default: {
      foregroundColors: {
        default: {
          default: '#171B1F',
          subtle: '#535759'
        },
        dark: {
          default: '#535759',
          subtle: '#535759'
        },
        light: {
          default: '#535759',
          subtle: '#929596'
        },
        accent: {
          default: '#007EA8',
          subtle: '#00A0D1'
        },
        good: {
          default: '#1B8728',
          subtle: '#24AB31'
        },
        warning: {
          default: '#D93829',
          subtle: '#FF5C4A'
        },
        attention: {
          default: '#C74F0E',
          subtle: '#F26B1D'
        }
      },
      backgroundColor: '#FFFFFF'
    },
    emphasis: {
      foregroundColors: {
        default: {
          default: '#171B1F',
          subtle: '#535759'
        },
        dark: {
          default: '#171B1F',
          subtle: '#535759'
        },
        light: {
          default: '#535759',
          subtle: '#929596'
        },
        accent: {
          default: '#007EA8',
          subtle: '#00A0D1'
        },
        good: {
          default: '#1B8728',
          subtle: '#24AB31'
        },
        warning: {
          default: '#D93829',
          subtle: '#FF5C4A'
        },
        attention: {
          default: '#C74F0E',
          subtle: '#F26B1D'
        }
      },
      backgroundColor: '#F2F4F5'
    }
  },
  actions: {
    maxActions: 5,
    buttonSpacing: 8,
    showCard: {
      actionMode: 'Inline',
      inlineTopMargin: 16,
      style: 'emphasis'
    },
    preExpandSingleShowCardAction: false,
    actionsOrientation: 'Horizontal',
    actionAlignment: 'Left'
  },
  adaptiveCard: {
    allowCustomStyle: false
  },
  imageSet: {
    maxImageHeight: 100
  },
  media: {
    allowInlinePlayback: true
  },
  factSet: {
    title: {
      size: 'Default',
      color: 'Default',
      isSubtle: false,
      weight: 'Bolder',
      wrap: true
    },
    value: {
      size: 'Default',
      color: 'Default',
      isSubtle: false,
      weight: 'Default',
      wrap: true
    },
    spacing: 10
  },
  cssClassNamePrefix: null
};

/**
 * Converts bytes to human readable size
 * @param {Number} bytes
 * @returns {String}
 */

function bytesToSize(bytes) {
  if (!bytes || bytes === 0) {
    return '0 Bytes';
  }

  const k = 1000;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  const output = (bytes / k ** i).toPrecision(3);
  return `${output} ${sizes[i]}`;
}
/**
 * Converts a buffer object to a objectUrl and blob
 * @param {Object} buffer
 * @returns {Object}
 */

function bufferToBlob(buffer) {
  const urlCreator = window.URL || window.webkitURL;
  const blob = new Blob([buffer], {
    type: buffer.type
  });
  const objectUrl = urlCreator.createObjectURL(blob);
  return {
    blob,
    objectUrl
  };
}
/**
 * Formats a file object with the appropriate fields
 * @param {Object} file
 * @returns {Object}
 */

function constructFile(file) {
  return Object.assign(file, {
    clientTempId: uuid.v4(),
    displayName: file.name,
    fileSize: file.size,
    fileSizePretty: bytesToSize(file.size),
    mimeType: file.type
  });
}
/**
 * Takes an array of files and formats them with appropriate fields
 * @param {Array} files
 * @returns {Array}
 */

function constructFiles(files) {
  const constructedFiles = [];

  for (let i = 0; i < files.length; i += 1) {
    constructedFiles.push(constructFile(files[i]));
  }

  return constructedFiles;
}
/**
 * Checks if file object is an image
 * @param {Object} file
 * @returns {Boolean}
 */

function isImage(file) {
  return file.type.indexOf('image') !== -1;
}
/**
 * Cleans a file object
 * @param {Object} file
 * @returns {Object}
 */

function sanitize(file) {
  return Object.assign(file, {
    id: file.clientTempId,
    displayName: file.displayName || null,
    fileSize: file.fileSize || 0,
    fileSizePretty: bytesToSize(file.fileSize)
  });
}
/**
 * Converts a mimeType string into a human readable string
 * @param {String} mimeType
 * @returns {String}
 */

function getFileType(mimeType) {
  if (FILE_TYPES[mimeType]) {
    return FILE_TYPES[mimeType];
  }

  if (mimeType) {
    const tokens = mimeType.split('/');

    if (tokens[0] === 'image') {
      return 'image';
    }

    if (tokens[0] === 'text') {
      return `${tokens[1].charAt(0).toUpperCase()}${tokens[1].slice(1)} file`;
    }
  }

  return 'file';
}
/**
 * Checks the files in an array and determines if their file size is too large.
 *
 * @param {Array} files An array of file objects with a `size` property
 * @param {function} addError Function from the errors redux action
 * @param {function} removeError Function from the errors redux action
 * @returns {boolean0}
 */

function checkMaxFileSize(files, addError, removeError) {
  const maxSizeExceeded = files.some(file => file.size >= FILE_ATTACHMENT_MAX_SIZE);

  if (maxSizeExceeded) {
    const errorID = 'file-attachment-threshold';
    addError({
      id: errorID,
      actionTitle: 'Dismiss',
      onAction: () => removeError(errorID),
      displayTitle: 'Too big for the web!',
      displaySubtitle: 'Only attachments smaller than 150MB are allowed',
      temporary: true
    });
    return false;
  }

  return true;
}

/**
 * Takes a component and provides the correct name
 * @param {String} C
 * @returns {String}
 */
function getDisplayName(C) {
  return C.displayName || C.name || 'C';
}

/**
 * format
 * - before a week ago from now: MM/DD/YY, h:mm meridiem
 * - yesterday: Yesterday at h:mm
 * - a week ago from now: DAY h:mm meridiem
 * - today: h:mm meridiem
 *
 * @param {Object} time moment object for specific time
 * @returns {String} nicely formatted timestamp
 */

function formatDate(time) {
  const now = moment();
  let rawTime = time || moment();

  switch (typeof rawTime) {
    case 'number':
    case 'string':
      rawTime = moment(rawTime);
      break;
  } // note endOf(day) compare to normalize now no matter how it was created


  if (now.endOf('day').diff(rawTime, 'days') === 0) {
    // today
    return rawTime.format('h:mm A');
  }

  if (now.startOf('day').diff(rawTime) <= 86400000) {
    // yesterday (60*60*24*1000 = 86400000)
    return rawTime.calendar();
  }

  if (now.startOf('day').diff(rawTime) <= 518400000) {
    // 6 days ago from today (60*60*24*6*1000 = 518400000)
    return rawTime.format('dddd h:mm A');
  }

  return rawTime.format('M/D/YY, h:mm A');
}

/**
 * Constructs a default activity
 *
 * @export
 * @param {object} conversation
 * @param {object} activityObject
 * @param {any} actor
 * @param {boolean} [sanitize = false]
 * @returns {object}
 */

function constructActivity(conversation, activityObject, actor, sanitize = false) {
  const clientTempId = `sdk-widget-${uuid.v4()}`;
  return {
    actor: {
      displayName: actor.name,
      id: actor.id,
      objectType: 'person'
    },
    // Needed for round trip
    clientTempId,
    id: clientTempId,
    // Minimum properties needed by API
    object: sanitize ? { ...activityObject,
      content: activityObject.content && escapeSync(activityObject.content)
    } : activityObject,
    target: {
      id: conversation.id,
      objectType: 'conversation'
    },
    verb: 'post',
    published: new Date().toISOString(),
    clientPublished: new Date().toISOString(),
    _status: 'pending',
    _meta: {
      actor,
      conversation,
      text: activityObject
    }
  };
}
/**
 * Constructs a share activity
 *
 * @export
 * @param {object} conversation
 * @param {object} activityObject
 * @param {object} actor
 * @param {array} files
 * @param {object} shareActivity
 * @param {boolean} [sanitize = false]
 * @returns {object}
 */
// eslint-disable-next-line max-len

function constructActivityWithContent(conversation, activityObject, actor, files, shareActivity, sanitize = false) {
  const activity = constructActivity(conversation, activityObject, actor, sanitize);
  activity.object.objectType = 'content';
  activity.verb = 'share';
  const items = files.map(file => {
    const item = Object.assign({}, file, {
      objectType: 'file',
      url: file.clientTempId
    });

    if (isImage(file)) {
      item.image = {
        url: file.thumbnail
      };
    }

    return item;
  });
  activity.object.files = {
    items
  }; // eslint-disable-reason _meta comes from SDK
  // eslint-disable-next-line no-underscore-dangle

  activity._meta.shareActivity = shareActivity;
  return activity;
}
/**
 * Constructs an Event from incoming Mercury Activity
 *
 * @export
 * @param {Object} activity from Mercury
 * @returns {Object}
 */

function constructActivityEventData(activity) {
  const hydraActivity = Object.assign({}, activity);
  hydraActivity.actorId = base64.encode(`ciscospark://us/PEOPLE/${activity.actor.id}`); // Base64 encode uuids

  hydraActivity.id = base64.encode(`ciscospark://us/MESSAGE/${activity.id}`);
  hydraActivity.roomId = base64.encode(`ciscospark://us/ROOM/${activity.target.id}`);
  hydraActivity.target = Object.assign({}, activity.target, {
    id: base64.encode(`ciscospark://us/ROOM/${activity.target.id}`)
  });
  return hydraActivity;
}

/**
 * Constructs a hydra id for a given uuid and type
 *
 * @export
 * @param {string} type one of PEOPLE, TEAM, ROOM
 * @param {any} id
 * @param {string} cluster
 * @returns {string}
 */

function constructHydraId(type, id, cluster) {
  return id ? constructHydraId$1(type, id, cluster) : '';
}
const hydraTypes = {
  ATTACHMENT_ACTION: 'ATTACHMENT_ACTION',
  CONTENT: 'CONTENT',
  MEMBERSHIP: 'MEMBERSHIP',
  MESSAGE: 'MESSAGE',
  ORGANIZATION: 'ORGANIZATION',
  PEOPLE: 'PEOPLE',
  ROOM: 'ROOM',
  TEAM: 'TEAM'
};
/**
 * Tests if a string is a UUID
 * @param {String} string
 * @returns {Boolean}
 */

function isUuid(string) {
  const uuidRegExp = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegExp.test(string);
}
/**
 * Takes a Conversation URL and returns the Uuid
 * @param {String} convoUrl
 * @returns {String|Boolean}
 */

function getConvoIdFromUrl(convoUrl) {
  const id = convoUrl.split('/').pop();

  if (isUuid(id)) {
    return id;
  }

  return false;
}
/**
 * @typedef {object} DeconstructedId
 * @param {string} [id] - id of the object destructed
 * @param {string} [cluster] - cluster location of the object destructed
 * @param {string} [type] - type of object destructed
 */

/**
 * Validates a id as a UUID or a hydra encoded UUID
 * @param {String} id
 * @returns {DeconstructedId} empty object if not a valid input
 */

function validateAndDecodeId(id) {
  if (!(id && id.length)) {
    return {};
  }

  if (isUuid(id)) {
    return {
      id
    };
  } // Check for base 64 encoding


  try {
    const idParts = deconstructHydraId(id);

    if (isUuid(idParts.id)) {
      return idParts;
    }
  } catch (e) {
    if (e.name !== 'InvalidCharacterError') {
      throw e;
    }
  }

  return {};
}

function validateSipUri(uri) {
  const re = /^(sip):(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(uri);
}

function setWrappedDisplayName(name) {
  return BaseComponent => setDisplayName(wrapDisplayName(BaseComponent.WrappedComponent || BaseComponent, name))(BaseComponent);
}

/**
 * @param {String} hex
 * @param {Boolean} isDarkShade
 * @returns {String}
*/
function getTeamColor(hex, isDarkShade) {
  switch (hex) {
    // archived
    case '#AEAEAF':
      return hex;
    // red

    case '#F0AFA7':
    case '#83605B':
    case '#EC6959':
    case '#F96C5E':
    case '#AE3201':
    case '#EB596B':
    case '#C05E59':
    case '#F4735E':
    case '#FF8F84':
    case '#E1480B':
      return isDarkShade ? '#83605B' : '#F0AFA7';
    // bouquet

    case '#DABDCA':
    case '#77676E':
    case '#B57B94':
    case '#BA4E9E':
    case '#C7567A':
    case '#B92819':
      return isDarkShade ? '#77676E' : '#DABDCA';
    // plum

    case '#D7ABE1':
    case '#765D7B':
    case '#BA4D9F':
    case '#E2738C':
    case '#A15AA1':
    case '#8164A8':
    case '#8E5ACF':
    case '#A359A3':
    case '#AF56C2':
    case '#C589C5':
    case '#731F73':
      return isDarkShade ? '#765D7B' : '#D7ABE1';
    // blue

    case '#A9C7EF':
    case '#5C6D83':
    case '#5390E0':
    case '#04699A':
    case '#3F8AA6':
    case '#7875E1':
    case '#0991D3':
    case '#28A1DB':
      return isDarkShade ? '#5C6D83' : '#A9C7EF';
    // yellow

    case '#F6D28D':
    case '#87734D':
    case '#D28C07':
    case '#C6871F':
    case '#C4AE50':
    case '#F8AF26':
      return isDarkShade ? '#87734D' : '#F6D28D';
    // green

    case '#B8D2A9':
    case '#65735C':
    case '#7BAF5D':
    case '#27946B':
    case '#A0AF57':
    case '#067F67':
      return isDarkShade ? '#65735C' : '#B8D2A9';
    // mint

    case '#98D5CA':
    case '#53746E':
    case '#33AC96':
    case '#55C3AE':
    case '#00B57E':
    case '#5AAE76':
      return isDarkShade ? '#53746E' : '#98D5CA';
    // duck egg

    case '#90BDC1':
    case '#4F6769':
    case '#217C84':
    case '#3FAAB5':
      return isDarkShade ? '#4F6769' : '#90BDC1';
    // orange

    case '#F9BB85':
    case '#886649':
    case '#FE8216':
    case '#F05F20':
    case '#E99849':
    case '#EF824F':
    case '#E04838':
    case '#FF895A':
      return isDarkShade ? '#886649' : '#F9BB85';
    // cyan

    case '#81CDD4':
    case '#467074':
    case '#039BA9':
    case '#737885':
      return isDarkShade ? '#467074' : '#81CDD4';

    default:
      // return cyan for unmapped colors
      return isDarkShade ? '#467074' : '#81CDD4';
  }
}

/*
 * Get the badge state of a conversation
 * @param  {Object} space - a space
 * @param  {boolean} [unread=false] - whether this conversation has unread activities
 * @param  {boolean} [hasMention=false] - whether this conversation has unread mentions
 * @param  {string} [globalNotificationState=NotificationsConstants.NOTIFICATIONS_ALL]
 *          - the value of global notification setting
 * @returns {string} a value that indicates what the badge of this conversation should be.
 */

function getBadgeState({
  space,
  unread = false,
  hasMention = false,
  globalNotificationState = NOTIFICATIONS_ALL
}) {
  let badge = NOTIFICATIONS_BADGE_NONE;

  if (!space) {
    return badge;
  } // One on one spaces


  if (space.type === SPACE_TYPE_ONE_ON_ONE) {
    const isMuted = space.tags && space.tags.includes(MESSAGE_NOTIFICATIONS_OFF);

    if (isMuted) {
      return NOTIFICATIONS_BADGE_MUTE;
    }

    if (unread) {
      return NOTIFICATIONS_BADGE_UNREAD;
    }

    return badge;
  } // Group spaces


  const {
    isMentionNotificationsOn,
    isMentionNotificationsOff,
    isMessageNotificationsOn,
    isMessageNotificationsOff
  } = space;

  if (isMessageNotificationsOff === undefined && isMessageNotificationsOn === undefined || isMentionNotificationsOff === undefined && isMentionNotificationsOn === undefined) {
    // No change to room notifications so default to global
    if (hasMention && globalNotificationState !== NOTIFICATIONS_OFF) {
      badge = NOTIFICATIONS_BADGE_MENTION;
    } else if (unread && globalNotificationState === NOTIFICATIONS_ALL) {
      badge = NOTIFICATIONS_BADGE_UNREAD;
    }

    return badge;
  }

  switch (globalNotificationState) {
    case NOTIFICATIONS_OFF:
      if (!isMessageNotificationsOff && isMentionNotificationsOn) {
        // All
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else if (unread) {
          badge = NOTIFICATIONS_BADGE_UNREAD;
        } else {
          badge = NOTIFICATIONS_BADGE_UNMUTE;
        }
      } else if (isMessageNotificationsOff && isMentionNotificationsOn) {
        // Mention only
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else {
          badge = NOTIFICATIONS_BADGE_UNMUTE;
        }
      } else {
        badge = NOTIFICATIONS_BADGE_NONE;
      }

      break;

    case NOTIFICATIONS_ALL:
      if (!isMessageNotificationsOff) {
        // Global or All
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else if (unread) {
          badge = NOTIFICATIONS_BADGE_UNREAD;
        } else {
          badge = NOTIFICATIONS_BADGE_NONE;
        }
      } else if (isMessageNotificationsOff && isMentionNotificationsOn) {
        // Mention only
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else {
          badge = NOTIFICATIONS_BADGE_MUTE;
        }
      } else {
        // Off
        badge = NOTIFICATIONS_BADGE_MUTE;
      }

      break;

    case NOTIFICATIONS_MENTIONS:
      if (isMessageNotificationsOff === isMentionNotificationsOn) {
        // Global or Mention only
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else {
          badge = NOTIFICATIONS_BADGE_NONE;
        }
      } else if (!isMessageNotificationsOff && isMentionNotificationsOn) {
        // All
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else if (unread) {
          badge = NOTIFICATIONS_BADGE_UNREAD;
        } else {
          badge = NOTIFICATIONS_BADGE_UNMUTE;
        }
      } else if (isMessageNotificationsOff && isMentionNotificationsOn) {
        // Mention only
        if (hasMention) {
          badge = NOTIFICATIONS_BADGE_MENTION;
        } else {
          badge = NOTIFICATIONS_BADGE_NONE;
        }
      } else if (isMessageNotificationsOff && !isMentionNotificationsOn) {
        // Off
        badge = NOTIFICATIONS_BADGE_MUTE;
      }

      break;
  }

  return badge;
}
/*
 * Get Global Notification State
 * @param  {Object} features - map of features
 * @returns {string} a value that indicates the global notification type that is based on global notification features
 */

function getGlobalNotificationState(features) {
  let globalNotificationState = NOTIFICATIONS_OFF;
  const items = features.get('items');

  if (features && items && items.size > 0) {
    const groupMessageNotifications = items.get(FEATURES_GROUP_MESSAGE_NOTIFICATIONS);
    const mentionNotifications = items.get(FEATURES_MENTION_NOTIFICATIONS);

    if (groupMessageNotifications) {
      globalNotificationState = NOTIFICATIONS_ALL;
    } else if (mentionNotifications) {
      globalNotificationState = NOTIFICATIONS_MENTIONS;
    }
  }

  return globalNotificationState;
}

/*
 * Check for mentions
 * @param  {Object} currentUser - current user
 * @param  {Object} space - a space
 * @returns {boolean} a value that indicates whether this space has mentions of targeted user/all or not
 */
function hasMentions(currentUser, space) {
  const {
    latestActivity
  } = space;

  if (latestActivity) {
    const mentions = latestActivity.object && space.latestActivity.object.mentions;
    const {
      id
    } = currentUser; // @User mentions

    const userMentions = mentions && mentions.items && mentions.items.find(item => item.id === id); // @All mentions

    const allMentions = mentions && mentions.items && mentions.items.length === 0;

    if (userMentions || allMentions) {
      return true;
    }
  }

  return false;
}

const iconTypes = {
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'file-spreadsheet',
  'application/vnd.ms-excel': 'file-spreadsheet',
  'application/xls': 'file-spreadsheet',
  'application/excel': 'file-spreadsheet',
  'application/pdf': 'pdf',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'file-graph',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'file-text',
  'application/msword': 'file-text',
  'application/octet-stream': 'document',
  'application/zip': 'file-zip',
  'application/x-zip-compressed': 'file-zip',
  'multipart/x-zip': 'file-zip'
};
/**
 * @param {String} mimeType
 * @param {Integer} size
 * @returns {String}
*/

function getFileIcon(mimeType, size) {
  if (!mimeType) {
    return `document_${size}`;
  }

  if (iconTypes[mimeType]) {
    return `${iconTypes[mimeType]}_${size}`;
  }

  const tokens = mimeType.split('/');

  if (tokens[0] === 'image') {
    return `file-image_${size}`;
  }

  if (tokens[0] === 'video') {
    return `file-video_${size}`;
  }

  if (tokens[0] === 'audio') {
    return `file-audio_${size}`;
  }

  if (tokens[0] === 'text') {
    return `file-text_${size}`;
  }

  return `document_${size}`;
}

const BaseHostConfig = new AdaptiveCard.HostConfig(ADAPTIVE_CARD_HOST_CONFIG);
/* eslint no-param-reassign: 2 */

/**
 * It used to handle markdown
 * esLint is disabled for param-reassign because based on this documentation https://github.com/microsoft/AdaptiveCards/blob/master/source/nodejs/adaptivecards/README.md#supporting-markdown
 * need to modify the result object only
 * @param {string} text
 * @param {object} result
 * @returns {object}
 */

AdaptiveCard.AdaptiveCard.onProcessMarkdown = function processMarkdown(text, result = {}) {
  try {
    const markedString = createMessageObject(text).content;
    result.outputHtml = markedString !== null ? markedString : text;
    result.didProcess = true;
  } catch (err) {
    result.didProcess = false;
  }

  return result;
};
/**
 * It used to call momentum ui compoennts and returns patched adaptive card
 * @param {object} addChildNode
 * @returns {object}
 */


function getPatchedAdaptiveCard(addChildNode = null) {
  AdaptiveCard.GlobalRegistry.elements.register(TEXT_INPUT_ELEMENT, () => new MDTextInput(addChildNode));
  AdaptiveCard.GlobalRegistry.elements.register(TOGGLE_INPUT_ELEMENT, () => new MDToggleInput(addChildNode));
  AdaptiveCard.GlobalRegistry.elements.register(CHOICE_SET_INPUT_ELEMENT, () => new MDChoiceSetInput(addChildNode));
  return AdaptiveCard;
}
/**
 * It will return the json object by taking the input string
 * @param {string} card
 * @param {object} sdkInstance
 * @returns {object}
 */

function getCardConfig(card, sdkInstance) {
  try {
    return JSON.parse(card);
  } catch (err) {
    sdkInstance.logger.error('Failed to parse Adaptive Card', err);
  }

  return null;
}
/**
 * It will return the rendered adaptive card when message contains card
 * else returns display name
 * @param {array} cards
 * @param {string} displayName
 * @param {object} sdkInstance
 * @param {object} addChildNode
 * @param {string} parentActivity
 * @param {object} convo
 * @param {Function} handleSubmitAction
 * @returns {object}
 */

function getAdaptiveCard(cards, displayName, sdkInstance, addChildNode = null, parentActivity, convo, handleSubmitAction) {
  // Parse the card for rendering
  try {
    const cardConfig = getCardConfig(cards[0], sdkInstance);
    const PatchedAdaptiveCard = getPatchedAdaptiveCard(addChildNode);
    const adaptiveCard = new PatchedAdaptiveCard.AdaptiveCard();

    adaptiveCard.onExecuteAction = action => {
      switch (action.getJsonTypeName()) {
        case ADAPTIVE_CARD_OPEN_URL_ACTION:
          window.open(action.url);
          break;

        case ADAPTIVE_CARD_SUBMIT_ACTION:
          {
            // get the rendered element in parent object for select action
            const btnClicked = action.renderedElement ? action.renderedElement : action.parent.renderedElement;
            const actionInput = {
              objectType: 'submit',
              inputs: action.data
            };
            handleSubmitAction(convo.get('url'), actionInput, parentActivity, btnClicked);
          }
          break;

        default:
          sdkInstance.logger.error(`Adaptive card ${action.getJsonTypeName()} is not supported yet`);
      }
    };

    adaptiveCard.parse(cardConfig);
    adaptiveCard.hostConfig = BaseHostConfig;
    return adaptiveCard.render();
  } catch (err) {
    sdkInstance.logger.error('Failed to parse Adaptive Card', err);
  }

  return displayName;
}
/**
 * It will return the boolean value for adaptive card exists or not
 * @param {array} cards
 * @param {object} sdkInstance
 * @returns {boolean}
 */

function hasAdaptiveCard(cards, sdkInstance) {
  if (Array.isArray(cards) && cards.length > 0) {
    const cardConfig = getCardConfig(cards[0], sdkInstance);
    return cardConfig !== null && cardConfig.type === CARD_ATTACHMENT_TYPE;
  }

  return false;
}

function getAdaptiveCardFeatureState(features) {
  let adaptiveCardFeatureState = FEATURES_WIDGET_ADAPTIVE_CARD_OFF;

  if (features !== undefined && features !== null) {
    const items = features.get('items');

    if (features && items && items.size > 0) {
      const adaptiveCardFeatures = items.get(FEATURES_WIDGET_ADAPTIVE_CARD);

      if (adaptiveCardFeatures) {
        adaptiveCardFeatureState = FEATURES_WIDGET_ADAPTIVE_CARD_ON;
      }
    }
  }

  return adaptiveCardFeatureState;
}

function renderCardElement(jsx, container, addChildNode) {
  ReactDOM.render(jsx, container);

  if (addChildNode && typeof addChildNode === 'function') {
    addChildNode(container);
  }
}

const urlTypes = ['url', 'backgroundImage', 'iconUrl'];
/**
 * replaces the index with the uri in cards
 * @param {Object} cardsActivity
 * @param {Array} decryptedURLs
 * @returns {Object}
 */

function replaceIndexWithBlobURL(cardsActivity, decryptedURLs) {
  const activityObject = JSON.parse(JSON.stringify(cardsActivity));

  if (activityObject) {
    // eslint-disable-next-line no-restricted-syntax
    for (const property in activityObject) {
      if (Object.prototype.hasOwnProperty.call(activityObject, property)) {
        const index = urlTypes.indexOf(property);
        const key = urlTypes[index];

        if (urlTypes.includes(property) && property === key && !Number.isNaN(Number(activityObject[key]))) {
          activityObject[key] = decryptedURLs[Number(activityObject[key])];
        } else if (typeof activityObject[property] === 'object') {
          activityObject[property] = replaceIndexWithBlobURL(activityObject[property], decryptedURLs);
        }
      }
    }
  }

  return activityObject;
}

export { ACTIVITY_CARDS, ACTIVITY_OBJECT_CONTENT_CATEGORY_IMAGES, ADAPTIVE_CARD_HOST_CONFIG, ADAPTIVE_CARD_OPEN_URL_ACTION, ADAPTIVE_CARD_SUBMIT_ACTION, API_ACTIVITY_TYPE, API_ACTIVITY_VERB, CARD_ATTACHMENT_TYPE, CARD_CONTAINS_IMAGE, CHOICE_SET_INPUT_ELEMENT, DEFAULT_VALUE_CHECK_BOX, EMAIL_NOTIFICATIONS_DIGEST_EMAILS, EMAIL_NOTIFICATIONS_MENTIONS, EMAIL_NOTIFICATIONS_ONE_TO_ONES, FAILURE, FEATURES_DEVELOPER, FEATURES_GROUP_MESSAGE_NOTIFICATIONS, FEATURES_MENTION_NOTIFICATIONS, FEATURES_USER, FEATURES_WIDGET_ADAPTIVE_CARD, FEATURES_WIDGET_ADAPTIVE_CARD_OFF, FEATURES_WIDGET_ADAPTIVE_CARD_ON, FILE_ATTACHMENT_MAX_SIZE, FILE_TYPES, MENTION_NOTIFICATIONS_OFF, MENTION_NOTIFICATIONS_ON, MESSAGE_NOTIFICATIONS_OFF, MESSAGE_NOTIFICATIONS_ON, NOTIFICATIONS_ALL, NOTIFICATIONS_BADGE_MENTION, NOTIFICATIONS_BADGE_MUTE, NOTIFICATIONS_BADGE_NONE, NOTIFICATIONS_BADGE_UNMUTE, NOTIFICATIONS_BADGE_UNREAD, NOTIFICATIONS_GLOBAL, NOTIFICATIONS_MENTIONS, NOTIFICATIONS_OFF, PENDING, SPACE_TYPE_GROUP, SPACE_TYPE_ONE_ON_ONE, SUCCESS, TAG_MUTED, TEXT_INPUT_ELEMENT, TOGGLE_INPUT_ELEMENT, bufferToBlob, bytesToSize, checkMaxFileSize, constructActivity, constructActivityEventData, constructActivityWithContent, constructFile, constructFiles, constructHydraId, formatDate, getAdaptiveCard, getAdaptiveCardFeatureState, getBadgeState, getCardConfig, getConvoIdFromUrl, getDisplayName, getFileIcon, getFileType, getGlobalNotificationState, getPatchedAdaptiveCard, getTeamColor, hasAdaptiveCard, hasMentions, hydraTypes, isImage, isUuid, renderCardElement, replaceIndexWithBlobURL, sanitize, setWrappedDisplayName, validateAndDecodeId, validateSipUri };
//# sourceMappingURL=index.js.map
