import { last } from 'lodash';
import isEmail from 'validator/lib/isEmail';
import { validateAndDecodeId, PENDING, SUCCESS, FAILURE, API_ACTIVITY_VERB, API_ACTIVITY_TYPE } from '@webex/react-component-utils';
import { OrderedMap, fromJS, Map } from 'immutable';

const ACKNOWLEDGE_ACTIVITY = 'conversation/ACKNOWLEDGE_ACTIVITY';
const ADD_ACTIVITIES_TO_CONVERSATION = 'conversation/ADD_ACTIVITIES_TO_CONVERSATION';
const ADD_PARTICIPANT = 'conversation/ADD_PARTICIPANT';
const ADD_PARTICIPANT_INFLIGHT = 'conversation/ADD_PARTICIPANT_INFLIGHT';
const CREATE_CONVERSATION_BEGIN = 'conversation/CREATE_CONVERSATION_BEGIN';
const CREATE_CONVERSATION = 'conversation/CREATE_CONVERSATION';
const UPDATE_CONVERSATION_STATE = 'conversation/UPDATE_CONVERSATION_STATE';
const DELETE_ACTIVITY_FROM_CONVERSATION = 'conversation/DELETE_ACTIVITY_FROM_CONVERSATION';
const RECEIVE_MERCURY_COMMENT = 'conversation/RECEIVE_MERCURY_COMMENT';
const RECEIVE_MERCURY_ACTIVITY = 'conversation/RECEIVE_MERCURY_ACTIVITY';
const REMOVE_PARTICIPANT = 'conversation/REMOVE_PARTICIPANT';
const REMOVE_PARTICIPANT_INFLIGHT = 'conversation/REMOVE_PARTICIPANT_INFLIGHT';
const RESET_CONVERSATION = 'conversation/RESET_CONVERSATION';
const ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION = 'adaptiveCards/ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION';

function acknowledgeActivity(activity) {
  return {
    type: ACKNOWLEDGE_ACTIVITY,
    payload: {
      activity
    }
  };
}

function addActivitiesToConversation(activities) {
  return {
    type: ADD_ACTIVITIES_TO_CONVERSATION,
    payload: {
      activities
    }
  };
}

function addParticipantInflight(participant) {
  return {
    type: ADD_PARTICIPANT_INFLIGHT,
    payload: {
      participant
    }
  };
}

function deleteActivityFromConversation(conversation, activity) {
  return {
    type: DELETE_ACTIVITY_FROM_CONVERSATION,
    payload: {
      conversation,
      activity
    }
  };
}

function removeParticipantInflight(participant) {
  return {
    type: REMOVE_PARTICIPANT_INFLIGHT,
    payload: {
      participant
    }
  };
}
/**
 * Adds a participant to conversation's participants array
 *
 * @export
 * @param {object} participant
 * @returns {object}
 */


function addParticipant(participant) {
  return {
    type: ADD_PARTICIPANT,
    payload: {
      participant
    }
  };
}
function createConversationBegin() {
  return {
    type: CREATE_CONVERSATION_BEGIN
  };
}
function receiveMercuryComment(activity) {
  return {
    type: RECEIVE_MERCURY_COMMENT,
    payload: {
      activity
    }
  };
}
function receiveMercuryActivity$1(activity) {
  return {
    type: RECEIVE_MERCURY_ACTIVITY,
    payload: {
      activity
    }
  };
}
/**
 * Removes a participant from the participants array
 *
 * @export
 * @param {object} participant
 * @returns {object}
 */

function removeParticipant(participant) {
  return {
    type: REMOVE_PARTICIPANT,
    payload: {
      participant
    }
  };
}
/**
 * Resets the conversation store to default
 *
 * @export
 * @returns {object}
 */

function resetConversation() {
  return {
    type: RESET_CONVERSATION
  };
}
function storeConversation(conversation) {
  return {
    type: CREATE_CONVERSATION,
    payload: {
      conversation
    }
  };
}
function updateConversationState(conversationState) {
  return {
    type: UPDATE_CONVERSATION_STATE,
    payload: {
      conversationState
    }
  };
}
/**
 * Computes and updates room properties
 * @param {Object} conversation
 * @param {Object} sparkInstance
 * @returns {Object}
 */

function computeRoomProperties(conversation, sparkInstance) {
  const computedConversation = Object.assign({}, conversation);
  const lockedTag = 'LOCKED';
  const oneOnOneTag = 'ONE_ON_ONE';
  const isLocked = conversation.tags.some(tag => tag === lockedTag);
  const isOneOnOne = conversation.tags.some(tag => tag === oneOnOneTag);
  const currentUserId = sparkInstance.internal.device.userId;
  const currentUserParticipant = conversation.participants.items.find(participant => participant.id === currentUserId);
  const isModerator = currentUserParticipant && currentUserParticipant.roomProperties && currentUserParticipant.roomProperties.isModerator;

  if (isOneOnOne && !conversation.displayName) {
    const otherUser = conversation.participants.items.find(p => p.id !== currentUserId);

    if (otherUser) {
      computedConversation.displayName = otherUser.displayName;
    }
  }

  computedConversation.status = Object.assign({}, conversation.status, {
    isLocked,
    isModerator,
    isOneOnOne
  });
  return computedConversation;
}
/**
 * Acknowledges (marks as read) an activity
 * @param {object} conversation (immutable object expected)
 * @param {object} activity
 * @param {object} spark
 * @returns {function}
 */

function acknowledgeActivityOnServer(conversation, activity, spark) {
  return dispatch => spark.internal.conversation.acknowledge(conversation.toJS(), activity).then(() => dispatch(acknowledgeActivity(activity)));
}
/**
 * Creates/Opens a conversation with a user
 *
 * @param {Array} participants List of userIds or emails
 * @param {object} spark
 * @returns {function}
 */

function createConversation(participants = [], spark) {
  return dispatch => {
    dispatch(createConversationBegin());
    const mappedParticipants = participants.map(p => {
      if (isEmail(p)) {
        return p;
      }

      const {
        id: uuid
      } = validateAndDecodeId(p);

      if (uuid) {
        return uuid;
      }

      return p;
    });
    return spark.internal.conversation.create({
      participants: mappedParticipants
    }, {
      latestActivity: true,
      activitiesLimit: 40,
      participantAckFilter: 'all'
    }).then(conversation => dispatch(storeConversation(computeRoomProperties(conversation, spark)))).catch(error => dispatch(updateConversationState({
      error: error.message
    })));
  };
}
/**
 * Deletes an activity from a conversation
 * @param {object} conversation (immutable object expected)
 * @param {object} activity
 * @param {object} spark
 * @returns {function}
 */

function deleteActivity(conversation, activity, spark) {
  return dispatch => spark.internal.conversation.delete(conversation.toJS(), activity).then(() => dispatch(deleteActivityFromConversation(conversation, activity)));
}
/**
 * Retrieves a conversation with SpaceId
 *
 * @param {string} id SpaceId
 * @param {object} spark
 * @returns {Promise}
 */

function getConversation(id, spark) {
  const room = validateAndDecodeId(id);
  return dispatch => {
    dispatch(createConversationBegin());

    if (room.id) {
      return spark.internal.conversation.get(room, {
        latestActivity: true,
        activitiesLimit: 40,
        participantAckFilter: 'all',
        includeParticipants: true
      }).then(conversation => dispatch(storeConversation(computeRoomProperties(conversation, spark)))).catch(error => dispatch(updateConversationState({
        error: error.message
      })));
    }

    return false;
  };
}
/**
 * Fetches activities that were posted after sinceDate
 * @param {string} conversationUrl
 * @param {string} sinceDate
 * @param {object} spark
 * @returns {function}
 */

function loadMissingActivities(conversationUrl, sinceDate, spark) {
  function fetchAndMergeMissingActivities(fetchConversationUrl, fetchSinceDate) {
    return dispatch => {
      const limit = 50;
      return spark.internal.conversation.listActivities({
        lastActivityFirst: false,
        conversationUrl: fetchConversationUrl,
        limit,
        fetchSinceDate
      }).then(activities => {
        if (activities.length) {
          dispatch(addActivitiesToConversation(activities));

          if (activities.length === limit) {
            // We still have (possibly) more activities missing
            const lastActivityDate = last(activities).published;
            return fetchAndMergeMissingActivities(fetchConversationUrl, lastActivityDate);
          }
        }

        return Promise.resolve();
      });
    };
  }

  return dispatch => {
    dispatch(updateConversationState({
      isLoadingMissing: true
    }));
    return dispatch(fetchAndMergeMissingActivities(conversationUrl, sinceDate)).then(() => dispatch(updateConversationState({
      isLoadingMissing: false
    })));
  };
}
/**
 * Loads activities for a conversation previous to the maxDate
 *
 * @export
 * @param {string} conversationUrl
 * @param {string} maxDate
 * @param {object} spark
 * @returns {function}
 */

function loadPreviousMessages(conversationUrl, maxDate, spark) {
  return dispatch => {
    dispatch(updateConversationState({
      isLoadingHistoryUp: true
    }));
    return spark.internal.conversation.listActivities({
      conversationUrl,
      lastActivityFirst: true,
      limit: 20,
      maxDate: Date.parse(maxDate) || Date.now()
    }).then(activities => {
      dispatch(addActivitiesToConversation(activities));
      dispatch(updateConversationState({
        isLoadingHistoryUp: false
      }));
    }).catch(error => dispatch(updateConversationState({
      error: error.message
    })));
  };
}
/**
 * Adds participant to the conversation on the server
 *
 * @export
 * @param {object} conversation (immutable object expected)
 * @param {object|string} participant the full participant object (js-sdk required)
 *                                    if string, must be an email address
 * @param {object} spark
 * @returns {function}
 */

function addParticipantToConversation(conversation, participant, spark) {
  return dispatch => {
    let participantObject = participant;

    if (typeof participant === 'string') {
      if (isEmail(participant)) {
        participantObject = {
          id: participant,
          displayName: participant,
          name: participant,
          emailAddress: participant
        };
      } else {
        const error = new Error('An email is required for string values of \'participant\' parameter.');
        dispatch(updateConversationState({
          addParticipantError: error
        }));
        return Promise.resolve();
      }
    }

    dispatch(addParticipantInflight(participantObject));
    return spark.internal.conversation.add(conversation.toJS(), participantObject).then(() => // Add will come as mercury event
    dispatch(updateConversationState({
      addParticipantError: null
    }))).catch(error => dispatch(updateConversationState({
      addParticipantError: error
    })));
  };
}
/**
 * Removes a participant from the conversation on the server
 *
 * @export
 * @param {object} conversation
 * @param {object} participant
 * @param {object} spark
 * @returns {function}
 */

function removeParticipantFromConversation(conversation, participant, spark) {
  return dispatch => {
    dispatch(removeParticipantInflight(participant));
    return spark.internal.conversation.leave(conversation.toJS(), participant).then(() => // Remove will come as mercury event
    dispatch(updateConversationState({
      removeParticipantError: null
    }))).catch(error => dispatch(updateConversationState({
      removeParticipantError: error
    })));
  };
}
/**
 * submits the adaptive card action
 *
 * @export
 * @param {string} url conversation end point to post data
 * @param {object} actionInput contians type of object and input data
 * @param {string} parentId id of the parent activity
 * @param {object} spark object used to call the funcion of conversation
 * @param {HTMLElement} btnClicked disable the clicked button
 * @returns {function}
 */

function handleAdaptiveCardSubmitAction(url, actionInput, parentId, spark, btnClicked) {
  return dispatch => {
    dispatch({
      type: ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION,
      status: PENDING
    });
    /* this button is from adaptive cards library we get only when an action happens and
     we don't have a reference to it in React */
    // eslint-disable-next-line no-param-reassign

    btnClicked.disabled = true;
    return spark.internal.conversation.cardAction({
      url
    }, actionInput, {
      id: parentId
    }).then(() => {
      setTimeout(() => {
        // eslint-disable-next-line no-param-reassign
        btnClicked.disabled = false;
      }, 2000);
      dispatch({
        type: ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION,
        status: SUCCESS
      });
    }).catch(() => {
      setTimeout(() => {
        // eslint-disable-next-line no-param-reassign
        btnClicked.disabled = false;
      }, 2000);
      dispatch({
        type: ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION,
        status: FAILURE
      });
    });
  };
}

/**
 * @typedef {Object} Activity
 * @typedef {String} ParentId
 */

/**
 * @param {Object.<ParentId, Activity[]>} threadActivities
 *   a map of parent activity IDs to a collection of reply activities
 * @param {Activity[]} sortNonThreadActivities collection of non-reply activities
 * @returns {Activity[]} combined collection of activities
 */
// eslint-disable-next-line import/prefer-default-export

const getActivitiesFromThreadAndNonThreadCollections = (threadActivities = {}, sortNonThreadActivities = []) => {
  const finalList = [];
  let start = 0;

  for (let i = 0; i < sortNonThreadActivities.length; i += 1) {
    if (threadActivities[sortNonThreadActivities[i].id]) {
      // The current activity is a parent activity
      // Grab the replies and insert them after the parent.
      // This grabs all of the activities prior to the current activity
      // that were not parent activities.
      finalList.push(...sortNonThreadActivities.slice(start, i + 1)); // This grabs all of the replies to the current parent activity

      finalList.push(...threadActivities[sortNonThreadActivities[i].id]); // Set start to the next activity

      start = i + 1;
    }
  }

  finalList.push(...sortNonThreadActivities.slice(start));
  return new OrderedMap(finalList.map(activity => [activity.url, activity]));
};

/**
 * Parses the giphy file object and set the url correctly
 * @param {Object} fileObject
 * @returns {Object}
 */

function convertGiphyFileObject(fileObject) {
  const normalizedFileObject = Object.assign({}, fileObject);
  normalizedFileObject.image.displayName = fileObject.displayName;
  normalizedFileObject.url = fileObject.scr.loc; // Set scr to null so we don't try to decrypt content in the sdk

  normalizedFileObject.scr = null;
  return normalizedFileObject;
}
/**
 * Normalizes an activity received from the conversation service
 * @param {Object} a
 * @returns {Object}
 */


function normalizeActivity(a) {
  const activity = Object.assign({}, a);

  if (activity.verb === 'share' && activity.object && activity.object.files && Array.isArray(activity.object.files.items)) {
    // Apply giphy fix to file url
    activity.object.files.items = activity.object.files.items.map(fileObject => {
      if (fileObject.url.includes('giphy')) {
        return convertGiphyFileObject(fileObject);
      }

      return fileObject;
    });
  }

  return activity;
}
/**
 * Normalizes an array of activities received from the conversation service
 * @param {Array} activities
 * @returns {Array}
 */

function normalizeActivities(activities) {
  return activities.map(normalizeActivity);
}
/**
 * Filters a raw list of activities for those we are interested in
 *
 * @param {array} activities
 * @returns {array}
 */

function filterActivities(activities) {
  return activities.filter(a => {
    const isUpdate = a.verb === API_ACTIVITY_VERB.UPDATE;
    const isContent = a.object && a.object.objectType === 'content';
    const isReply = a.type === API_ACTIVITY_TYPE.REPLY;
    let shouldInclude = true; // Content updates show up out of order and should not be displayed

    if (isUpdate && isContent) {
      shouldInclude = false;
    } // Threaded replies are not currently supported


    if (isReply) {
      shouldInclude = false;
    }

    return shouldInclude;
  });
}

/* eslint complexity: ["error", 14] */
const initialState = fromJS({
  sortNonThreadActivities: [],
  threadActivities: {},
  id: null,
  inFlightParticipants: {
    adding: new Map(),
    removing: new Map()
  },
  lastAcknowledgedActivityId: null,
  participants: [],
  cardActionAcknowledgedState: '',
  status: {
    addParticipantError: null,
    isFetching: false,
    isListeningToMercury: false,
    isLoaded: false,
    isLoadingHistoryUp: false,
    isLoadingMissing: false,
    isLocked: true,
    isModerator: false,
    isOneOnOne: null,
    error: null,
    removeParticipantError: null
  }
});

const markDeletedActivity = ({
  activity: {
    object: {
      id
    }
  },
  activities
}) => activities.map(activityItem => {
  if (activityItem.id === id) {
    return Object.assign({}, activityItem, {
      verb: 'tombstone'
    });
  }

  return activityItem;
});

function receiveMercuryActivity(state, {
  payload: {
    activity
  }
}) {
  switch (activity.verb) {
    case 'delete':
      {
        // Find activity that is being deleted and change it to a tombstone
        const sortNonThreadActivities = markDeletedActivity({
          activity,
          activities: state.get('sortNonThreadActivities')
        });
        const threadActivities = {};

        for (const [threadId, threads] of Object.entries(state.get('threadActivities'))) {
          threadActivities[threadId] = markDeletedActivity({
            activity,
            activities: threads
          });
        }

        return state.set('sortNonThreadActivities', sortNonThreadActivities).set('threadActivities', threadActivities);
      }

    case 'acknowledge':
      {
        // acknowledge is a read receipt. we need to update the participants who
        // are listed in this acknowledgement
        const participants = state.get('participants');
        const actorId = activity.actor.id;
        return state.set('participants', participants.map(participant => {
          if (participant.get('id') === actorId) {
            return participant.setIn(['roomProperties', 'lastSeenActivityUUID'], activity.object.id).setIn(['roomProperties', 'lastSeenActivityDate'], activity.published);
          }

          return participant;
        }));
      }

    default:
      return state;
  }
}

const compareActivities = (first, second) => Date.parse(first.published) - Date.parse(second.published);

const findOldestPublishedDate = ({
  activity,
  published
}) => compareActivities({
  published
}, activity) < 0 ? published : activity.published;

const processActivities = ({
  activities,
  threadActivities = {},
  nonThreadActivities = [],
  oldestPublishedDate
}) => {
  let ta = threadActivities;
  let nta = nonThreadActivities;
  const dirtyThreadList = new Set();
  let needSort = false;
  let published = oldestPublishedDate;

  for (const activity of activities) {
    var _activity$parent;

    published = findOldestPublishedDate({
      activity,
      published
    }); // Split the activities into the correct buckets

    const parentId = (_activity$parent = activity.parent) === null || _activity$parent === void 0 ? void 0 : _activity$parent.id;

    if (parentId) {
      var _ta$parentId;

      dirtyThreadList.add(parentId);
      const threads = (_ta$parentId = ta[parentId]) !== null && _ta$parentId !== void 0 ? _ta$parentId : [];
      ta = { ...ta
      };
      ta[parentId] = [...threads, activity];
    } else {
      needSort = true;
      nta = [...nta, activity];
    }
  }

  for (const threadParent of dirtyThreadList) {
    ta[threadParent] = ta[threadParent].sort(compareActivities);
  }

  return {
    threadActivities: ta,
    sortNonThreadActivities: needSort ? nta.sort(compareActivities) : nta,
    oldestPublishedDate: published
  };
};

const processCreateConversation = ({
  action,
  state
}) => {
  const {
    defaultActivityEncryptionKeyUrl,
    avatar,
    displayName,
    id,
    kmsResourceObjectUrl,
    locusUrl,
    participants,
    tags,
    published,
    url,
    lastReadableActivityDate,
    teams,
    status
  } = action.payload.conversation;
  const rawActivities = action.payload.conversation.activities.items;
  const conversationActivities = normalizeActivities(filterActivities(rawActivities));
  const {
    threadActivities,
    sortNonThreadActivities,
    oldestPublishedDate
  } = processActivities({
    activities: conversationActivities,
    oldestPublishedDate: state.get('oldestPublishedDate')
  });
  return state.set('threadActivities', threadActivities).set('sortNonThreadActivities', sortNonThreadActivities).set('oldestPublishedDate', oldestPublishedDate).mergeDeep({
    avatar,
    displayName,
    defaultActivityEncryptionKeyUrl,
    id,
    kmsResourceObjectUrl,
    locusUrl,
    url,
    published,
    tags,
    lastReadableActivityDate,
    teams,
    status: Object.assign({}, status, {
      error: null,
      isFetching: false,
      isLoaded: true
    }),
    participants: participants.items
  });
};

const addActivities = ({
  state,
  addedActivities
}) => {
  const opd = state.get('oldestPublishedDate');
  const {
    threadActivities,
    sortNonThreadActivities,
    oldestPublishedDate
  } = processActivities({
    threadActivities: state.get('threadActivities'),
    nonThreadActivities: state.get('sortNonThreadActivities'),
    activities: addedActivities,
    oldestPublishedDate: opd
  });
  return state.set('threadActivities', threadActivities).set('sortNonThreadActivities', sortNonThreadActivities).set('oldestPublishedDate', oldestPublishedDate);
};

function reducer(state = initialState, action) {
  switch (action.type) {
    case ACKNOWLEDGE_ACTIVITY:
      {
        return state.set('lastAcknowledgedActivityId', action.payload.activity.id);
      }

    case ADD_ACTIVITIES_TO_CONVERSATION:
      {
        const addedActivities = normalizeActivities(filterActivities(action.payload.activities));
        return addActivities({
          state,
          addedActivities
        });
      }

    case ADD_PARTICIPANT:
      {
        const participants = state.get('participants').push(fromJS(action.payload.participant));
        return state.set('participants', participants).removeIn(['inFlightParticipants', 'adding', action.payload.participant.id]) // In flight participants could be sideboarded and not have an id
        .removeIn(['inFlightParticipants', 'adding', action.payload.participant.emailAddress]);
      }

    case ADD_PARTICIPANT_INFLIGHT:
      {
        const {
          participant
        } = action.payload;
        return state.setIn(['inFlightParticipants', 'adding', participant.id], participant);
      }

    case CREATE_CONVERSATION_BEGIN:
      {
        return state.setIn(['status', 'isFetching'], true);
      }

    case CREATE_CONVERSATION:
      {
        return processCreateConversation({
          action,
          state
        });
      }

    case RECEIVE_MERCURY_ACTIVITY:
      {
        return receiveMercuryActivity(state, action);
      }

    case RECEIVE_MERCURY_COMMENT:
      {
        const receivedActivity = normalizeActivity(action.payload.activity);
        return addActivities({
          state,
          addedActivities: [receivedActivity]
        });
      }

    case REMOVE_PARTICIPANT:
      {
        const participants = [];
        state.get('participants').forEach(p => {
          if (p.get('id') !== action.payload.participant.id) {
            participants.push(p);
          }
        });
        return state.set('participants', fromJS(participants)).removeIn(['inFlightParticipants', 'removing', action.payload.participant.id]);
      }

    case REMOVE_PARTICIPANT_INFLIGHT:
      {
        const {
          participant
        } = action.payload;
        return state.setIn(['inFlightParticipants', 'removing', participant.id], participant);
      }

    case RESET_CONVERSATION:
      {
        return initialState;
      }

    case UPDATE_CONVERSATION_STATE:
      {
        return state.mergeIn(['status'], action.payload.conversationState);
      }

    case ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION:
      {
        return state.set('cardActionAcknowledgedState', action.status);
      }

    default:
      {
        return state;
      }
  }
}

export default reducer;
export { ACKNOWLEDGE_ACTIVITY, ACKNOWLEDGE_ADAPTIVE_CARD_SUBMIT_ACTION, ADD_ACTIVITIES_TO_CONVERSATION, ADD_PARTICIPANT, ADD_PARTICIPANT_INFLIGHT, CREATE_CONVERSATION, CREATE_CONVERSATION_BEGIN, DELETE_ACTIVITY_FROM_CONVERSATION, RECEIVE_MERCURY_ACTIVITY, RECEIVE_MERCURY_COMMENT, REMOVE_PARTICIPANT, REMOVE_PARTICIPANT_INFLIGHT, RESET_CONVERSATION, UPDATE_CONVERSATION_STATE, acknowledgeActivityOnServer, addParticipant, addParticipantToConversation, computeRoomProperties, createConversation, createConversationBegin, deleteActivity, getActivitiesFromThreadAndNonThreadCollections, getConversation, handleAdaptiveCardSubmitAction, initialState, loadMissingActivities, loadPreviousMessages, receiveMercuryActivity$1 as receiveMercuryActivity, receiveMercuryComment, removeParticipant, removeParticipantFromConversation, resetConversation, storeConversation, updateConversationState };
//# sourceMappingURL=index.js.map
