import { compose, lifecycle, branch, renderComponent, withHandlers, setDisplayName } from 'recompose';
import { constructWebexEnhancer, withIntl } from '@webex/webex-widget-base';
import mercury, { enhancer as enhancer$1 } from '@webex/redux-module-mercury';
import media, { acceptIncomingCall, declineIncomingCall, placeCall, hangupCall, enhancer } from '@webex/redux-module-media';
import { combineReducers, bindActionCreators } from 'redux';
import { Record } from 'immutable';
import Notifications, { reducer as reducer$1, createNotification } from '@webex/react-container-notifications';
import avatar, { fetchAvatar } from '@webex/redux-module-avatar';
import spaces, { fetchSpace } from '@webex/redux-module-spaces';
import activities from '@webex/redux-module-activities';
import React, { Component } from 'react';
import PropTypes, { shape, func } from 'prop-types';
import { connect } from 'react-redux';
import classNames from 'classnames';
import Ringtone, { RINGTONE_TYPE_INCOMING, RINGTONE_TYPE_RINGBACK } from '@webex/react-component-ringtone';
import LoadingScreen from '@webex/react-component-loading-screen';
import IncomingCall from '@webex/react-component-incoming-call';
import '@webex/components/dist/css/webex-components.css';
import PresenceAvatar from '@webex/react-container-presence-avatar';
import ButtonControls from '@webex/react-component-button-controls';
import { WebexDataProvider, WebexMeetingControls, WebexMeetingControl, WebexInMeeting } from '@webex/components';
import { defineMessages } from 'react-intl';
import { createSelector } from 'reselect';
import { validateAndDecodeId, constructHydraId, hydraTypes, deconstructHydraId } from '@webex/react-component-utils';
import { addError, removeError } from '@webex/redux-module-errors';
import { getUser } from '@webex/redux-module-users';

const UPDATE_LOCAL_VIDEO_POSITION = 'widget-meet/UPDATE_LOCAL_VIDEO_POSITION';
const UPDATE_WIDGET_STATUS = 'widget-meet/UPDATE_WIDGET_STATUS';
const STORE_MEET_DETAILS = 'widget-meet/STORE_MEET_DETAILS';
function updateWidgetStatus(status) {
  return {
    type: UPDATE_WIDGET_STATUS,
    payload: {
      status
    }
  };
}
function storeMeetDetails(details) {
  return {
    type: STORE_MEET_DETAILS,
    payload: details
  };
}

const Status = Record({
  hasOpenWithCall: false,
  hasInitiatedCall: false // local user has clicked call button

});
const VideoPosition = Record({
  x: 0,
  y: 0
});
/**
 * Note: We are storing the call object because services can take a long time to
 * return with a full locus object. If the call object exists in this store, it
 * will be used as a fallback if no others exist in the media store.
 */

const InitialState = Record({
  toType: '',
  // valid types: userId, spaceId, email, sip, pstn
  toValue: '',
  // sip address, uuid, email, phone number
  callId: '',
  // id of call object in media store.
  spaceId: '',
  userId: '',
  localVideoPosition: new VideoPosition(),
  status: new Status()
});
const initialState = new InitialState();
function reducer(state = initialState, action) {
  switch (action.type) {
    case STORE_MEET_DETAILS:
      return state.merge(action.payload);

    case UPDATE_LOCAL_VIDEO_POSITION:
      return state.set('localVideoPosition', action.payload.position);

    case UPDATE_WIDGET_STATUS:
      return state.mergeIn(['status'], action.payload.status);

    default:
      return state;
  }
}
const reducers = {
  media,
  avatar,
  activities,
  mercury,
  notifications: reducer$1,
  spaces,
  widgetMeet: reducer
};
combineReducers(reducers);

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = ".widget-meet__callInactiveContainer__LmNhbGxJ {\n  position: relative;\n  display: flex;\n  width: 100%;\n  margin: auto;\n  text-align: center;\n  flex: 1 1 auto;\n  align-items: center;\n  flex-direction: column;\n}\n\n.widget-meet__personName__LmNhbGxJ {\n  width: 100%;\n  margin: 10px;\n  overflow: hidden;\n  font-size: 32px;\n  color: #707071;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.widget-meet__callControls__LmNhbGxJ {\n  z-index: 100;\n  text-align: center;\n}\n\n.widget-meet__callControls__LmNhbGxJ .widget-meet__callButton__LmNhbGxJ {\n  background-color: #30d557;\n}\n\n.widget-meet__callControls__LmNhbGxJ .widget-meet__callButton__LmNhbGxJ:hover {\n  background-color: #2ac44f;\n}\n";
var styles$2 = {"callInactiveContainer":"widget-meet__callInactiveContainer__LmNhbGxJ","personName":"widget-meet__personName__LmNhbGxJ","callControls":"widget-meet__callControls__LmNhbGxJ","callButton":"widget-meet__callButton__LmNhbGxJ"};
styleInject(css_248z$2);

const propTypes = {
  avatarId: PropTypes.string,
  avatarImage: PropTypes.string,
  callButtonAriaLabel: PropTypes.string,
  callButtonLabel: PropTypes.string,
  displayName: PropTypes.string,
  onCallClick: PropTypes.func
};
const defaultProps = {
  avatarId: '',
  avatarImage: '',
  callButtonAriaLabel: 'Start Call',
  callButtonLabel: 'Call',
  displayName: 'Unknown',
  onCallClick: () => {}
};

function InactiveCall({
  avatarId,
  avatarImage,
  onCallClick,
  callButtonAriaLabel,
  callButtonLabel,
  displayName
}) {
  const buttons = [{
    label: callButtonLabel,
    accessibilityLabel: callButtonAriaLabel,
    buttonClassName: styles$2.callButton,
    buttonType: 'camera',
    onClick: onCallClick
  }];
  return /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$2.callInactiveContainer, 'call-inactive-container')
  }, /*#__PURE__*/React.createElement(PresenceAvatar, {
    avatarId: avatarId,
    image: avatarImage,
    name: displayName,
    size: 84
  }), /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$2.personName, 'call-person-name')
  }, displayName), /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$2.callControls, 'call-controls-container')
  }, /*#__PURE__*/React.createElement(ButtonControls, {
    buttons: buttons,
    showLabels: true
  })));
}

InactiveCall.propTypes = propTypes;
InactiveCall.defaultProps = defaultProps;

var css_248z$1 = ".widget-meet__callContainer__LmNhbGxD {\n  position: relative;\n  display: flex;\n  width: 100%;\n  height: inherit;\n  justify-content: center;\n  align-items: center;\n}\n\n.widget-meet__callContainer__LmNhbGxD:hover .widget-meet__callControls__LmNhbGxD {\n  visibility: visible;\n}\n\n.widget-meet__callControls__LmNhbGxD {\n  visibility: hidden;\n  position: absolute;\n  bottom: 2rem;\n  z-index: 100;\n}\n";
var styles$1 = {"callContainer":"widget-meet__callContainer__LmNhbGxD","callControls":"widget-meet__callControls__LmNhbGxD"};
styleInject(css_248z$1);

const ActiveMeeting = ({
  adapter,
  meetingId
}) => /*#__PURE__*/React.createElement(WebexDataProvider, {
  adapter: adapter
}, /*#__PURE__*/React.createElement("div", {
  className: classNames(styles$1.callContainer, 'call-container')
}, /*#__PURE__*/React.createElement(WebexMeetingControls, {
  className: styles$1.callControls,
  meetingID: meetingId
}, /*#__PURE__*/React.createElement(WebexMeetingControl, {
  type: "mute-audio"
}), /*#__PURE__*/React.createElement(WebexMeetingControl, {
  type: "mute-video"
}), /*#__PURE__*/React.createElement(WebexMeetingControl, {
  type: "leave-meeting"
})), /*#__PURE__*/React.createElement(WebexInMeeting, {
  meetingID: meetingId
})));

ActiveMeeting.propTypes = {
  adapter: PropTypes.object.isRequired,
  meetingId: PropTypes.string.isRequired
};

/*
 * WidgetMeet Messages
 *
 * This contains all the text for the FeaturePage component.
 */
var messages$1 = defineMessages({
  answerButtonLabel: {
    id: 'ciscospark.container.meet.button.answer',
    defaultMessage: 'Answer'
  },
  callButtonAriaLabel: {
    id: 'ciscospark.container.meet.button.aria.call',
    defaultMessage: 'Start Call'
  },
  callButtonLabel: {
    id: 'ciscospark.container.meet.button.call',
    defaultMessage: 'Call'
  },
  declineButtonLabel: {
    id: 'ciscospark.container.meet.button.decline',
    defaultMessage: 'Decline'
  },
  hangupButtonLabel: {
    id: 'ciscospark.container.meet.button.hangup',
    defaultMessage: 'Hangup'
  },
  okButtonLabel: {
    id: 'ciscospark.container.meet.button.ok',
    defaultMessage: 'Ok'
  },
  callErrorDeviceNotFound: {
    id: 'ciscospark.container.meet.message.deviceNotFound',
    defaultMessage: 'Webex cannot find your camera. Please check your browser settings, and that your camera is accessible, and try again.'
  },
  callErrorNotAllowed: {
    id: 'ciscospark.container.meet.message.errorNotAllowed',
    defaultMessage: 'Webex cannot access your camera. Please check your browser settings and try again.'
  },
  callErrorSecurity: {
    id: 'ciscospark.container.meet.message.errorSecurity',
    defaultMessage: 'Video Calling is supported on secure (HTTPS) sites only.'
  },
  callErrorUnknownMessage: {
    id: 'ciscospark.container.meet.message.errorUnknown',
    defaultMessage: 'Webex cannot connect your call. Please try again.'
  },
  callErrorBadToPropTitle: {
    id: 'ciscospark.container.meet.message.errorBadToPropTitle',
    defaultMessage: 'Invalid or missing details'
  },
  callErrorBadToPropMessage: {
    id: 'ciscospark.container.meet.message.errorBadToPropMessage',
    defaultMessage: 'Please provide a valid email address, user ID, SIP uri, space ID, or call object'
  },
  callPersonPrefix: {
    id: 'ciscospark.container.meet.message.callPerson',
    defaultMessage: 'Call'
  },
  incomingCallMessage: {
    id: 'ciscospark.container.meet.message.incomingCall',
    defaultMessage: 'Incoming call'
  },
  noWebRTCBrowserSupportMessage: {
    id: 'ciscospark.container.meet.message.noWebRTCBrowserSupport',
    defaultMessage: 'Video calling is not yet supported in your browser.'
  },
  useSupportedBrowserMessage: {
    id: 'ciscospark.container.meet.message.useSupportedBrowser',
    defaultMessage: 'For the best experience, use the latest version of Chrome or Firefox.'
  }
});

var css_248z = ".widget-meet__meetWidgetContainer__Lm1lZXRX {\n  position: relative;\n  display: flex;\n  width: 100%;\n  flex: 1 1 auto;\n  justify-content: center;\n}\n\n.widget-meet__noWebRtc__Lm1lZXRX {\n  top: 0;\n  bottom: 0;\n  padding: 0 40px;\n  text-align: center;\n  flex-direction: column;\n  align-items: center;\n}\n\n.widget-meet__noWebRtcMessage__Lm1lZXRX {\n  padding-top: 10px;\n  font-size: 22px;\n}\n";
var styles = {"meetWidgetContainer":"widget-meet__meetWidgetContainer__Lm1lZXRX","noWebRtc":"widget-meet__noWebRtc__Lm1lZXRX","noWebRtcMessage":"widget-meet__noWebRtcMessage__Lm1lZXRX"};
styleInject(css_248z);

const getSDKAdapter = state => state.spark.get('adaptor');

const getWidget = state => state.widgetMeet;

const getCalls = state => state.media.byId;

const getAvatars = state => state.avatar;

const getUsers = state => state.users;

const getSpaces = state => state.spaces;

const getErrors = state => state.errors;

const getOwnProps = (state, ownProps) => ownProps;

const getCall = createSelector([getOwnProps, getCalls], (ownProps, calls) => {
  var _ownProps$call;

  let call;

  if (ownProps.call && (_ownProps$call = ownProps.call) !== null && _ownProps$call !== void 0 && _ownProps$call.instance) {
    if (calls.has(ownProps.call.id)) {
      call = calls.get(ownProps.call.id);
    } else {
      ({
        call
      } = ownProps);
    }
  } // Patching in activeParticipantsCount with devices to support sip should be migrated to sdk


  if (call && call.instance && call.instance.locus && call.instance.locus.participants) {
    const count = call.instance.locus.participants.reduce((acc, p) => acc + (p.state === 'JOINED' && p.type !== 'MEETING_BRIDGE' ? 1 : 0), 0);
    call = call.set('activeParticipantsCount', count);
  }

  return call;
});
const getMeeting = createSelector([getWidget, getSDKAdapter], // eslint-disable-next-line arrow-body-style
(widget, sdkAdapter) => {
  return widget.callId ? sdkAdapter.meetingsAdapter.datasource.meetings.getMeetingByType('id', widget.callId) : null;
});
const getAvatarImage = createSelector([getOwnProps, getAvatars, getWidget, getUsers], (ownProps, avatars, widget, users) => {
  const {
    toValue,
    toType
  } = widget;
  let avatarId;

  if (toType === destinationTypes.EMAIL) {
    avatarId = users.getIn(['byEmail', toValue]);
  } else if ([destinationTypes.EMAIL, destinationTypes.USERID, destinationTypes.SPACEID].includes(toType)) {
    avatarId = toValue;
  }

  return avatars.getIn(['items', avatarId]);
});
const getDisplayName = createSelector([getOwnProps, getWidget, getUsers, getSpaces], (ownProps, widget, users, spaces) => {
  const {
    toValue,
    toType
  } = widget;

  switch (toType) {
    case destinationTypes.SIP:
    case destinationTypes.PSTN:
      return toValue;

    case destinationTypes.EMAIL:
      {
        const userId = users.getIn(['byEmail', toValue]);
        return users.getIn(['byId', userId, 'displayName']);
      }

    case destinationTypes.USERID:
      return users.getIn(['byId', toValue, 'displayName']);

    case destinationTypes.SPACEID:
      if (ownProps.spaceDetails.type === 'direct') {
        return ownProps.spaceDetails.title;
      }

      return spaces.getIn(['byId', validateAndDecodeId(toValue).id, 'displayName']);

    default:
      return '';
  }
});
const getMeetWidgetError = createSelector([getErrors], errors => errors.get('errors').first());

const isInState = (states = []) => call => states.find(state => {
  var _call$instance;

  return (call === null || call === void 0 ? void 0 : (_call$instance = call.instance) === null || _call$instance === void 0 ? void 0 : _call$instance.state) === state;
});

const isOut = isInState(['DECLINED', 'LEFT']);
const isAnswered = isInState(['JOINED']);
const getMeetWidgetProps = createSelector([getAvatarImage, getWidget, getCall, getDisplayName, getMeetWidgetError, getSDKAdapter, getMeeting], (avatarImage, widgetMeet, call, displayName, error, sdkAdapter, meeting) => {
  const props = {
    avatarImage,
    displayName,
    call,
    widgetMeet,
    error,
    localVideoPosition: widgetMeet.localVideoPosition,
    hasVideo: widgetMeet.toType !== destinationTypes.PSTN,
    sdkAdapter,
    meeting
  };
  let callProps;

  if (call) {
    // Is the call active?
    const {
      direction,
      isConnected,
      hasJoinedOnThisDevice,
      isRinging,
      localMediaStream,
      isCall,
      isSendingVideo
    } = call;
    const validCall = !!call.instance.state;
    callProps = {
      isRinging,
      isCall,
      callInstance: call.instance,
      isActive: isConnected && hasJoinedOnThisDevice || direction === 'out',
      isIncoming: validCall && direction === 'in' && !hasJoinedOnThisDevice && !isOut(call) && !isAnswered(call)
    };
    props.hasLocalVideo = localMediaStream && localMediaStream.active && isSendingVideo;
  }

  return { ...props,
    ...callProps
  };
});

var withErrors = compose(connect(state => state, dispatch => bindActionCreators({
  addError,
  removeError
}, dispatch)), lifecycle({
  componentWillMount() {
    const {
      call,
      destination,
      intl
    } = this.props;

    if (!call && (!destination || destination && !destination.id || !destination.type)) {
      const {
        formatMessage
      } = intl;
      this.props.addError({
        id: 'widgetMeet.to',
        displayTitle: formatMessage(messages$1.callErrorBadToPropTitle),
        displaySubtitle: formatMessage(messages$1.callErrorBadToPropMessage),
        temporary: false
      });
    }
  },

  componentWillReceiveProps({
    call
  }) {
    if (call && call.error && !this.props.error) {
      // Call has an error
      this.props.catchCallError(call.error);
      this.props.handleHangup();
    }
  }

}));

function NoWebRTCSupport({
  intl
}) {
  return /*#__PURE__*/React.createElement("div", {
    className: classNames(styles.meetWidgetContainer, styles.noWebRtc, 'meet-widget-container')
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.noWebRtcMessage
  }, /*#__PURE__*/React.createElement("p", null, intl.formatMessage(messages$1.noWebRTCBrowserSupportMessage)), /*#__PURE__*/React.createElement("p", null, intl.formatMessage(messages$1.useSupportedBrowserMessage))));
}

NoWebRTCSupport.propTypes = {
  // Grabbed from https://github.com/sharetribe/ftw-daily/blob/master/src/util/reactIntl.js#L10
  intl: shape({
    formatDate: func.isRequired,
    formatHTMLMessage: func.isRequired,
    formatMessage: func.isRequired,
    formatNumber: func.isRequired,
    formatPlural: func.isRequired,
    formatRelativeTime: func.isRequired,
    formatTime: func.isRequired
  }).isRequired
};

const isNotSupported = ({
  media
}) => media.getIn(['webRTC', 'hasCheckedSupport']) && !media.getIn(['webRTC', 'isSupported']);

var withWebRtcSupport = branch(isNotSupported, renderComponent(NoWebRTCSupport));

const eventNames = {
  CALLS_CREATED: 'calls:created',
  CALLS_CONNECTED: 'calls:connected',
  CALLS_DISCONNECTED: 'calls:disconnected',
  MEMBERSHIPS_NOTIFIED: 'memberships:notified',
  MEMBERSHIPS_CONNECTED: 'memberships:connected',
  MEMBERSHIPS_DECLINED: 'memberships:declined',
  MEMBERSHIPS_DISCONNECTED: 'memberships:disconnected'
};
/**
 * Creates an event data object for DOM and event hooks
 *
 * @export
 * @param {Object} call
 * @param {Object} actor
 * @param {String} spaceId
 * @returns {Object}
 */

function constructCallEventData({
  callInstance,
  actor
}) {
  let personDetails = {};

  if (actor) {
    personDetails = {
      actorId: constructHydraId(hydraTypes.PEOPLE, actor.id),
      actorName: actor.name,
      personId: constructHydraId(hydraTypes.PEOPLE, actor.id),
      personEmail: actor.email
    };
  }

  if (callInstance && callInstance.locus) {
    const {
      locus
    } = callInstance;
    const conversationId = locus.conversationUrl.split('/');
    const {
      host
    } = locus;

    if (host) {
      personDetails.actorId = constructHydraId(hydraTypes.PEOPLE, host.id);
      personDetails.actorName = host.name;
      personDetails.personEmail = host.email;
      personDetails.personId = constructHydraId(hydraTypes.PEOPLE, host.id);
    }

    if (conversationId) {
      personDetails.roomId = constructHydraId(hydraTypes.ROOM, conversationId);
    }
  }

  return { ...personDetails,
    call: callInstance
  };
}

function handleEvent(props) {
  return (name, data) => {
    const {
      onEvent
    } = props;

    if (typeof onEvent === 'function') {
      onEvent(name, data);
    }
  };
}

var withEventHandler = compose(withHandlers({
  handleEvent
}), lifecycle({
  componentDidMount() {
    this.eventNames = Object.assign({}, eventNames, this.props.eventNames);
  },

  componentWillReceiveProps(nextProps) {
    const {
      currentUser,
      call,
      callInstance
    } = nextProps;
    const prevCall = this.props.call;

    try {
      if (call) {
        // Check if this is a new initiated call
        if (call.isInitiated && (!prevCall || !prevCall.isInitiated)) {
          // Emit the event
          nextProps.handleEvent(this.eventNames.CALLS_CREATED, constructCallEventData({
            callInstance
          }));
        }

        if (call.isConnected && !prevCall.isConnected) {
          // New call is connected, emit event
          nextProps.handleEvent(this.eventNames.CALLS_CONNECTED, constructCallEventData({
            callInstance
          }));
        }
      }

      if (!call && prevCall) {
        nextProps.handleEvent(this.eventNames.CALLS_DISCONNECTED, constructCallEventData({
          callInstance: prevCall.instance,
          actor: currentUser
        }));
      }
    } catch (e) {// Do nothing
    }
  }

}));

/**
 * Catches a call error and creates a system error
 * @param {*} props
 * @param {Object} props.call expects to have a call object
 * @param {Object} props.call.error call should have an error to process
 * @returns {Function} a recompose handler
 */

function catchCallError(props) {
  return () => {
    const error = props.call.error || {};
    const callErrorId = 'spark.call';
    const {
      formatMessage
    } = props.intl;
    const actionTitle = formatMessage(messages$1.okButtonLabel);
    let displayTitle;
    let displaySubtitle;

    switch (error.name) {
      case 'DevicesNotFoundError':
        displayTitle = formatMessage(messages$1.callErrorDeviceNotFound);
        break;

      case 'NotAllowedError':
        displayTitle = formatMessage(messages$1.callErrorNotAllowed);
        break;

      case 'SecurityError':
        displayTitle = formatMessage(messages$1.callErrorSecurity);
        break;

      default:
        displayTitle = formatMessage(messages$1.callErrorUnknownMessage);
        displaySubtitle = `(${error.name} ${error.message})`;
    }

    props.addError({
      actionTitle,
      code: error.name,
      id: callErrorId,
      displayTitle,
      displaySubtitle,
      onAction: () => props.removeError(callErrorId),
      temporary: true
    });
  };
}

function handleAnswer(props) {
  const cleanUp = () => props.updateWidgetStatus({
    hasInitiatedCall: false
  });

  return () => {
    const {
      call,
      sdkAdapter,
      destinationId
    } = props;
    props.updateWidgetStatus({
      hasInitiatedCall: true
    });
    props.acceptIncomingCall(call, {
      sdkAdapter,
      destinationId,
      cleanUp
    }).then(({
      id: callId
    }) => props.storeMeetDetails({
      callId
    }));
  };
}

function handleDecline(props) {
  return () => {
    const {
      call,
      sdkAdapter
    } = props;
    props.declineIncomingCall(call, sdkAdapter);
  };
}

function handleHangup(props) {
  return () => {
    const {
      call
    } = props;
    props.hangupCall({
      call: call.instance,
      id: call.id
    });
  };
}

function handleCall(props) {
  const cleanUp = () => props.updateWidgetStatus({
    hasInitiatedCall: false
  });

  return () => {
    const {
      sdkAdapter,
      widgetMeet
    } = props;
    const {
      toType,
      toValue
    } = widgetMeet;
    let destination = toValue;
    const callOptions = {
      constraints: {
        audio: true,
        video: true
      },
      offerOptions: {
        offerToReceiveVideo: true,
        offerToReceiveAudio: true
      }
    };

    switch (toType) {
      case destinationTypes.USERID:
        destination = constructHydraId(hydraTypes.PEOPLE, toValue);
        break;

      case destinationTypes.SPACEID:
        destination = toValue;
        break;

      case destinationTypes.PSTN:
        callOptions.constraints.video = false;
        callOptions.offerOptions.offerToReceiveVideo = false;
        break;
    }

    props.updateWidgetStatus({
      hasInitiatedCall: true
    });
    props.placeCall(sdkAdapter, {
      destination,
      options: callOptions,
      cleanUp
    }).then(({
      id
    }) => {
      props.storeMeetDetails({
        callId: id
      });
    });
  };
}

function handleCallNotification(props) {
  return (incomingCall, fromPersonName) => {
    const {
      intl,
      avatarImage
    } = props;
    const {
      formatMessage
    } = intl;
    const details = {
      username: fromPersonName,
      message: formatMessage(messages$1.incomingCallMessage),
      avatar: avatarImage
    };
    props.createNotification(incomingCall.id, details);
  };
}

var withCallHandlers = compose(connect(null, dispatch => bindActionCreators({
  createNotification,
  acceptIncomingCall,
  declineIncomingCall,
  placeCall,
  hangupCall,
  updateWidgetStatus,
  storeMeetDetails,
  addError,
  removeError
}, dispatch)), withHandlers({
  handleAnswer,
  handleDecline,
  handleHangup,
  handleCall,
  handleCallNotification,
  catchCallError
}), lifecycle({
  componentWillReceiveProps(nextProps) {
    const {
      call,
      displayName,
      widgetMeet,
      currentUser,
      startCall,
      isIncoming
    } = nextProps;

    if (call) {
      const prevCall = this.props.call; // Check if this is a new initiated call and is incoming

      if (call.isInitiated && (!prevCall || !prevCall.isInitiated) && isIncoming) {
        nextProps.handleCallNotification(call, displayName);
      }
    }

    if ((widgetMeet.toValue || call) && currentUser && !widgetMeet.status.hasOpenWithCall && (startCall === true || startCall === '' || startCall === 'true')) {
      nextProps.updateWidgetStatus({
        hasOpenWithCall: true
      });
      nextProps.handleCall();
    }
  },

  componentWillUnmount() {
    if (this.props.isActive) {
      this.props.handleHangup();
    }
  }

}));

function storeDestinationType(props) {
  const {
    destination,
    call
  } = props;
  const details = {};

  if (destination && !call) {
    let toValue = destination.id; // Normalize To values and store

    switch (destination.type) {
      case destinationTypes.SIP:
        toValue = toValue.replace('sip:', '');
        break;

      case destinationTypes.USERID:
        {
          const hydraObject = deconstructHydraId(toValue);
          toValue = hydraObject.id;
        }
        break;
    }

    details.toType = destination.type;
    details.toValue = toValue;
    props.storeMeetDetails(details);
  }
}

var withDestinationType = compose(connect(null, dispatch => bindActionCreators({
  storeMeetDetails
}, dispatch)), lifecycle({
  componentWillMount() {
    storeDestinationType(this.props);
  }

}));

function getCallDetails(props) {
  const {
    sparkInstance,
    avatar,
    spaces,
    users,
    currentUser,
    widgetMeet,
    media
  } = props;
  const {
    toType,
    toValue
  } = widgetMeet;

  switch (toType) {
    case destinationTypes.EMAIL:
      if (!users.getIn(['byEmail', toValue])) {
        props.getUser({
          email: toValue
        }, sparkInstance);
      }

      break;

    case destinationTypes.USERID:
      if (!users.getIn(['byId', toValue])) {
        props.getUser({
          id: toValue
        }, sparkInstance);
      }

      break;

    case destinationTypes.SPACEID:
      {
        const spaceShell = validateAndDecodeId(toValue);
        const space = spaces.getIn(['byId', spaceShell.id]);

        if (!space) {
          props.fetchSpace(sparkInstance, spaceShell).then(s => {
            if (s && s.locusUrl) {
              props.storeMeetDetails({
                callId: media.getIn(['byLocusUrl', s.locusUrl])
              });
            }
          });
        } else if (!space.isFetching && !avatar.hasIn(['items', space.id]) && !avatar.hasIn(['avatarsInFlight', space.id])) {
          const otherUser = space.participants.find(p => p !== currentUser.id);

          if (space.type !== 'direct' || !avatar.hasIn(['items', otherUser]) && !avatar.hasIn(['avatarsInFlight', otherUser])) {
            props.fetchAvatar({
              space,
              userId: otherUser
            }, sparkInstance);
          }
        }
      }
      break;
  }
}

var withMeetDetails = compose(connect(null, dispatch => bindActionCreators({
  fetchSpace,
  fetchAvatar,
  storeMeetDetails,
  getUser
}, dispatch)), lifecycle({
  componentWillReceiveProps(nextProps) {
    // check to see if we have gotten currentUser and device is registered
    if (nextProps.currentUser) {
      getCallDetails(nextProps);
    }
  }

}));

var enhancers = compose(setDisplayName('WidgetMeetEnhancers'), withEventHandler, withDestinationType, withMeetDetails, withCallHandlers, withErrors, withWebRtcSupport);

const injectedPropTypes = {
  avatarId: PropTypes.string,
  avatarImage: PropTypes.string,
  displayName: PropTypes.string,
  call: PropTypes.object,
  meeting: PropTypes.object,
  widgetMeet: PropTypes.object.isRequired
};
const ownPropTypes = {
  call: PropTypes.object,
  destination: PropTypes.shape({
    id: PropTypes.string.isRequired,
    type: PropTypes.oneOf(['email', 'spaceId', 'userId', 'sip', 'pstn'])
  }).isRequired,
  eventNames: PropTypes.object,
  muteNotifications: PropTypes.bool,
  onEvent: PropTypes.func,
  startCall: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])
};
class MeetWidget extends Component {
  constructor() {
    super();
    this.state = {};
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  render() {
    const {
      intl,
      displayName,
      isIncoming,
      avatarImage,
      meeting,
      widgetMeet,
      sdkAdapter
    } = this.props;
    const {
      formatMessage
    } = intl;
    const {
      avatarId
    } = this.props.spaceDetails;

    if (displayName && sdkAdapter) {
      // Is this an incoming call?
      if (isIncoming) {
        const {
          handleAnswer,
          handleDecline
        } = this.props;
        return /*#__PURE__*/React.createElement("div", {
          className: classNames(styles.meetWidgetContainer, 'meet-widget-container')
        }, /*#__PURE__*/React.createElement(IncomingCall, {
          answerButtonLabel: formatMessage(messages$1.answerButtonLabel),
          avatarId: avatarId,
          avatarImage: avatarImage,
          declineButtonLabel: formatMessage(messages$1.declineButtonLabel),
          displayName: displayName,
          incomingCallMessage: formatMessage(messages$1.incomingCallMessage),
          onAnswerClick: handleAnswer,
          onDeclineClick: handleDecline
        }), /*#__PURE__*/React.createElement(Ringtone, {
          play: true,
          type: RINGTONE_TYPE_INCOMING
        }), /*#__PURE__*/React.createElement(Notifications, {
          onEvent: this.props.handleEvent,
          isMuted: this.props.muteNotifications
        }));
      } // Is the call active?


      if (meeting && (meeting.meetingFiniteStateMachine.is('JOINED') || widgetMeet.status.hasInitiatedCall)) {
        return /*#__PURE__*/React.createElement("div", {
          className: classNames(styles.meetWidgetContainer, 'meet-widget-container')
        }, /*#__PURE__*/React.createElement(ActiveMeeting, {
          adapter: sdkAdapter,
          meetingId: meeting.id
        }), /*#__PURE__*/React.createElement(Ringtone, {
          play: status.isRinging,
          type: RINGTONE_TYPE_RINGBACK
        }));
      }

      if (widgetMeet.status.hasInitiatedCall) {
        return /*#__PURE__*/React.createElement(LoadingScreen, null);
      }

      return /*#__PURE__*/React.createElement("div", {
        className: classNames(styles.meetWidgetContainer, 'meet-widget-container')
      }, /*#__PURE__*/React.createElement(InactiveCall, {
        avatarId: avatarId,
        avatarImage: avatarImage,
        callButtonAriaLabel: formatMessage(messages$1.callButtonAriaLabel),
        callButtonLabel: formatMessage(messages$1.callButtonLabel),
        displayName: displayName,
        onCallClick: this.props.handleCall
      }), /*#__PURE__*/React.createElement(Notifications, {
        onEvent: this.props.handleEvent,
        isMuted: this.props.muteNotifications
      }));
    }

    return /*#__PURE__*/React.createElement(LoadingScreen, null);
  }

}
MeetWidget.propTypes = { ...ownPropTypes,
  ...injectedPropTypes
};
var ConnectedMeet = compose(connect(getMeetWidgetProps), enhancers)(MeetWidget);

var messages = {};

const destinationTypes = {
  SIP: 'sip',
  EMAIL: 'email',
  USERID: 'userId',
  SPACEID: 'spaceId',
  PSTN: 'pstn'
};
var index = compose(constructWebexEnhancer({
  name: 'meet',
  reducers
}), withIntl({
  locale: 'en',
  messages
}), enhancer, enhancer$1)(ConnectedMeet);

export default index;
export { destinationTypes, reducers };
//# sourceMappingURL=index.js.map
