import { compose, lifecycle } from 'recompose';
import { constructWebexEnhancer, withIntl } from '@webex/webex-widget-base';
import mercury, { connectToMercury, enhancer as enhancer$1 } from '@webex/redux-module-mercury';
import media, { enhancer } from '@webex/redux-module-media';
import { Record, OrderedMap } from 'immutable';
import users, { storeUser } from '@webex/redux-module-users';
import spaces, { addSpaceTags, fetchSpace, removeSpace, removeSpaceTags, updateSpaceRead, updateSpaceWithActivity, fetchSpaces, fetchSpacesEncrypted, fetchSpacesHydra } from '@webex/redux-module-spaces';
import errors$1, { addError, removeError } from '@webex/redux-module-errors';
import features, { getFeature } from '@webex/redux-module-features';
import teams, { fetchTeams } from '@webex/redux-module-teams';
import avatar, { fetchAvatar } from '@webex/redux-module-avatar';
import activities, { storeActivities } from '@webex/redux-module-activities';
import presence from '@webex/redux-module-presence';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import classNames from 'classnames';
import { autobind } from 'core-decorators';
import { pick, has } from 'lodash';
import LoadingScreen from '@webex/react-component-loading-screen';
import ErrorDisplay from '@webex/react-component-error-display';
import SpacesList from '@webex/react-component-spaces-list';
import { defineMessages } from 'react-intl';
import { MenuOverlay, MenuContent, Avatar, Menu, MenuItem, InputSearch, Button, Icon } from '@momentum-ui/react';
import PresenceAvatar from '@webex/react-container-presence-avatar';
import { constructHydraId, hydraTypes, SPACE_TYPE_ONE_ON_ONE, SPACE_TYPE_GROUP, formatDate, MENTION_NOTIFICATIONS_ON, MENTION_NOTIFICATIONS_OFF, MESSAGE_NOTIFICATIONS_ON, MESSAGE_NOTIFICATIONS_OFF, API_ACTIVITY_TYPE, API_ACTIVITY_VERB, FEATURES_USER, FEATURES_GROUP_MESSAGE_NOTIFICATIONS, FEATURES_MENTION_NOTIFICATIONS } from '@webex/react-component-utils';
import { createSelector } from 'reselect';
import moment from 'moment';

const UPDATE_SPACE_KEYWORD_FILTER = 'widget-recents/UPDATE_SPACE_KEYWORD_FILTER';
const UPDATE_STATUS = 'widget-recents/UPDATE_STATUS';
function updateSpaceKeywordFilter(keyword) {
  return {
    type: UPDATE_SPACE_KEYWORD_FILTER,
    payload: {
      keyword
    }
  };
}
function updateWidgetStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

const Status = Record({
  isFetchingInitialSpaces: false,
  hasFetchedInitialSpaces: false,
  isFetchingAllSpaces: false,
  hasFetchedAllSpaces: false,
  isFetchingRecentSpaces: false,
  hasFetchedRecentSpaces: false,
  isFetchingTeams: false,
  hasFetchedTeams: false,
  isFetchingAvatars: false,
  hasFetchedAvatars: false,
  isListeningForNewActivity: false,
  hasFetchedGroupMessageNotificationFeature: false,
  hasFetchedMentionNotificationFeature: false,
  isScrolledToTop: true
});
const RecentsWidget$1 = Record({
  incomingCall: null,
  keyword: null,
  spaceType: null,
  status: new Status()
});
new RecentsWidget$1();
function reducer(state = new RecentsWidget$1(), action) {
  switch (action.type) {
    case UPDATE_STATUS:
      return state.mergeIn(['status'], action.payload.status);

    case UPDATE_SPACE_KEYWORD_FILTER:
      return state.setIn(['keyword'], action.payload.keyword ? action.payload.keyword.trim() : '');

    default:
      return state;
  }
}
const reducers = {
  avatar,
  activities,
  errors: errors$1,
  features,
  media,
  mercury,
  presence,
  spaces,
  teams,
  users,
  widgetRecents: reducer
};

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

/*
 * WidgetRecents Messages
 *
 * This contains all the text for the FeaturePage component.
 */
var messages$1 = defineMessages({
  sharedFile: {
    id: 'ciscospark.container.recents.sharedFile',
    defaultMessage: 'Shared a file'
  },
  noSpaces: {
    id: 'ciscospark.container.recents.noSpaces',
    defaultMessage: 'No spaces yet'
  },
  createSpacePlus: {
    id: 'ciscospark.container.recents.createSpacePlus',
    defaultMessage: 'Create a space using the plus button next to the search bar above.'
  },
  createSpaceTeams: {
    id: 'ciscospark.container.recents.createSpaceTeams',
    defaultMessage: 'Create spaces in Webex to see them here.'
  },
  unavailable: {
    id: 'ciscospark.container.recents.userUnavailable',
    defaultMessage: '{actorName} was unavailable.'
  },
  addedToSpace: {
    id: 'ciscospark.container.recents.addedToSpace',
    defaultMessage: '{actorName} added {targetName} to this space.'
  },
  answerButtonLabel: {
    id: 'ciscospark.container.recents.button.answer',
    defaultMessage: 'Answer'
  },
  declineButtonLabel: {
    id: 'ciscospark.container.recents.button.decline',
    defaultMessage: 'Decline'
  },
  incomingCallMessage: {
    id: 'ciscospark.container.recents.message.incomingCall',
    defaultMessage: 'Incoming call'
  },
  errorConnection: {
    id: 'ciscospark.container.recents.error.connection',
    defaultMessage: 'Connection unavailable.'
  },
  errorBadToken: {
    id: 'ciscospark.container.recents.error.badtoken',
    defaultMessage: 'Error: Bad or Invalid Access Token'
  },
  unableToLoad: {
    id: 'ciscospark.container.recents.error.unabletoload',
    defaultMessage: 'Unable to Load Recents'
  },
  unknownError: {
    id: 'ciscospark.container.recents.error.unknown',
    defaultMessage: 'There was a problem loading recents'
  },
  reconnecting: {
    id: 'ciscospark.container.recents.error.reconnecting',
    defaultMessage: 'Reconnecting...'
  },
  viewOlderSpacesButtonLabel: {
    id: 'ciscospark.container.recents.button.viewOlderSpaces',
    defaultMessage: 'View Older Spaces'
  }
});

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$4 = ".widget-recents__noSpacesWrapper__Lm5vU3Bh {\n  height: 100%;\n  text-align: center;\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  justify-content: center;\n  background-color: black;\n}\n\n.widget-recents__noSpacesImg__Lm5vU3Bh {\n  height: 72px;\n  width: 100%;\n  margin-bottom: 24px;\n}\n\n.widget-recents__noSpacesTitle__Lm5vU3Bh {\n  color: #fff;\n  font-weight: 700;\n  line-height: 24px;\n  text-align: center;\n  margin-bottom: 12px;\n}\n\n.widget-recents__noSpacesMessage__Lm5vU3Bh {\n  color: hsla(0,0%,100%,.6);\n  line-height: 22px;\n  text-align: center;\n}\n";
var styles$3 = {"noSpacesWrapper":"widget-recents__noSpacesWrapper__Lm5vU3Bh","noSpacesImg":"widget-recents__noSpacesImg__Lm5vU3Bh","noSpacesTitle":"widget-recents__noSpacesTitle__Lm5vU3Bh","noSpacesMessage":"widget-recents__noSpacesMessage__Lm5vU3Bh"};
styleInject(css_248z$4);

const propTypes$2 = {
  title: PropTypes.string.isRequired,
  emptyMessage: PropTypes.string.isRequired
};

function NoSpaces(props) {
  const {
    title,
    emptyMessage
  } = props;
  return /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-recents-widget-no-spaces', styles$3.noSpacesWrapper)
  }, /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-no-spaces-img', styles$3.noSpacesImg)
  }, /*#__PURE__*/React.createElement("svg", {
    width: "80px",
    height: "62px",
    viewBox: "0 0 80 62",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React.createElement("defs", null), /*#__PURE__*/React.createElement("g", {
    id: "Illustrations",
    stroke: "none",
    strokeWidth: "1",
    fill: "none",
    fillRule: "evenodd"
  }, /*#__PURE__*/React.createElement("g", {
    id: "Artboard",
    transform: "translate(-1053.000000, -175.000000)",
    fill: "#FFFFFF"
  }, /*#__PURE__*/React.createElement("g", {
    id: "No-Space",
    transform: "translate(1053.000000, 175.000000)"
  }, /*#__PURE__*/React.createElement("path", {
    d: "M56.999,0 C44.297,0 34,10.297 34,22.999 C34,26.583 34.82,29.975 36.282,32.998 L37.822,32.998 L56.5,32.998 C56.775,32.998 57,33.223 57,33.498 C57,33.773 56.775,33.998 56.5,33.998 L38.353,33.998 L36.797,33.998 C40.697,41.147 48.281,45.998 56.999,45.998 C69.701,45.998 79.998,35.701 79.998,22.999 C79.998,10.297 69.701,0 56.999,0",
    id: "fill",
    opacity: "0.400000006"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M29,33 L29,5.5 C29,5.225 28.775,5 28.5,5 C28.225,5 28,5.225 28,5.5 L28,33 L0.5,33 C0.225,33 0,33.225 0,33.5 C0,33.775 0.225,34 0.5,34 L28,34 L28,61.5 C28,61.775 28.225,62 28.5,62 C28.775,62 29,61.775 29,61.5 L29,34 L36.797,34 C36.617,33.671 36.445,33.338 36.282,33 L29,33 Z",
    id: "fill"
  })))))), /*#__PURE__*/React.createElement("h2", {
    className: classNames('webex-no-spaces-title', styles$3.noSpacesTitle)
  }, title), /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-no-spaces-message', styles$3.noSpacesMessage)
  }, emptyMessage));
}

NoSpaces.propTypes = propTypes$2;

var css_248z$3 = ".widget-recents__menu__Lm1lbnUg {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  width: 235px;\n  height: 160px;\n  border-bottom: 1px solid #E0E0E0;\n}\n\n.widget-recents__menu__Lm1lbnUg h5 {\n  color: #666666;\n}\n\n.widget-recents__info__Lm1lbnUg {\n  margin-top: 8px;\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n}\n\n.widget-recents__signout__Lm1lbnUg div {\n  color: black !important;\n}\n";
var styles$2 = {"menu":"widget-recents__menu__Lm1lbnUg","info":"widget-recents__info__Lm1lbnUg","signout":"widget-recents__signout__Lm1lbnUg"};
styleInject(css_248z$3);

const propTypes$1 = {
  currentUserWithAvatar: PropTypes.shape({
    id: PropTypes.string,
    displayName: PropTypes.string,
    email: PropTypes.string,
    img: PropTypes.string
  }).isRequired,
  enableUserProfileMenu: PropTypes.bool.isRequired,
  onSignOutClick: PropTypes.func,
  onProfileClick: PropTypes.func
};
const defaultProps$2 = {
  onSignOutClick: () => {},
  onProfileClick: () => {}
};

function ProfileAvatarMenu(props) {
  const {
    currentUserWithAvatar,
    enableUserProfileMenu,
    onProfileClick,
    onSignOutClick
  } = props;
  const presenceAvatar = /*#__PURE__*/React.createElement(PresenceAvatar, {
    avatarId: currentUserWithAvatar.id,
    name: currentUserWithAvatar.displayName,
    onClick: onProfileClick
  });
  const menu = /*#__PURE__*/React.createElement(MenuOverlay, {
    direction: "bottom-left",
    menuTrigger: presenceAvatar,
    targetOffset: {
      vertical: 4
    }
  }, /*#__PURE__*/React.createElement(MenuContent, null, /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-recents-header-profile-menu', styles$2.menu)
  }, /*#__PURE__*/React.createElement(Avatar, {
    src: currentUserWithAvatar.img,
    title: currentUserWithAvatar.displayName,
    size: 84
  }), /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-recents-header-profile-menu-info', styles$2.info)
  }, /*#__PURE__*/React.createElement("h4", null, currentUserWithAvatar.displayName, " "), /*#__PURE__*/React.createElement("h5", null, currentUserWithAvatar.email)))), /*#__PURE__*/React.createElement(Menu, null, /*#__PURE__*/React.createElement(MenuItem, {
    className: classNames('webex-recents-header-profile-menu-signout', styles$2.signout),
    onClick: onSignOutClick,
    label: "Sign Out"
  })));
  return enableUserProfileMenu ? menu : presenceAvatar;
}

ProfileAvatarMenu.propTypes = propTypes$1;
ProfileAvatarMenu.defaultProps = defaultProps$2;

var css_248z$2 = ".widget-recents__recentsHeader__LnJlY2Vu {\n  height: 60px;\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  box-sizing: border-box;\n  background: black;\n}\n\n.widget-recents__bottomBorder__LnJlY2Vu {\n  border-bottom: 1px solid #666666;\n}\n\n.widget-recents__searchInputWrapper__LnJlY2Vu {\n  display: flex;\n  justify-content: center;\n  align-self: center;\n  flex: 1 1 auto;\n  margin: auto;\n  fill: #efefef;\n  background-color: black\n}\n\n.widget-recents__searchInput__LnJlY2Vu {\n  background-color: #666666;\n  border-radius: 100px;\n  width: 100%;\n  height: 32px;\n}\n\n.widget-recents__searchInput__LnJlY2Vu input {\n  border: none;\n}\n\n.widget-recents__headerSideItem__LnJlY2Vu {\n  flex: 0 0 auto;\n  margin-left: 14px;\n  margin-right: 14px;\n  min-width: 40px;\n  height: 40px;\n}\n";
var styles$1 = {"recentsHeader":"widget-recents__recentsHeader__LnJlY2Vu","bottomBorder":"widget-recents__bottomBorder__LnJlY2Vu","searchInputWrapper":"widget-recents__searchInputWrapper__LnJlY2Vu","searchInput":"widget-recents__searchInput__LnJlY2Vu","headerSideItem":"widget-recents__headerSideItem__LnJlY2Vu"};
styleInject(css_248z$2);

const propTypes = {
  currentUserWithAvatar: PropTypes.shape({
    id: PropTypes.string,
    displayName: PropTypes.string,
    email: PropTypes.string,
    img: PropTypes.string
  }).isRequired,
  enableAddButton: PropTypes.bool.isRequired,
  enableSpaceListFilter: PropTypes.bool.isRequired,
  enableUserProfile: PropTypes.bool.isRequired,
  enableUserProfileMenu: PropTypes.bool.isRequired,
  hideBottomBorder: PropTypes.bool.isRequired,
  onAddClick: PropTypes.func,
  onFilterChange: PropTypes.func,
  onProfileClick: PropTypes.func,
  onSignOutClick: PropTypes.func
};
const defaultProps$1 = {
  onAddClick: () => {},
  onProfileClick: () => {},
  onFilterChange: () => {},
  onSignOutClick: () => {}
};

function RecentsHeader(props) {
  const {
    currentUserWithAvatar,
    enableAddButton,
    enableUserProfile,
    enableUserProfileMenu,
    enableSpaceListFilter,
    hideBottomBorder,
    onAddClick,
    onFilterChange,
    onProfileClick,
    onSignOutClick
  } = props;
  return /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-recents-header', styles$1.recentsHeader, 'md--dark', hideBottomBorder ? '' : styles$1.bottomBorder)
  }, /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-recents-header-left', styles$1.headerSideItem)
  }, enableUserProfile && /*#__PURE__*/React.createElement(ProfileAvatarMenu, {
    currentUserWithAvatar: currentUserWithAvatar,
    enableUserProfileMenu: enableUserProfileMenu,
    onProfileClick: onProfileClick,
    onSignOutClick: onSignOutClick
  })), /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-search-input-wrapper', styles$1.searchInputWrapper)
  }, enableSpaceListFilter && /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-search-input', styles$1.searchInput)
  }, /*#__PURE__*/React.createElement(InputSearch, {
    name: "pillSearchInput",
    htmlId: "pillSearchInput",
    type: "pill",
    onKeyUp: onFilterChange,
    onChange: onFilterChange,
    clear: true
  }))), /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-recents-header-right', styles$1.headerSideItem)
  }, enableAddButton && /*#__PURE__*/React.createElement(Button, {
    ariaLabel: "Contact a person or create a space",
    onClick: onAddClick,
    circle: true,
    color: "white",
    size: 40,
    title: "Contact a person or create a space"
  }, /*#__PURE__*/React.createElement(Icon, {
    name: "plus_18"
  }))));
}

RecentsHeader.propTypes = propTypes;
RecentsHeader.defaultProps = defaultProps$1;

function checkForMercuryErrors(props) {
  const {
    errors,
    intl,
    mercury
  } = props; // Add Mercury disconnect error

  const mercuryError = 'mercury.disconnect';
  const isMercuryConnected = mercury.getIn(['status', 'connected']);
  const isMercuryDisconnected = !isMercuryConnected && mercury.getIn(['status', 'hasConnected']);
  const hasError = errors.get('hasError');
  const hasMercuryError = errors.get('errors').has(mercuryError);
  const hasNoMercuryError = !hasError || !hasMercuryError;

  if (isMercuryDisconnected && hasNoMercuryError) {
    // Create UI Error
    const {
      formatMessage
    } = intl;
    props.addError({
      id: mercuryError,
      displayTitle: formatMessage(messages$1.errorConnection),
      displaySubtitle: formatMessage(messages$1.reconnecting),
      temporary: true
    });
  }

  if (isMercuryConnected && hasMercuryError) {
    props.removeError(mercuryError);
  }
}

function checkForErrors(props) {
  const {
    errors,
    sparkState,
    spark
  } = props;
  const {
    formatMessage
  } = props.intl;
  const registerErrorId = 'spark.register';

  if (sparkState.registerError && (!errors.get('hasError') || !errors.get('errors').has(registerErrorId))) {
    const error = spark.get('error');
    let displaySubtitle = formatMessage(messages$1.unknownError);

    if (error.statusCode === 401) {
      displaySubtitle = formatMessage(messages$1.errorBadToken);
    }

    props.addError({
      id: registerErrorId,
      displayTitle: formatMessage(messages$1.unableToLoad),
      displaySubtitle,
      temporary: false,
      code: error.statusCode
    });
  }
}

function checkForPropsErrors(props) {
  const {
    errors,
    enableUserProfile,
    enableUserProfileMenu
  } = props;
  const missingUserProfilePropErrorId = 'missingUserProfilePropErrorId';

  if (enableUserProfileMenu && !enableUserProfile && (!errors.get('hasError') || !errors.get('errors').has(missingUserProfilePropErrorId))) {
    props.addError({
      id: missingUserProfilePropErrorId,
      displayTitle: 'You must enable the userProfile property if the userProfileMenu property is enabled',
      temporary: false
    });
  }
}

var errors = compose(connect(state => state, dispatch => bindActionCreators({
  addError,
  removeError
}, dispatch)), lifecycle({
  componentWillMount() {
    checkForErrors(this.props);
    checkForMercuryErrors(this.props);
    checkForPropsErrors(this.props);
  },

  componentWillReceiveProps: nextProps => {
    checkForMercuryErrors(nextProps);
    checkForErrors(nextProps);
    checkForPropsErrors(nextProps);
  }
}));

const eventNames = {
  SPACES_READ: 'rooms:read',
  SPACES_UNREAD: 'rooms:unread',
  SPACES_SELECTED: 'rooms:selected',
  MESSAGES_CREATED: 'messages:created',
  CALLS_CREATED: 'calls:created',
  ACTION_CALL: 'call',
  MEMBERSHIPS_CREATED: 'memberships:created',
  MEMBERSHIPS_DELETED: 'memberships:deleted',
  ADD_CLICKED: 'add:clicked',
  PROFILE_CLICKED: 'profile:clicked',
  USER_SIGNOUT_CLICKED: 'user_signout:clicked'
};
/**
 * Constructs an event detail object for messages:created
 * @export
 * @param {Object} activity from mercury
 * @param {Object} toUser
 * @returns {Object} constructed event
 */

function constructMessagesEventData(activity, toUser) {
  const roomType = activity.target.tags.includes('ONE_ON_ONE') ? 'direct' : 'group';
  let files, toPersonEmail, toPersonId;

  if (roomType === 'direct' && toUser) {
    toPersonEmail = toUser.email;
    toPersonId = constructHydraId(hydraTypes.PEOPLE, toUser.id);
  }

  let mentionedPeople = activity.object.mentions;

  if (mentionedPeople && mentionedPeople.items.length) {
    mentionedPeople = mentionedPeople.items.map(people => ({
      id: constructHydraId(hydraTypes.PEOPLE, people.id)
    }));
  } // Files need to be decrypted and converted into a usable URL


  if (activity.object.files && activity.object.files.items.length) {
    files = activity.object.files.items;
  }

  const personId = constructHydraId(hydraTypes.PEOPLE, activity.actor.id);
  return {
    actorId: personId,
    id: constructHydraId(hydraTypes.MESSAGE, activity.id),
    roomId: constructHydraId(hydraTypes.ROOM, activity.target.id),
    roomType: activity.target.tags.includes('ONE_ON_ONE') ? 'direct' : 'group',
    text: activity.object.displayName,
    html: activity.object.content,
    files,
    personId,
    personEmail: activity.actor.emailAddress,
    created: activity.published,
    mentionedPeople,
    toPersonId,
    toPersonEmail
  };
}
function constructRoomsEventData(space, activity) {
  return {
    id: space.globalId,
    title: space.name,
    type: space.type,
    isLocked: space.isLocked,
    teamId: constructHydraId(hydraTypes.TEAM, space.teamId),
    lastActivity: activity && activity.published || space.lastActivityTimestamp,
    created: space.published,
    toPersonEmail: space.toPersonEmail,
    tags: space.tags,
    isMentionNotificationsOn: space.isMentionNotificationsOn,
    isMentionNotificationsOff: space.isMentionNotificationsOff,
    isMessageNotificationsOn: space.isMessageNotificationsOn,
    isMessageNotificationsOff: space.isMessageNotificationsOff
  };
}
function constructMembershipEventData(activity) {
  return {
    actorId: constructHydraId(hydraTypes.PEOPLE, activity.actor.id),
    id: constructHydraId(hydraTypes.MESSAGE, activity.id),
    roomId: constructHydraId(hydraTypes.ROOM, activity.target.id),
    personId: constructHydraId(hydraTypes.PEOPLE, activity.object.id),
    personEmail: activity.object.emailAddress,
    created: activity.published
  };
}
function constructCallEventData(call, space) {
  const event = {
    call
  };

  if (space && space.id) {
    event.roomId = constructHydraId(hydraTypes.ROOM, space.id);
  }

  return event;
}

/**
 * Finds the participant in a direct space that isn't current user
 *
 * @param {object} space
 * @param {string} currentUserId
 * @returns {object} participant object
 */

function getToParticipant(space, currentUserId) {
  return space.participants.find(p => p.id !== currentUserId);
}
/**
 * Gets the avatar for a space
 * Will fetch the user avatar for 1:1 spaces
 *
 * @export
 * @param {Object} space
 * @param {Object} props
 * @param {function} props.fetchAvatar redux action
 * @param {object} props.sparkInstance spark sdk instance
 * @param {object} props.users users redux store
 */

function getSpaceAvatar(space, props) {
  const {
    users,
    sparkInstance
  } = props;

  if (!space.isDecrypting) {
    if (space.type === SPACE_TYPE_ONE_ON_ONE) {
      // Find the participant that is not the current user
      const toParticipant = getToParticipant(space, users.get('currentUserId'));

      if (toParticipant) {
        // Direct spaces use the "other participant" as the space avatar
        props.fetchAvatar({
          userId: toParticipant.id
        }, sparkInstance);
      }
    } else if (space.type === SPACE_TYPE_GROUP && space.id) {
      props.fetchAvatar({
        space
      }, sparkInstance);
    }
  }
}

const getWidget = state => state.widgetRecents;

const getSpark = state => state.spark;

const getSDKAdapter = state => state.spark.get('adaptor');

const getCurrentUser = state => state.users.getIn(['byId', state.users.get('currentUserId')]);

const getAvatars$1 = state => state.avatar;

const getTeams$1 = state => state.teams.get('byId');

const getSpaces = state => state.spaces.get('byId');

const getUsers = state => state.users.get('byId');

const getActivities = state => state.activities.get('byId');

const getMedia = state => state.media;

const getCallsById = state => state.media.byId;

const getMercuryStatus = state => state.mercury.get('status');

const getFeatures$1 = state => state.features;

const getWidgetProps = (state, props) => props;

function sortByNewest(space) {
  return -moment(space.lastReadableActivityDate).format('x');
}

function constructSpace(space) {
  var _space$tags, _space$tags2, _space$tags3, _space$tags4, _space$tags5;

  const {
    lastSeenActivityDate,
    lastReadableActivityDate
  } = space;
  const properties = ['id', 'locusUrl', 'globalId', 'type', 'participants', 'published', 'tags', 'isDecrypting'];
  const isUnread = lastSeenActivityDate ? moment(lastSeenActivityDate).isBefore(lastReadableActivityDate) : true;
  return { ...pick(space, properties),
    lastActivityTime: formatDate(lastReadableActivityDate),
    lastActivityTimestamp: lastReadableActivityDate,
    name: space.displayName || 'Untitled',
    isLocked: (_space$tags = space.tags) === null || _space$tags === void 0 ? void 0 : _space$tags.includes('LOCKED'),
    isUnread,
    isMentionNotificationsOn: (_space$tags2 = space.tags) !== null && _space$tags2 !== void 0 && _space$tags2.includes(MENTION_NOTIFICATIONS_ON) ? true : undefined,
    isMentionNotificationsOff: (_space$tags3 = space.tags) !== null && _space$tags3 !== void 0 && _space$tags3.includes(MENTION_NOTIFICATIONS_OFF) ? true : undefined,
    isMessageNotificationsOn: (_space$tags4 = space.tags) !== null && _space$tags4 !== void 0 && _space$tags4.includes(MESSAGE_NOTIFICATIONS_ON) ? true : undefined,
    isMessageNotificationsOff: (_space$tags5 = space.tags) !== null && _space$tags5 !== void 0 && _space$tags5.includes(MESSAGE_NOTIFICATIONS_OFF) ? true : undefined
  };
}

function constructOneOnOne({
  space,
  currentUser,
  users
}) {
  const thisSpace = constructSpace(space); // Get the user ID of the participant that isn't current user

  let toPerson, toPersonId;
  const toParticipant = getToParticipant(space, currentUser.id); // Sometimes we have a direct convo with only one participant
  // (user has been deleted, etc)

  if (toParticipant) {
    toPersonId = toParticipant.id;
    toPerson = users.get(toPersonId);
  }

  if (toPerson) {
    thisSpace.toPersonId = toPersonId;
    thisSpace.toPersonEmail = toPerson.email;
    thisSpace.name = toPerson.displayName;
  }

  return thisSpace;
}

function constructGroup({
  space,
  team
}) {
  const {
    id,
    displayName
  } = space;
  const thisSpace = constructSpace(space);
  thisSpace.name = displayName || 'Untitled';

  if (team) {
    thisSpace.teamName = team.displayName;
    thisSpace.teamColor = team.color;
    thisSpace.teamId = team.id;

    if (id === team.generalConversationId) {
      thisSpace.name = 'General';
    }
  }

  return thisSpace;
}

const getIncomingCall = createSelector([getCallsById], calls => calls.find(call => call.isIncoming && !call.isDismissed));
const getRecentSpaces = createSelector([getSpaces, getActivities, getCurrentUser, getUsers, getTeams$1, getWidget, getWidgetProps], (spaces, activities, currentUser, users, teams, widget, widgetProps) => {
  let recents = new OrderedMap();
  const spaceType = widget.get('spaceType');
  spaces.toOrderedMap().sortBy(sortByNewest).forEach(space => {
    if (!space.isHidden && !space.isFetching) {
      const spaceId = space.id;
      const team = teams.get(space.team);
      let constructedSpace;

      if (space.type === 'direct') {
        constructedSpace = constructOneOnOne({
          space,
          users,
          currentUser
        });
      } else {
        constructedSpace = constructGroup({
          space,
          team
        });
      } // All spaces report unread in basic mode due to service limitations


      if (widgetProps.basicMode) {
        constructedSpace.isUnread = false;
      } // Get Latest Activity


      const activity = activities.get(space.latestActivity);

      if (activity) {
        const actorId = activity.actor;
        const actor = users.get(actorId);
        constructedSpace.latestActivity = {
          actorName: actor && actor.displayName ? actor.displayName.split(' ')[0] : '',
          type: activity.type,
          object: activity.object,
          text: activity.object && activity.object.displayName,
          actor,
          tags: space.tags
        };
      }

      if (space.isDecrypting) {
        constructedSpace.name = 'Decrypting Space...';
      }

      recents = recents.set(spaceId, constructedSpace);
    }
  }); // filter space list by type

  if (spaceType && [SPACE_TYPE_ONE_ON_ONE, SPACE_TYPE_GROUP].includes(spaceType)) {
    return recents.filter(space => {
      const {
        type
      } = space;
      return spaceType === type;
    });
  }

  return recents;
});
const getRecentSpacesWithDetail = createSelector([getRecentSpaces, getAvatars$1, getMedia, getWidget], (recentSpaces, avatars, media, widget) => {
  const avatarItems = avatars.get('items');
  const keyword = widget.get('keyword');
  const spaces = recentSpaces.map(space => {
    const s = Object.assign({}, space); // Get Avatar

    if (avatarItems.count()) {
      if (s.type === 'direct') {
        s.avatarUrl = avatarItems.get(s.toPersonId);
      } else {
        s.avatarUrl = avatarItems.get(s.id);
      }
    } // Get current call


    if (media.byId.size && media.hasIn(['byLocusUrl', s.locusUrl])) {
      s.call = media.getIn(['byId', media.getIn(['byLocusUrl', s.locusUrl])]);
      s.hasJoinedOnThisDevice = s.call.hasJoinedOnThisDevice;

      if (s.call.activeParticipantsCount > 0) {
        s.callStartTime = s.call.startTime;
      }
    }

    return s;
  });

  if (keyword && keyword.length > 0) {
    return spaces.filter(({
      name
    }) => name.toLowerCase().includes(keyword.toLowerCase()));
  }

  return spaces;
});
const getCurrentUserWithAvatar = createSelector([getCurrentUser, getAvatars$1], (currentUser, avatars) => {
  let user;

  if (currentUser && currentUser.id) {
    user = Object.assign({}, currentUser.toJS(), {
      img: avatars.getIn(['items', currentUser.id])
    });
  }

  return user;
});
const getRecentsWidgetProps = createSelector([getWidget, getRecentSpacesWithDetail, getSpark, getSpaces, getIncomingCall, getMercuryStatus, getFeatures$1, getCurrentUserWithAvatar, getSDKAdapter], (widget, spacesList, spark, spacesById, incomingCall, mercuryStatus, features, currentUserWithAvatar, sdkAdapter) => {
  let lastActivityDate;

  if (spacesList && spacesList.count()) {
    lastActivityDate = spacesList.last().lastActivityTimestamp;
  }

  return {
    widgetStatus: widget.get('status').toJS(),
    keywordFilter: widget.get('keyword'),
    sparkState: spark.get('status').toJS(),
    sparkInstance: spark.get('spark'),
    widgetRecents: widget,
    spacesById,
    spacesList,
    spacesListArray: spacesList.toArray(),
    lastActivityDate,
    incomingCall,
    mercuryStatus: mercuryStatus.toJS(),
    features,
    currentUserWithAvatar: currentUserWithAvatar || {},
    sdkAdapter
  };
});

/**
 * Recompose Lifecycle Enhancers for Websocket Listeners
 */
/**
 * Event handler that logs data then sends to the onEvent function
 *
 * @param {String} name
 * @param {Object} data
 * @param {Object} props
 */

function handleEvent(name, data, props) {
  const {
    onEvent,
    sparkInstance
  } = props;
  const logData = Object.assign({}, data); // Omit call objet from logger to prevent call range error

  if (data.call) {
    logData.call = '--- OMITTED ---';
  }

  sparkInstance.logger.info(`event handler - ${name}`, logData);

  if (typeof onEvent === 'function') {
    props.onEvent(name, data);
  }
}
/**
 * Processes a space activity as it comes in via websocket
 *
 * Expects a space to have been loaded for the given activity
 *
 * @param {Object} activity
 * @param {Object} space
 * @param {Object} props
 */


function processActivity(activity, space, props) {
  const {
    users,
    spacesList
  } = props; // Reply activities are not currently supported

  if (activity.type === API_ACTIVITY_TYPE.REPLY) {
    return;
  }

  props.storeActivities([activity]);
  const currentUserId = users.get('currentUserId');
  const isSelf = activity.actor.id === currentUserId;
  const formattedSpace = spacesList.get(space.id);

  switch (activity.verb) {
    case API_ACTIVITY_VERB.SHARE:
    case API_ACTIVITY_VERB.POST:
      {
        const otherParticipant = !!space.participants && typeof space.participants.find === 'function' && space.participants.find(p => p.id !== currentUserId);
        const otherParticipantId = otherParticipant && otherParticipant.id;
        const otherUser = users.getIn(['byId', otherParticipantId]); // Update space with newest post activity

        props.updateSpaceWithActivity(activity, isSelf, true); // Do not emit unread if current user created the message

        if (!isSelf && formattedSpace) {
          handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(formattedSpace, activity), props);
        } // Emit message:created event


        handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser), props);
        break;
      }

    case API_ACTIVITY_VERB.LOCK:
    case API_ACTIVITY_VERB.UNLOCK:
      {
        props.updateSpaceWithActivity(activity, isSelf);
        break;
      }

    case API_ACTIVITY_VERB.ACKNOWLEDGE:
      {
        if (isSelf && formattedSpace) {
          // update space with last acknowledgment if it's this user
          props.updateSpaceRead(activity.target.id, activity.published);
          handleEvent(eventNames.SPACES_READ, constructRoomsEventData(formattedSpace, activity), props);
        }

        break;
      }

    case API_ACTIVITY_VERB.CREATE:
      {
        const constructedActivity = Object.assign({}, activity, {
          target: activity.object,
          object: {
            id: activity.actor.id,
            emailAddress: activity.actor.emailAddress
          }
        });
        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(constructedActivity), props);
        break;
      }

    case API_ACTIVITY_VERB.ADD:
      {
        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity), props);
        break;
      }

    case API_ACTIVITY_VERB.LEAVE:
      {
        props.removeSpace(space.id);
        handleEvent(eventNames.MEMBERSHIPS_DELETED, constructMembershipEventData(activity), props);
        break;
      }

    case API_ACTIVITY_VERB.HIDE:
      {
        props.removeSpace(space.id);
        break;
      }

    case API_ACTIVITY_VERB.TAG:
      {
        props.addSpaceTags(space.id, activity.object.tags);
        break;
      }

    case API_ACTIVITY_VERB.UNTAG:
      {
        props.removeSpaceTags(space.id, activity.object.tags);
        break;
      }
  }
}
/**
 * Handles the initial processing of new activity coming in via websocket
 *
 * @param {Object} activity
 * @param {Object} props
 */


function handleNewActivity(activity, props) {
  const {
    sparkInstance,
    spacesById,
    users
  } = props;
  const space = activity.target || activity.object;
  let spaceId = space && space.id; // On delete, refetch space to get previous activity

  if (spaceId && ['delete', 'tombstone'].includes(activity.verb)) {
    props.fetchSpace(sparkInstance, space);
  } // Handle spaceId if this is a completely new space or hiding a space


  if (!spaceId && ['create', 'hide'].includes(activity.verb)) {
    spaceId = activity.object.id;
  }

  const cachedSpace = spacesById.get(spaceId);

  if (cachedSpace) {
    processActivity(activity, cachedSpace, props);
  } else {
    // go retrieve the space if it doesn't exist
    props.fetchSpace(sparkInstance, space).then(newSpace => {
      if (newSpace) {
        processActivity(activity, newSpace, props);
        getSpaceAvatar(newSpace, props); // Store user for 1:1 spaces

        if (newSpace.type === SPACE_TYPE_ONE_ON_ONE) {
          const toUser = getToParticipant(newSpace, users.get('currentUserId'));

          if (toUser) {
            props.storeUser(toUser);
          }
        }
      }
    });
  }
}

var listeners = compose(connect(getRecentsWidgetProps, dispatch => bindActionCreators({
  addSpaceTags,
  fetchAvatar,
  fetchSpace,
  removeSpace,
  removeSpaceTags,
  storeActivities,
  storeUser,
  updateSpaceRead,
  updateSpaceWithActivity,
  updateWidgetStatus
}, dispatch)), lifecycle({
  componentWillReceiveProps(nextProps) {
    const {
      users,
      sparkInstance,
      widgetStatus
    } = nextProps; // Listen for new conversation activity

    if (users.get('currentUserId') && !widgetStatus.isListeningForNewActivity) {
      nextProps.updateWidgetStatus({
        isListeningForNewActivity: true
      });
      sparkInstance.internal.mercury.on('event:conversation.activity', event => handleNewActivity(event.data.activity, this.props));
    }
  }

}));

const DEFAULT_SPACE_COUNT = 25;
/**
 * Store the "to" participant in a 1:1 convo
 * This user is needed in our store to calculate a space title
 *
 * @param {object} space
 * @param {object} props
 */

function storeToParticipant(space, props) {
  const {
    users
  } = props; // Store the to user in a direct convo to calculate space title

  if (space.type === SPACE_TYPE_ONE_ON_ONE) {
    // Find the participant that is not the current user
    const toPerson = getToParticipant(space, users.get('currentUserId'));

    if (toPerson) {
      props.storeUser(toPerson);
    }
  }
}
/**
 * Connects to the websocket server (mercury)
 * @param {object} props
 */


function connectWebsocket(props) {
  const {
    sparkInstance,
    mercuryStatus
  } = props;

  if (!mercuryStatus.hasConnected && !mercuryStatus.connecting && !mercuryStatus.connected && sparkInstance.internal.device.registered) {
    props.connectToMercury(sparkInstance);
  }
}
/**
 * Gets the user's feature flags
 *
 * @param {object} props
 */


function getFeatures(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props; // Initial fetching of group message notification feature

  if (!widgetStatus.hasFetchedGroupMessageNotificationFeature) {
    props.getFeature(FEATURES_USER, FEATURES_GROUP_MESSAGE_NOTIFICATIONS, sparkInstance).then(() => {
      props.updateWidgetStatus({
        hasFetchedGroupMessageNotificationFeature: true
      });
    });
  } // Initial Fetching of mention notification feature


  if (!widgetStatus.hasFetchedMentionNotificationFeature) {
    props.getFeature(FEATURES_USER, FEATURES_MENTION_NOTIFICATIONS, sparkInstance).then(() => {
      props.updateWidgetStatus({
        hasFetchedMentionNotificationFeature: true
      });
    });
  }
}
/**
 * Gets the user's teams
 *
 * @param {*} props
 */


function getTeams(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props; // Grab teams

  if (sparkInstance.internal.team && !widgetStatus.isFetchingTeams && !widgetStatus.hasFetchedTeams) {
    props.updateWidgetStatus({
      isFetchingTeams: true
    });
    props.fetchTeams(sparkInstance).then(() => {
      props.updateWidgetStatus({
        isFetchingTeams: false,
        hasFetchedTeams: true
      });
    });
  }
}
/**
 * Fetches the initial space list from services
 *
 * @param {object} props
 */


function getInitialSpaces(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props;
  const spaceLoadCount = props.spaceLoadCount > 0 ? props.spaceLoadCount : DEFAULT_SPACE_COUNT;

  if (!widgetStatus.isFetchingInitialSpaces && !widgetStatus.hasFetchedInitialSpaces) {
    props.updateWidgetStatus({
      isFetchingInitialSpaces: true
    });

    if (props.basicMode) {
      props.fetchSpacesHydra(sparkInstance, {
        max: spaceLoadCount
      }).then(() => props.updateWidgetStatus({
        hasFetchedInitialSpaces: true,
        // Basic mode doesn't have a second load state
        hasFetchedAllSpaces: true
      }));
    } else {
      /**
       * Fetches an encrypted small batch of spaces
       * This allows us to show the encrypted spaces in the spaces list
       * and decrypt individually to give a good initial user experience.
       */
      props.fetchSpacesEncrypted(sparkInstance, {
        conversationsLimit: spaceLoadCount
      }).then(encryptedSpaces => {
        props.updateWidgetStatus({
          hasFetchedInitialSpaces: true,
          // We don't currently have a second load state (pagination to come)
          hasFetchedAllSpaces: true
        }); // As the spaces decrypt, get the avatar for them

        const promises = encryptedSpaces.map(s => s.decryptPromise.then(decryptedSpace => {
          // Store the to user in a direct convo to calculate space title
          if (decryptedSpace.type === SPACE_TYPE_ONE_ON_ONE) {
            storeToParticipant(decryptedSpace, props);
          }

          return getSpaceAvatar(decryptedSpace, props);
        }));
        return Promise.all(promises);
      });
    }
  }
}
/**
 * Fetches the avatars for all the loaded spaces
 *
 * @param {object} props
 */


function getAvatars(props) {
  const {
    spacesList,
    widgetStatus
  } = props;

  if (!widgetStatus.hasFetchedAvatars && !widgetStatus.isFetchingAvatars) {
    props.updateWidgetStatus({
      isFetchingAvatars: true
    });
    spacesList.forEach(s => getSpaceAvatar(s, props));
    props.updateWidgetStatus({
      hasFetchedAvatars: true
    });
  }
}
/**
 * The main setup process that proceeds through a series of events
 * based on the state of the application.
 *
 * @export
 * @param {*} props
 */


function setup(props) {
  const {
    mercuryStatus,
    sparkInstance,
    sparkState,
    widgetStatus
  } = props; // We cannot do anything until the sdk is ready

  if (sparkInstance && sparkState.authenticated && sparkState.registered && !sparkState.hasError) {
    getFeatures(props);

    if (!mercuryStatus.connected) {
      connectWebsocket(props);
    } else {
      // Initial fetching workflow
      if (!widgetStatus.hasFetchedInitialSpaces) {
        getInitialSpaces(props);
      } else if (!widgetStatus.hasFetchedAvatars && !props.basicMode) {
        // All spaces have been fetched, load avatars
        getAvatars(props);
      } // Synchronous load of teams (smaller request)


      if (!widgetStatus.hasFetchedTeams) {
        getTeams(props);
      }
    }
  }
}
var setup$1 = compose(connect(getRecentsWidgetProps, dispatch => bindActionCreators({
  connectToMercury,
  fetchAvatar,
  fetchSpaces,
  fetchSpacesEncrypted,
  fetchSpacesHydra,
  fetchTeams,
  getFeature,
  storeUser,
  updateWidgetStatus
}, dispatch)), lifecycle({
  componentWillMount() {
    setup(this.props);
  },

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  },

  componentWillReceiveProps(nextProps) {
    setup(nextProps, this.props);
  }

}));

var enhancers = [setup$1, errors, listeners];

var css_248z$1 = ".widget-recents__recentsWidget__LnJlY2Vu {\n  display: flex;\n  height: 100%;\n  flex-direction: column;\n\n  /* IE 11 scrollbar styling workarounds */\n  scrollbar-face-color: #8a8a8a;\n  scrollbar-shadow-color:black;\n  scrollbar-track-color: black;\n  scrollbar-shadow-color: black;\n}\n\n.widget-recents__spacesListWrapper__LnJlY2Vu {\n  height: 100%;\n  width: 100%;\n  overflow: auto;\n  font-size: 16px;\n  background: #fff;\n}\n\n.widget-recents__errorWrapper__LnJlY2Vu {\n  position: absolute;\n  z-index: 1000;\n  width: 100%;\n  height: 100%;\n}\n\n.widget-recents__loadMoreContainer__LnJlY2Vu {\n  display: flex;\n  justify-content: center;\n  padding: 10px 0;\n}\n\n.widget-recents__loadMoreButton__LnJlY2Vu {\n  height: 36px;\n  min-width: 64.8px;\n  padding: 0 36px;\n  font-size: 14px;\n  line-height: 24px;\n  line-height: normal;\n  letter-spacing: 0.3px;\n  color: #fff;\n  cursor: pointer;\n  background: #07c1e4;\n  border: 1px #07c1e4;\n  border-radius: 4px;\n}\n\n.widget-recents__midDot__LnJlY2Vu::after {\n  padding: 0 3px;\n  content: '\\B7';\n}\n";
var styles = {"recentsWidget":"widget-recents__recentsWidget__LnJlY2Vu","spacesListWrapper":"widget-recents__spacesListWrapper__LnJlY2Vu","errorWrapper":"widget-recents__errorWrapper__LnJlY2Vu","loadMoreContainer":"widget-recents__loadMoreContainer__LnJlY2Vu","loadMoreButton":"widget-recents__loadMoreButton__LnJlY2Vu","midDot":"widget-recents__midDot__LnJlY2Vu"};
styleInject(css_248z$1);

var css_248z = "$brand-font-folder: \"~@momentum-ui/core/fonts\";\n$icon-font-path: \"~@momentum-ui/icons/fonts\";\n\n@import '~@momentum-ui/core/scss/momentum-ui-components';\n";
styleInject(css_248z);

var _class;
const injectedPropTypes = {
  currentUser: PropTypes.object,
  currentUserAvatar: PropTypes.object,
  errors: PropTypes.object.isRequired,
  incomingCall: PropTypes.object,
  media: PropTypes.object.isRequired,
  mercuryStatus: PropTypes.object.isRequired,
  spacesById: PropTypes.object.isRequired,
  spacesList: PropTypes.object.isRequired,
  spacesListArray: PropTypes.array.isRequired,
  sparkInstance: PropTypes.object,
  sparkState: PropTypes.object.isRequired,
  users: PropTypes.object.isRequired,
  teams: PropTypes.object.isRequired,
  widgetRecents: PropTypes.object.isRequired,
  widgetStatus: PropTypes.object.isRequired,
  addError: PropTypes.func.isRequired,
  features: PropTypes.object.isRequired,
  keywordFilter: PropTypes.string,
  fetchAvatar: PropTypes.func.isRequired,
  fetchSpace: PropTypes.func.isRequired,
  getFeature: PropTypes.func.isRequired,
  removeSpace: PropTypes.func.isRequired,
  updateSpaceRead: PropTypes.func.isRequired,
  updateSpaceWithActivity: PropTypes.func.isRequired,
  updateSpaceKeywordFilter: PropTypes.func.isRequired,
  updateWidgetStatus: PropTypes.func.isRequired
};
const ownPropTypes = {
  basicMode: PropTypes.bool,
  enableAddButton: PropTypes.bool,
  enableSpaceListFilter: PropTypes.bool,
  enableUserProfile: PropTypes.bool,
  enableUserProfileMenu: PropTypes.bool,
  muteNotifications: PropTypes.bool,
  spaceLoadCount: PropTypes.number
};
const defaultProps = {
  basicMode: false,
  enableAddButton: false,
  enableUserProfile: true,
  enableUserProfileMenu: false,
  enableSpaceListFilter: true,
  spaceLoadCount: 25
};
let RecentsWidget = (_class = class RecentsWidget extends Component {
  componentWillReceiveProps(nextProps) {
    this.addListeners(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.spacesList !== this.props.spacesList || nextProps.errors !== this.props.errors || nextProps.widgetRecents !== this.props.widgetRecents || nextProps.incomingCall !== this.props.incomingCall;
  }

  getSpaceFromCall(call) {
    if (call.instance.locus && call.instance.locus.conversationUrl) {
      return this.props.spacesById.get(call.instance.locus.conversationUrl.split('/').pop());
    }

    return '';
  }

  addListeners(nextProps) {
    const {
      incomingCall
    } = nextProps;

    if (incomingCall && !this.props.incomingCall) {
      this.handleCall(incomingCall.instance);
    }
  }

  handleCall(call) {
    const {
      props,
      handleEvent
    } = this;
    const {
      spacesById
    } = props;
    let space;

    if (has(call, 'locus.conversationUrl')) {
      space = spacesById.get(call.locus.conversationUrl.split('/').pop());
    } else {
      // We don't know anything about this space for this call
      space = {
        id: call.id
      };
    }

    handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
  }

  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }

  handleAddClick() {
    this.handleEvent(eventNames.ADD_CLICKED, {});
  }

  handleListScroll({
    scrollTop
  }) {
    const isScrolledToTop = scrollTop === 0;

    if (isScrolledToTop !== this.props.widgetStatus.isScrolledToTop) {
      this.props.updateWidgetStatus({
        isScrolledToTop
      });
    }
  }

  handleProfileClick() {
    const {
      currentUserWithAvatar
    } = this.props;
    this.handleEvent(eventNames.PROFILE_CLICKED, currentUserWithAvatar);
  }

  handleSignOutClick() {
    this.handleEvent(eventNames.USER_SIGNOUT_CLICKED, {});
  }
  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undefined}
   */


  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    const logData = Object.assign({}, data); // Omit call objet from logger to prevent call range error

    if (data.call) {
      logData.call = '--- OMITTED ---';
    }

    sparkInstance.logger.info(`event handler - ${name}`, logData);

    if (typeof onEvent === 'function') {
      this.props.onEvent(name, data);
    }
  }

  handleSpaceFilterInput(event) {
    const {
      props
    } = this;
    const keyword = event.target.value;
    props.updateSpaceKeywordFilter(keyword);
  }

  render() {
    const {
      props
    } = this;
    const {
      enableAddButton,
      enableSpaceListFilter,
      enableUserProfile,
      enableUserProfileMenu,
      errors,
      features,
      keywordFilter,
      spacesListArray,
      currentUser,
      currentUserWithAvatar,
      widgetStatus
    } = props;
    const {
      formatMessage
    } = props.intl;
    let displaySubtitle, displayTitle, temporary, widgetError; // Recents widget is ready once we have some spaces or a search causing spaces to be empty

    const isFiltered = keywordFilter && keywordFilter.length;
    const isReady = widgetStatus.hasFetchedInitialSpaces || isFiltered; // Recents widget is loading more until it has fetched all spaces

    const isLoadingMore = !widgetStatus.hasFetchedAllSpaces; // Display the header if any of these options are true, otherwise, hide header.

    const showHeader = enableSpaceListFilter || enableAddButton || enableUserProfile;
    const hasSpaces = widgetStatus.hasFetchedInitialSpaces && spacesListArray.length > 0;
    const emptyMessage = !hasSpaces && enableAddButton ? formatMessage(messages$1.createSpacePlus) : formatMessage(messages$1.createSpaceTeams);

    if (errors.get('hasError')) {
      widgetError = errors.get('errors').first();
      ({
        displayTitle,
        displaySubtitle,
        temporary
      } = widgetError);
    }

    if (isReady) {
      return /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-recents-widget', 'md', styles.recentsWidget)
      }, errors.get('hasError') && /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-error-wrapper', styles.errorWrapper)
      }, /*#__PURE__*/React.createElement(ErrorDisplay, {
        secondaryTitle: displaySubtitle,
        title: displayTitle,
        transparent: temporary
      })), showHeader && /*#__PURE__*/React.createElement(RecentsHeader, {
        currentUserWithAvatar: currentUserWithAvatar,
        enableAddButton: enableAddButton,
        enableSpaceListFilter: enableSpaceListFilter,
        enableUserProfile: enableUserProfile,
        enableUserProfileMenu: enableUserProfileMenu,
        hideBottomBorder: widgetStatus.isScrolledToTop,
        onAddClick: this.handleAddClick,
        onFilterChange: this.handleSpaceFilterInput,
        onProfileClick: this.handleProfileClick,
        onSignOutClick: this.handleSignOutClick
      }), hasSpaces && /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-spaces-list-wrapper', styles.spacesListWrapper)
      }, /*#__PURE__*/React.createElement(SpacesList, {
        currentUser: currentUser,
        features: features,
        formatMessage: formatMessage,
        hasCalling: true,
        isLoadingMore: isLoadingMore,
        onCallClick: this.handleSpaceCallClick,
        onClick: this.handleSpaceClick,
        onScroll: this.handleListScroll,
        spaces: spacesListArray,
        searchTerm: typeof keywordFilter === 'string' ? keywordFilter : ''
      })), !hasSpaces && /*#__PURE__*/React.createElement(NoSpaces, {
        title: formatMessage(messages$1.noSpaces),
        emptyMessage: emptyMessage
      }));
    }

    if (errors.get('hasError')) {
      return /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-recents-widget', 'md', styles.recentsWidget)
      }, /*#__PURE__*/React.createElement(ErrorDisplay, {
        secondaryTitle: displaySubtitle,
        title: displayTitle,
        transparent: temporary
      }));
    }

    return /*#__PURE__*/React.createElement("div", {
      className: classNames('webex-recents-widget', 'md', styles.recentsWidget)
    }, /*#__PURE__*/React.createElement(LoadingScreen, null));
  }

}, (_applyDecoratedDescriptor(_class.prototype, "getSpaceFromCall", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "getSpaceFromCall"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "addListeners", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "addListeners"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleCall", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleCall"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleSpaceClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleSpaceClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleSpaceCallClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleSpaceCallClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleAddClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleAddClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleListScroll", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleListScroll"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleProfileClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleProfileClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleSignOutClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleSignOutClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleEvent", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleEvent"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleSpaceFilterInput", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleSpaceFilterInput"), _class.prototype)), _class);
RecentsWidget.propTypes = { ...injectedPropTypes,
  ...ownPropTypes
};
RecentsWidget.defaultProps = { ...defaultProps
};
var ConnectedRecents = compose(connect(getRecentsWidgetProps, dispatch => bindActionCreators({
  fetchSpace,
  getFeature,
  removeSpace,
  updateSpaceRead,
  updateSpaceWithActivity,
  storeActivities,
  updateSpaceKeywordFilter,
  updateWidgetStatus
}, dispatch)), ...enhancers, enhancer)(RecentsWidget);

var messages = {};

var index = compose(constructWebexEnhancer({
  name: 'recents',
  reducers
}), enhancer$1, enhancer, withIntl({
  locale: 'en',
  messages
}))(ConnectedRecents);

export default index;
export { reducers };
//# sourceMappingURL=index.js.map
