import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import { saveAs } from 'file-saver';
import { autobind } from 'core-decorators';
import { getDisplayName, bufferToBlob } from '@webex/react-component-utils';
import { retrieveSharedFile } from '@webex/redux-module-share';
import { createSelector } from 'reselect';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

const getSpark = (state, ownProps) => ownProps.sparkInstance || state.spark.get('spark');

const getShare = state => state.share;

const getContainerProps = createSelector([getSpark, getShare], (spark, share) => ({
  share,
  spark
}));

// TODO: Rename this project to react-hoc-file-downloader

function injectFileDownloader(WrappedComponent) {
  var _class;

  const injectedPropTypes = {
    share: PropTypes.object.isRequired,
    spark: PropTypes.object.isRequired,
    retrieveSharedFile: PropTypes.func.isRequired
  };
  const propTypes = {
    files: PropTypes.array,
    ...injectedPropTypes
  };
  const defaultProps = {
    files: []
  };
  let FileDownloader = (_class = class FileDownloader extends Component {
    componentDidMount() {
      const {
        files
      } = this.props;
      files.forEach(file => {
        this.getThumbnailImage(file);
      });
    }

    getSharedFileFromStore(fileUrl) {
      const {
        props
      } = this;
      return props.share.get(['files', fileUrl]);
    }

    getThumbnailImage(fileObject) {
      const {
        image
      } = fileObject;

      if (fileObject.mimeType === 'image/gif' && fileObject.url) {
        this.retrieveFile(fileObject);
      } else if (image && (image.url && !this.getSharedFileFromStore(image.url) || image.scr)) {
        this.retrieveFile(image);
      }
    }

    retrieveFile(file) {
      const {
        props
      } = this;
      props.retrieveSharedFile(file, props.spark);
    }

    handleDownloadClick(fileObject) {
      const {
        props
      } = this;
      const cachedFile = this.getSharedFileFromStore(fileObject.url);

      if (cachedFile && cachedFile.blob) {
        saveAs(cachedFile.blob, fileObject.displayName);
      } else {
        props.retrieveSharedFile(fileObject, props.spark).then(file => {
          const {
            blob
          } = bufferToBlob(file);
          saveAs(blob, file.name);
        });
      }
    }

    render() {
      return /*#__PURE__*/React.createElement(WrappedComponent, _extends({
        onDownloadClick: this.handleDownloadClick
      }, this.props));
    }

  }, (_applyDecoratedDescriptor(_class.prototype, "getSharedFileFromStore", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "getSharedFileFromStore"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "retrieveFile", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "retrieveFile"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleDownloadClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleDownloadClick"), _class.prototype)), _class);
  FileDownloader.propTypes = propTypes;
  FileDownloader.defaultProps = defaultProps;
  FileDownloader.displayName = `FileDownloader(${getDisplayName(WrappedComponent)})`;
  FileDownloader.WrappedComponent = WrappedComponent;
  return connect(getContainerProps, dispatch => bindActionCreators({
    retrieveSharedFile
  }, dispatch))(FileDownloader);
}

export default injectFileDownloader;
//# sourceMappingURL=index.js.map
