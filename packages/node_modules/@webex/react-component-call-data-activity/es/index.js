import React from 'react';
import PropTypes from 'prop-types';
import { defineMessages, FormattedMessage } from 'react-intl';
import moment from 'moment';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var messages = defineMessages({
  someoneWasUnavailable: {
    id: 'ciscospark.callDataActivity.message.someoneWasUnavailable',
    defaultMessage: '{name} was unavailable.'
  },
  youCancelledACall: {
    id: 'ciscospark.callDataActivity.message.youCancelledACall',
    defaultMessage: 'You cancelled a call.'
  },
  someoneCancelledACall: {
    id: 'ciscospark.callDataActivity.message.someoneCancelledACall',
    defaultMessage: '{name} cancelled a call.'
  },
  youHadACall: {
    id: 'ciscospark.callDataActivity.message.youHadACall',
    defaultMessage: 'You had a call ({duration})'
  },
  youMissedACall: {
    id: 'ciscospark.callDataActivity.message.youMissedACall',
    defaultMessage: 'You missed a call.'
  },
  youHadAMeeting: {
    id: 'ciscospark.callDataActivity.message.youHadAMeeting',
    defaultMessage: 'You had a meeting ({duration})'
  },
  nobodyJoinedYourMeeting: {
    id: 'ciscospark.callDataActivity.message.nobodyJoinedYourMeeting',
    defaultMessage: 'You started a meeting but no one was available.'
  },
  nobodyJoinedTheMeeting: {
    id: 'ciscospark.callDataActivity.message.nobodyJoinedTheMeeting',
    defaultMessage: '{name} cancelled a meeting.'
  },
  youMissedAMeeting: {
    id: 'ciscospark.callDataActivity.message.youMissedAMeeting',
    defaultMessage: 'You missed a meeting ({duration})'
  }
});

function getCallDataOneOnOne({
  everyBodyJoined,
  iDeclined,
  actorWasMe,
  partner = {
    person: {
      displayName: ''
    }
  },
  partnerDeclined
}) {
  let arg, status;

  if (everyBodyJoined) {
    status = 'youHadACall';
  } // One on One Call
  else if (iDeclined) {
      status = 'youCancelledACall';
    } else if (partnerDeclined) {
      status = 'someoneCancelledACall';
      arg = {
        name: partner.person.displayName
      };
    } else if (actorWasMe) {
      status = 'someoneWasUnavailable';
      arg = {
        name: partner.person.displayName
      };
    } else {
      status = 'youMissedACall';
    }

  return {
    arg,
    status
  };
}

function getCallDataGroup({
  iWasJoined,
  noBodyJoined,
  actorWasMe,
  actor = {
    displayName: ''
  }
}) {
  let arg, status;

  if (iWasJoined && !noBodyJoined) {
    status = 'youHadAMeeting';
  } else if (noBodyJoined) {
    if (actorWasMe) {
      status = 'nobodyJoinedYourMeeting';
    } else {
      status = 'nobodyJoinedTheMeeting';
    }

    arg = {
      name: actor.displayName
    };
  } else {
    status = 'youMissedAMeeting';
  }

  return {
    arg,
    status
  };
}
/**
 * Parses call data from an activity
 * @param {object} callData
 * @param {object} callData.actor
 * @param {number} callData.duration
 * @param {boolean} callData.isGroupCall
 * @param {array} callData.participants
 * @param {object} currentUser
 * @returns {object}
 */


function parseActivityCallData(callData, currentUser) {
  const {
    actor = {
      displayName: ''
    },
    duration,
    isGroupCall,
    participants
  } = callData; // Call/Meeting update parsing

  const partner = participants.find(p => p.person.entryUUID !== currentUser.id);
  const me = participants.find(p => p.person.entryUUID === currentUser.id);
  const iWasJoined = me && me.state === 'LEFT';
  const iDeclined = me && me.state === 'DECLINED';
  const partnerDeclined = partner && partner.state === 'DECLINED';
  const everyBodyJoined = participants.every(p => p.state === 'LEFT');
  const callees = participants.filter(p => !p.isInitiator);
  const noBodyJoined = callees.every(p => p.state !== 'LEFT');
  const actorWasMe = actor && actor.id === currentUser.id;
  const {
    arg,
    status
  } = isGroupCall ? getCallDataGroup({
    iWasJoined,
    noBodyJoined,
    actorWasMe,
    actor
  }) : getCallDataOneOnOne({
    everyBodyJoined,
    iDeclined,
    actorWasMe,
    partner,
    partnerDeclined
  }); // Duration

  const humanizedDuration = moment.duration((duration || 0) * 1000).humanize();
  return {
    callInfo: {
      duration: humanizedDuration,
      ...arg
    },
    status
  };
}

const propTypes = {
  actor: PropTypes.shape({
    displayName: PropTypes.string.isRequired
  }),
  duration: PropTypes.number.isRequired,
  isGroupCall: PropTypes.bool.isRequired,
  participants: PropTypes.arrayOf(PropTypes.shape({
    isInitiator: PropTypes.bool,
    person: PropTypes.shape({
      entryUUID: PropTypes.string
    }),
    state: PropTypes.string
  })).isRequired,
  currentUser: PropTypes.shape({
    id: PropTypes.string.isRequired
  }).isRequired
};
const defaultProps = {
  actor: {
    displayName: ''
  }
};

const CallDataActivityMessage = props => {
  const {
    actor,
    duration,
    isGroupCall,
    participants,
    currentUser
  } = props;
  const callData = {
    actor,
    duration,
    isGroupCall,
    participants
  };
  const parsedCallData = parseActivityCallData(callData, currentUser);
  return parsedCallData && /*#__PURE__*/React.createElement(FormattedMessage, _extends({}, messages[parsedCallData.status], {
    values: { ...parsedCallData.callInfo
    }
  }));
};

CallDataActivityMessage.propTypes = propTypes;
CallDataActivityMessage.defaultProps = defaultProps;

export default CallDataActivityMessage;
//# sourceMappingURL=index.js.map
