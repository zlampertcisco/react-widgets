import { addAvatar, convertToSmallAvatar } from '@webex/redux-module-avatar';
import { subscribeToPresenceUpdates } from '@webex/redux-module-presence';
import { deconstructHydraId, validateAndDecodeId } from '@webex/react-component-utils';
import { Record, fromJS } from 'immutable';

function constructUserFromParticipant(user) {
  return {
    id: user.id,
    displayName: user.displayName,
    nickName: user.displayName ? user.displayName.split(' ')[0] : '',
    email: user.emailAddress,
    orgId: user.orgId,
    status: {
      isFetching: false
    }
  };
}
function constructUserFromHydra(user) {
  if (user) {
    return {
      id: deconstructHydraId(user.id).id,
      displayName: user.displayName,
      nickName: user.nickName,
      email: user.emails[0],
      orgId: deconstructHydraId(user.orgId).id,
      status: {
        isFetching: false
      }
    };
  }

  return {};
}
function constructUser(user) {
  if (user && user.nickName || user.emails) {
    return constructUserFromHydra(user);
  }

  return constructUserFromParticipant(user);
}
function constructCurrentUser(user) {
  return {
    id: user.id,
    displayName: user.name,
    nickName: user.givenName,
    email: user.email,
    orgId: user.orgId,
    status: {
      isFetching: false
    }
  };
}

const STORE_USER = 'users/STORE_USER';
const STORE_USERS = 'users/STORE_USERS';
const FETCH_USER_REQUEST = 'users/FETCH_USER_REQUEST';
const STORE_CURRENT_USER_ID = 'users/STORE_CURRENT_USER_ID';
const STORE_CURRENT_USER = 'users/STORE_CURRENT_USER';
const FETCH_CURRENT_USER_REQUEST = 'users/FETCH_CURRENT_USER_REQUEST';
const PENDING_STATUS = 'PENDING';

function fetchUserRequest({
  email,
  id
}) {
  return {
    type: FETCH_USER_REQUEST,
    payload: {
      email,
      id
    }
  };
}

function storeUser(user) {
  return {
    type: STORE_USER,
    payload: {
      user: constructUser(user)
    }
  };
}
function storeUsers(users) {
  return {
    type: STORE_USERS,
    payload: {
      users: users.map(u => constructUser(u))
    }
  };
}

function fetchCurrentUserRequest(id) {
  return {
    type: FETCH_CURRENT_USER_REQUEST,
    payload: {
      id
    }
  };
}

function storeCurrentUser(user) {
  return {
    type: STORE_CURRENT_USER,
    payload: {
      user: constructCurrentUser(user)
    }
  };
}

function storeCurrentUserId(id) {
  return {
    type: STORE_CURRENT_USER_ID,
    payload: {
      id
    }
  };
}
/**
 * Retrieves the current user using internal APIs
 * @param {Object} sparkInstance
 * @returns {Function}
 */


function fetchCurrentUser(sparkInstance) {
  return (dispatch, getState) => {
    const {
      users
    } = getState(); // Check for stored current User

    let userId = users.get('currentUserId');

    if (!sparkInstance) {
      return Promise.reject(new Error('spark instance is required to fetch current user'));
    } // Get userId from device registration


    if (!userId) {
      if (sparkInstance.internal.device && sparkInstance.internal.device.userId) {
        ({
          userId
        } = sparkInstance.internal.device);
        dispatch(storeCurrentUserId(userId));
      } else {
        return Promise.reject(new Error('cannot retrieve current user. spark device is not registered.'));
      }
    }

    if (userId) {
      const currentUser = users.getIn(['byId', userId]);

      if (currentUser) {
        return Promise.resolve(currentUser);
      }
    }

    dispatch(fetchCurrentUserRequest(userId));
    dispatch(subscribeToPresenceUpdates([userId], sparkInstance));
    return sparkInstance.internal.user.get().then(user => {
      dispatch(storeCurrentUser(user));

      if (user.photos && user.photos[0] && user.photos[0].url) {
        const {
          id: personId
        } = validateAndDecodeId(userId);
        dispatch(addAvatar(personId, convertToSmallAvatar(user.photos[0].url)));
      }

      return Promise.resolve(user);
    });
  };
}
/**
 * Performs an API call to fetch and store user details
 * @param {Object} user
 * @param {String} user.email
 * @param {String} user.id
 * @param {Object} sparkInstance
 * @returns {Function}
 */

function fetchUser({
  email,
  id
}, sparkInstance) {
  return dispatch => {
    if (!sparkInstance) {
      return Promise.reject(new Error('spark instance is required to fetch users'));
    }

    const handleResponse = person => {
      dispatch(storeUser(person));
      const {
        id: personId
      } = validateAndDecodeId(person.id);
      dispatch(addAvatar(personId, convertToSmallAvatar(person.avatar)));
      return Promise.resolve(person);
    };

    if (email) {
      return sparkInstance.people.list({
        email
      }).then(res => res.items[0]).then(handleResponse);
    }

    if (id) {
      return sparkInstance.people.get(id).then(handleResponse);
    }

    return Promise.reject(new Error('user email or id is required'));
  };
}
/**
 * Retrieves user from store or makes an API call if it doesn't exist
 * @param {Object} user
 * @param {String} user.email
 * @param {String} user.id
 * @param {Object} sparkInstance
 * @returns {Function}
 */

function getUser({
  email,
  id
}, sparkInstance) {
  return (dispatch, getState) => {
    // Check if we've fetched or already fetched this user
    const {
      users
    } = getState();
    const userId = validateAndDecodeId(id).id || users.getIn(['byEmail', email]);

    if (userId) {
      const user = users.getIn(['byId', userId]); // If we've already fetched this user

      if (user) {
        // If we haven't finished getting the user
        if (user.status.isFetching) {
          return Promise.resolve();
        }

        return Promise.resolve(user);
      }
    } // Initiate an API call to get user


    dispatch(fetchUserRequest({
      email,
      id: userId
    }));
    return dispatch(fetchUser({
      email,
      id: userId
    }, sparkInstance));
  };
}

const Status = new Record({
  isFetching: false
});
const User = new Record({
  id: undefined,
  displayName: '',
  nickName: '',
  email: '',
  orgId: '',
  status: new Status()
});
const initialState = fromJS({
  currentUserId: null,
  byId: {},
  byEmail: {}
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case STORE_USER:
      {
        const {
          user
        } = action.payload;
        return state.setIn(['byId', user.id], new User(user)).setIn(['byEmail', user.email], user.id);
      }

    case STORE_USERS:
      {
        const users = {};
        const emails = {};
        action.payload.users.forEach(u => {
          users[u.id] = new User(u);
          emails[u.email] = u.id;
        });
        return state.mergeIn(['byId'], users).mergeIn(['byEmail'], emails);
      }

    case STORE_CURRENT_USER:
      {
        const {
          user
        } = action.payload;
        return state.set('currentUserId', user.id).setIn(['byId', user.id], new User(user)).setIn(['byEmail', user.email], user.id);
      }

    case FETCH_USER_REQUEST:
      {
        const {
          email,
          id
        } = action.payload;
        let newState = state;

        if (id) {
          newState = newState.setIn(['byId', id], new User({
            status: {
              isFetching: true
            }
          }));
        } else if (email) {
          newState = newState.setIn(['byEmail', email], id || PENDING_STATUS);
        }

        return newState;
      }

    case FETCH_CURRENT_USER_REQUEST:
      {
        const {
          id
        } = action.payload;
        return state.set('currentUserId', id).setIn(['byId', id], new User({
          status: {
            isFetching: true
          }
        }));
      }

    default:
      return state;
  }
}
const records = {
  Status,
  User
};

export default reducer;
export { FETCH_CURRENT_USER_REQUEST, FETCH_USER_REQUEST, PENDING_STATUS, STORE_CURRENT_USER, STORE_CURRENT_USER_ID, STORE_USER, STORE_USERS, fetchCurrentUser, fetchUser, getUser, initialState, records, storeUser, storeUsers };
//# sourceMappingURL=index.js.map
