import { compose } from 'recompose';
import { constructWebexEnhancer, withIntl } from '@webex/webex-widget-base';
import { fromJS } from 'immutable';
import { combineReducers, bindActionCreators } from 'redux';
import avatar, { fetchAvatarsForUsers } from '@webex/redux-module-avatar';
import conversation, { addParticipantToConversation, removeParticipantFromConversation } from '@webex/redux-module-conversation';
import users from '@webex/redux-module-users';
import search, { searchForUser } from '@webex/redux-module-search';
import media from '@webex/redux-module-media';
import spark from '@webex/react-redux-spark';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import classNames from 'classnames';
import { autobind } from 'core-decorators';
import { has, concat, debounce } from 'lodash';
import isEmail from 'validator/lib/isEmail';
import LoadingScreen from '@webex/react-component-loading-screen';
import wrapConversationMercury from '@webex/react-hoc-conversation-mercury';
import PeopleList from '@webex/react-component-people-list';
import ActivityMenuHeader from '@webex/react-component-activity-menu-header';
import { Spinner, Icon, Button, Input } from '@momentum-ui/react';
import { createSelector } from 'reselect';
import { defineMessages } from 'react-intl';

const VIEW_MAIN = 'VIEW_MAIN';
const VIEW_ADD = 'VIEW_ADD';
const UPDATE_WIDGET_STATE = 'widget-roster/UPDATE_WIDGET_STATE';
function updateWidgetState(state) {
  return {
    type: UPDATE_WIDGET_STATE,
    payload: {
      state
    }
  };
}
/**
 * Sets the widget view to the main roster view
 * @returns {Object}
 */

function setWidgetViewMain() {
  return updateWidgetState({
    currentView: VIEW_MAIN
  });
}
/**
 * Sets the widget view to the add participant view
 * @returns {Object}
 */

function setWidgetViewAdd() {
  return updateWidgetState({
    currentView: VIEW_ADD
  });
}
/**
 * Sets the current search term
 * @param {string} searchTerm
 * @returns {Object}
 */

function setSearchTerm(searchTerm) {
  return updateWidgetState({
    searchTerm
  });
}

const initialState = fromJS({
  currentView: VIEW_MAIN,
  searchTerm: ''
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case UPDATE_WIDGET_STATE:
      return state.merge(fromJS(action.payload.state));

    default:
      return state;
  }
}
const reducers = {
  avatar,
  conversation,
  users,
  spark,
  search,
  media,
  widgetRoster: reducer
};
combineReducers(reducers);

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

/*
 * WidgetRoster Messages
 *
 * This contains all the text for the Roster component.
 */
var messages$1 = defineMessages({
  addPeople: {
    id: 'ciscospark.container.roster.message.addPeople',
    defaultMessage: 'Add people'
  },
  addPlaceholder: {
    id: 'ciscospark.container.roster.message.addPeople.placeholder',
    defaultMessage: 'Who are you looking for?'
  },
  cancelDetails: {
    id: 'ciscospark.container.roster.message.cancelDetails',
    defaultMessage: 'Cancel'
  },
  removeParticipant: {
    id: 'ciscospark.container.roster.message.removeParticipant',
    defaultMessage: 'Remove'
  },
  noResults: {
    id: 'ciscospark.container.roster.message.addPeople.noResults',
    defaultMessage: 'No Results'
  },
  externalParticipants: {
    id: 'ciscospark.container.roster.message.externalParticipants',
    defaultMessage: 'People outside your company are included in this space'
  },
  moderators: {
    id: 'ciscospark.container.roster.title.moderators',
    defaultMessage: 'Moderators'
  },
  participants: {
    id: 'ciscospark.container.roster.title.participants',
    defaultMessage: 'Participants'
  },
  inMeeting: {
    id: 'ciscospark.container.roster.title.inMeeting',
    defaultMessage: 'In Meeting'
  },
  notInMeeting: {
    id: 'ciscospark.container.roster.title.notInMeeting',
    defaultMessage: 'Not in Meeting'
  }
});

const getSparkInstance = (state, props) => props.sparkInstance || state.spark.get('spark');

const getConversation = state => state.conversation;

const getCurrentUser = state => state.users.getIn(['byId', state.users.get('currentUserId')]);

const getSearch = state => state.search;

const getMedia = state => state.media;

const getWidget = state => state.widgetRoster;

const getFormatMessage = (state, props) => props.intl.formatMessage;

function sortParticipants(participantA, participantB) {
  const A = participantA.displayName;
  const B = participantB.displayName;
  const aGreaterThanB = A > B ? 1 : 0;
  return A < B ? -1 : aGreaterThanB;
}

const getCurrentCall = createSelector([getMedia, getConversation], (media, conversation) => {
  const locusUrl = conversation.get('locusUrl');

  if (locusUrl) {
    return media.getIn(['byId', media.getIn(['byLocusUrl', locusUrl])]);
  }

  return undefined;
});
const getSearchResults = createSelector([getSearch, getWidget, getCurrentUser], (search, widgetRoster, currentUser) => {
  const searchTerm = widgetRoster.get('searchTerm');

  if (searchTerm && search.hasIn(['searchResults', searchTerm])) {
    const searchResults = search.getIn(['searchResults', searchTerm]).toJS();
    const results = [];

    if (searchResults.results) {
      searchResults.results.forEach(user => {
        if (user.id !== currentUser.id) {
          results.push(user);
        }
      });
      searchResults.results = results;
    }

    return searchResults;
  }

  return undefined;
});
const getParticipantsById = createSelector([getConversation, getCurrentUser], (conversation, currentUser) => {
  const participantsList = conversation.get('participants');
  const inFlightParticipants = conversation.get('inFlightParticipants').toJS();
  const isConsumerOrg = currentUser.orgId === 'consumer';
  const participantsById = {};
  participantsList.forEach(p => {
    const participant = p.toJS();
    participant.isExternal = currentUser && !isConsumerOrg && currentUser.orgId !== 'consumer' && currentUser.orgId !== participant.orgId;
    participant.displayName = participant.displayName ? participant.displayName : participant.name;
    participant.isPending = has(inFlightParticipants, ['removing', participant.id]) || has(inFlightParticipants, ['adding', participant.id]);
    participantsById[participant.id] = participant;
  });
  return participantsById;
});
const getParticipants = createSelector([getConversation, getParticipantsById, getCurrentUser, getCurrentCall, getFormatMessage], (conversation, participantsById, currentUser, currentCall, formatMessage) => {
  const people = [];
  let hasExternalParticipants = false;
  let count = 0;

  if (currentCall && currentCall.getIn(['callState', 'connected'])) {
    const callMemberships = currentCall.get('instance').memberships;
    const inMeeting = [];
    const notInMeeting = [];
    callMemberships.forEach(m => {
      const participant = participantsById[m.personUuid];

      if (participant) {
        if (m.state === 'connected') {
          inMeeting.push(participant);
        } else {
          notInMeeting.push(participant);
        }
      }
    });

    if (inMeeting.length > 0) {
      people.push({
        label: formatMessage(messages$1.inMeeting),
        people: inMeeting
      });
    }

    if (notInMeeting.length > 0) {
      people.push({
        label: formatMessage(messages$1.notInMeeting),
        people: notInMeeting
      });
    }
  } else {
    const currentUserParticipant = [];
    const moderatorParticipants = [];
    let otherParticipants = [];
    const inFlightParticipantsAdding = conversation.getIn(['inFlightParticipants', 'adding']).toArray();
    Object.keys(participantsById).forEach(id => {
      const p = participantsById[id];

      if (p.isExternal) {
        hasExternalParticipants = true;
      }

      if (p.roomProperties && p.roomProperties.isModerator) {
        moderatorParticipants.push(p);
      } else if (p.id === currentUser.id) {
        currentUserParticipant.push(p);
      } else {
        otherParticipants.push(p);
      }

      count += 1;
    }); // Add inflight adding participants to other participants

    otherParticipants = concat(currentUserParticipant.sort(sortParticipants), otherParticipants.sort(sortParticipants), inFlightParticipantsAdding);

    if (moderatorParticipants.length > 0) {
      people.push({
        label: formatMessage(messages$1.moderators),
        people: moderatorParticipants
      });
    }

    if (otherParticipants.length > 0) {
      people.push({
        label: formatMessage(messages$1.participants),
        people: otherParticipants
      });
    }
  }

  return {
    hasExternalParticipants,
    count,
    people
  };
});
const getRosterWidgetProps = createSelector([getSparkInstance, getConversation, getCurrentUser, getSearchResults, getWidget, getParticipants], (sparkInstance, conversation, currentUser, searchResults, widgetRoster, participants) => {
  const isOneOnOne = conversation.getIn(['status', 'isOneOnOne']);
  const isLocked = conversation.getIn(['status', 'isLocked']);
  const isModerator = conversation.getIn(['status', 'isModerator']);
  const canEditRoster = !isOneOnOne && (isLocked && isModerator || !isLocked);
  const isConsumerOrg = currentUser.orgId === 'consumer';
  return {
    sparkInstance,
    canEditRoster,
    searchResults,
    participants,
    isConsumerOrg,
    currentView: widgetRoster.get('currentView'),
    searchTerm: widgetRoster.get('searchTerm')
  };
});

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = ".widget-roster__roster__LnJvc3Rl {\n  display: flex;\n  height: 100%;\n  width: 100%;\n  font-family: CiscoSansTT Regular, Helvetica Neue, Helvetica, Arial, sans-serif;\n  flex-direction: column;\n}\n\n.widget-roster__fullHeight__LnJvc3Rl {\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: column;\n  height: 100%;\n}\n\n.widget-roster__scrolling__LnJvc3Rl {\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: column;\n}\n\n.widget-roster__participantsSeparator__LnJvc3Rl {\n  height: 30px;\n  padding-left: 16px;\n  font-size: 12px;\n  line-height: 30px;\n  color: #4f5051;\n  background-color: #f5f5f6;\n}\n\n.widget-roster__addPeople__LnJvc3Rl {\n  display: flex;\n  width: 100%;\n  min-height: 52px;\n  font-size: 14px;\n  font-weight: 300;\n  line-height: 52px;\n  color: #000;\n  cursor: pointer;\n}\n\n.widget-roster__addPeopleIcon__LnJvc3Rl {\n  height: 52px;\n  width: 52px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n";
var styles$2 = {"roster":"widget-roster__roster__LnJvc3Rl","fullHeight":"widget-roster__fullHeight__LnJvc3Rl","scrolling":"widget-roster__scrolling__LnJvc3Rl","participantsSeparator":"widget-roster__participantsSeparator__LnJvc3Rl","addPeople":"widget-roster__addPeople__LnJvc3Rl","addPeopleIcon":"widget-roster__addPeopleIcon__LnJvc3Rl"};
styleInject(css_248z$2);

var css_248z$1 = ".widget-roster__addPartipicant__LmFkZFBh {\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: column;\n}\n\n.widget-roster__searchBar__LmFkZFBh {\n  display: flex;\n  margin: 5px;\n}\n\n.widget-roster__searchInput__LmFkZFBh {\n  height: 28px;\n  width: 100%;\n  margin-bottom: 0 !important; /* overrides momentum-ui input margin */\n}\n\n.widget-roster__searchInput__LmFkZFBh input {\n  font-size: 12px;\n  height: 28px;\n  margin-bottom: 0;\n}\n\n.widget-roster__closeButton__LmFkZFBh {\n  padding-right: 5px;\n}\n\n.widget-roster__closeButton__LmFkZFBh button {\n  border-radius: 5px !important; /* converts a circle button to small rounded */\n}\n\n.widget-roster__inviteButton__LmFkZFBh {\n  font-size: 16px;\n}\n\n.widget-roster__results__LmFkZFBh {\n  border-top: 1px solid #f5f5f6;\n  height: 100%;\n  width: 100%;\n}\n\n.widget-roster__resultsLoading__LmFkZFBh {\n  margin: auto;\n}\n\n.widget-roster__resultsNone__LmFkZFBh {\n  margin: 0 15px 15px;\n  font-size: 14px;\n  font-weight: 300;\n}\n\n.widget-roster__resultsInvite__LmFkZFBh {\n  display: flex;\n  margin: 15px;\n  font-size: 14px;\n  font-weight: 300;\n  line-height: 34px;\n  cursor: pointer;\n}\n\n.widget-roster__resultsInviteIcon__LmFkZFBh {\n  display: flex;\n  margin: 5px;\n}\n\n.widget-roster__item__LmFkZFBh {\n  cursor: pointer;\n}\n\n.widget-roster__fullHeight__LmFkZFBh {\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: column;\n}\n";
var styles$1 = {"addPartipicant":"widget-roster__addPartipicant__LmFkZFBh","searchBar":"widget-roster__searchBar__LmFkZFBh","searchInput":"widget-roster__searchInput__LmFkZFBh","closeButton":"widget-roster__closeButton__LmFkZFBh","inviteButton":"widget-roster__inviteButton__LmFkZFBh","results":"widget-roster__results__LmFkZFBh","resultsLoading":"widget-roster__resultsLoading__LmFkZFBh","resultsNone":"widget-roster__resultsNone__LmFkZFBh","resultsInvite":"widget-roster__resultsInvite__LmFkZFBh","resultsInviteIcon":"widget-roster__resultsInviteIcon__LmFkZFBh","item":"widget-roster__item__LmFkZFBh","fullHeight":"widget-roster__fullHeight__LmFkZFBh"};
styleInject(css_248z$1);

const propTypes$1 = {
  noResultsMessage: PropTypes.string.isRequired,
  onAddPerson: PropTypes.func.isRequired,
  onChange: PropTypes.func.isRequired,
  onDismiss: PropTypes.func.isRequired,
  placeholder: PropTypes.string.isRequired,
  searchResults: PropTypes.shape({
    inProgress: PropTypes.bool,
    date: PropTypes.number,
    results: PropTypes.array
  }),
  searchTerm: PropTypes.string
};
const defaultProps = {
  searchResults: undefined,
  searchTerm: ''
};

function AddParticipant({
  noResultsMessage,
  onChange,
  onDismiss,
  onAddPerson,
  placeholder,
  searchResults,
  searchTerm
}) {
  const baseClassPrefix = 'webex-roster-add-participant';

  function handleChange(e) {
    onChange(e.target.value);
  }

  function handleClose() {
    onChange('');
    onDismiss();
  }

  function handleClick(person) {
    onAddPerson(person);
  }

  function handleInvite() {
    onAddPerson(searchTerm);
  }

  function handleKeyPressInvite(e) {
    if (e.key === 'Enter' || e.key === ' ') {
      onAddPerson(searchTerm);
    }
  }

  let results;

  if (searchResults) {
    if (searchResults.inProgress) {
      results = /*#__PURE__*/React.createElement("div", {
        className: classNames(`${baseClassPrefix}-results-loading`, styles$1.resultsLoading)
      }, /*#__PURE__*/React.createElement(Spinner, null));
    } else if (searchResults.results && searchResults.results.length) {
      results = /*#__PURE__*/React.createElement("div", {
        className: classNames(`${baseClassPrefix}-results`, styles$1.results, styles$1.fullHeight)
      }, /*#__PURE__*/React.createElement(PeopleList, {
        items: [{
          people: searchResults.results
        }],
        onItemClick: handleClick
      }));
    } else if (searchResults.results && searchResults.results.length === 0 && isEmail(searchTerm)) {
      results = /*#__PURE__*/React.createElement("div", {
        className: classNames(`${baseClassPrefix}-results-invite`, styles$1.resultsInvite),
        onClick: handleInvite,
        onKeyPress: handleKeyPressInvite,
        role: "button",
        tabIndex: "0"
      }, /*#__PURE__*/React.createElement("div", {
        className: classNames(`${baseClassPrefix}-results-invite-icon`, styles$1.resultsInviteIcon)
      }, /*#__PURE__*/React.createElement(Icon, {
        name: "icon-email-invite_24"
      })), /*#__PURE__*/React.createElement("div", null, `Invite ${searchTerm}`));
    } else if (searchTerm) {
      results = /*#__PURE__*/React.createElement("div", {
        className: classNames(`${baseClassPrefix}-results-none`, styles$1.resultsNone)
      }, /*#__PURE__*/React.createElement("div", null, noResultsMessage));
    }
  }

  return /*#__PURE__*/React.createElement("div", {
    className: classNames(`${baseClassPrefix}`, styles$1.addPartipicant)
  }, /*#__PURE__*/React.createElement("div", {
    className: classNames(styles$1.searchBar)
  }, /*#__PURE__*/React.createElement("div", {
    className: classNames(`${baseClassPrefix}-close-button-container`, styles$1.closeButton)
  }, /*#__PURE__*/React.createElement(Button, {
    ariaLabel: "Close Search",
    circle: true,
    onClick: handleClose,
    size: 28
  }, /*#__PURE__*/React.createElement(Icon, {
    name: "icon-arrow-left_12"
  }))), /*#__PURE__*/React.createElement(Input, {
    name: "addParticipantSearchInput",
    htmlId: "addParticipantSearchInput",
    onChange: handleChange,
    placeholder: placeholder,
    className: classNames(styles$1.searchInput, 'md-input--filled'),
    value: searchTerm
  })), results);
}

AddParticipant.propTypes = propTypes$1;
AddParticipant.defaultProps = defaultProps;

var css_248z = ".widget-roster__external__LmV4dGVy {\n  display: flex;\n  align-items: center;\n  height: 33px;\n  margin: 8px;\n  font-size: 10px;\n  font-weight: 200;\n  color: #FFB400;\n  line-height: 1.2;\n}\n\n.widget-roster__externalIcon__LmV4dGVy {\n  display: flex;\n  margin: 0 8px;\n  width: 33px;\n  justify-content: center;\n  align-items: center;\n}\n";
var styles = {"external":"widget-roster__external__LmV4dGVy","externalIcon":"widget-roster__externalIcon__LmV4dGVy"};
styleInject(css_248z);

const propTypes = {
  message: PropTypes.string.isRequired
};

function ExternalParticipantMessage({
  message
}) {
  return /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-has-external', styles.external)
  }, /*#__PURE__*/React.createElement("div", {
    className: classNames('webex-has-external-icon', styles.externalIcon)
  }, /*#__PURE__*/React.createElement(Icon, {
    color: "yellow",
    name: "icon-external-user_20"
  })), /*#__PURE__*/React.createElement("div", null, message));
}

ExternalParticipantMessage.propTypes = propTypes;

var _class;
/**
 * RosterWidget Container
 * @extends Component
 */

let RosterWidget = (_class = class RosterWidget extends Component {
  constructor(props) {
    super(props);
    this.doSearch = debounce(this.doSearch, 1000);
    const {
      formatMessage
    } = props.intl;
    this.formattedMessages = {
      addPeople: formatMessage(messages$1.addPeople),
      addPlaceholder: formatMessage(messages$1.addPlaceholder),
      cancelDetails: formatMessage(messages$1.cancelDetails),
      externalParticipants: formatMessage(messages$1.externalParticipants),
      moderators: formatMessage(messages$1.moderators),
      noResults: formatMessage(messages$1.noResults),
      participants: formatMessage(messages$1.participants),
      removeParticipant: formatMessage(messages$1.removeParticipant)
    };
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.avatar.get('items') !== this.props.avatar.get('items') || nextProps.conversation.get('participants') !== this.props.conversation.get('participants') || nextProps.canEditRoster !== this.props.canEditRoster || nextProps.currentView !== this.props.widgetRoster.currentView || nextProps.searchResults !== this.props.searchResults;
  }

  componentWillUpdate(nextProps) {
    // Fetch avatars for searched users
    if (nextProps.searchResults && nextProps.searchResults !== this.props.searchResults && nextProps.searchResults.results) {
      this.props.fetchAvatarsForUsers(nextProps.searchResults.results.map(user => user.id), this.props.sparkInstance);
    }
  }

  displayUsers(users) {
    this.props.fetchAvatarsForUsers(users, this.props.sparkInstance);
  }

  handleMenuClick() {
    this.props.onClickMenu();
  }

  handleCloseClick() {
    this.props.onClickClose();
  }

  handleAddPeople() {
    this.props.setWidgetViewAdd();
  }

  handleAddPeopleDismiss() {
    this.props.setWidgetViewMain();
  }

  handleAddPersonClick(person) {
    this.props.setWidgetViewMain();
    this.props.addParticipantToConversation(this.props.conversation, person, this.props.sparkInstance);
  }

  handleSearchInput(searchTerm) {
    this.props.setSearchTerm(searchTerm); // Consumer org can only search via email

    if (this.props.isConsumerOrg && isEmail(searchTerm) || !this.props.isConsumerOrg && searchTerm.length >= 3) {
      this.doSearch(searchTerm);
    }
  }

  handleRosterRemove(participant) {
    this.props.removeParticipantFromConversation(this.props.conversation, participant, this.props.sparkInstance);
  }

  doSearch(searchTerm) {
    // Only actually search if we don't have search results for the term
    if (searchTerm === this.props.searchTerm && !this.props.searchResults) {
      this.props.searchForUser(searchTerm, this.props.sparkInstance);
    }
  }
  /**
   * Renders the main area of the widget
   *
   * @returns {object}
   */


  render() {
    let mainArea;
    const {
      activityTypes,
      canEditRoster,
      participants
    } = this.props;

    if (!this.props.conversation.has('participants')) {
      mainArea = /*#__PURE__*/React.createElement(LoadingScreen, null);
    } else {
      const {
        currentView,
        searchResults,
        searchTerm
      } = this.props;
      let content;

      if (currentView === VIEW_ADD) {
        content = /*#__PURE__*/React.createElement("div", {
          className: classNames('webex-roster-add-participant-list', styles$2.fullHeight)
        }, /*#__PURE__*/React.createElement(AddParticipant, {
          noResultsMessage: this.formattedMessages.noResults,
          onAddPerson: this.handleAddPersonClick,
          onChange: this.handleSearchInput,
          onDismiss: this.handleAddPeopleDismiss,
          placeholder: this.formattedMessages.addPlaceholder,
          searchResults: searchResults,
          searchTerm: searchTerm
        }));
      } else {
        let addPeopleButton;

        if (canEditRoster) {
          addPeopleButton =
          /*#__PURE__*/
          // eslint-disable-reason false positive until a11y plugin upgraded to ^5.0
          // eslint-disable-next-line jsx-a11y/no-static-element-interactions
          React.createElement("div", {
            className: classNames('webex-roster-add-people', styles$2.addPeople),
            onClick: this.handleAddPeople,
            onKeyPress: this.handleAddPeople,
            role: "button",
            tabIndex: "0"
          }, /*#__PURE__*/React.createElement("div", {
            className: classNames(styles$2.addPeopleIcon)
          }, /*#__PURE__*/React.createElement(Button, {
            ariaLabel: this.formattedMessages.addPeople,
            circle: true,
            color: "blue",
            size: 28
          }, /*#__PURE__*/React.createElement(Icon, {
            name: "icon-plus_12",
            color: "white"
          }))), /*#__PURE__*/React.createElement("div", null, this.formattedMessages.addPeople));
        }

        content = /*#__PURE__*/React.createElement("div", {
          className: classNames('webex-roster-people-list', styles$2.fullHeight)
        }, addPeopleButton, /*#__PURE__*/React.createElement(PeopleList, {
          canEdit: canEditRoster,
          items: participants.people,
          onDisplayUsers: this.displayUsers,
          onPersonRemove: this.handleRosterRemove
        }));
      }

      mainArea = /*#__PURE__*/React.createElement("div", {
        className: classNames('webex-roster-main-area-participants', styles$2.fullHeight)
      }, participants.hasExternalParticipants && /*#__PURE__*/React.createElement(ExternalParticipantMessage, {
        message: this.formattedMessages.externalParticipants
      }), content);
    }

    return /*#__PURE__*/React.createElement("div", {
      className: classNames('webex-roster', styles$2.roster)
    }, /*#__PURE__*/React.createElement(ActivityMenuHeader, {
      activityTypes: activityTypes,
      onClose: this.props.onClickClose && this.handleCloseClick,
      onMenuClick: this.props.onClickMenu && this.handleMenuClick,
      title: `People (${participants.count ? participants.count : null})`
    }), /*#__PURE__*/React.createElement("div", {
      className: classNames('webex-roster-main-area', styles$2.fullHeight)
    }, mainArea));
  }

}, (_applyDecoratedDescriptor(_class.prototype, "displayUsers", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "displayUsers"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleMenuClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleMenuClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleCloseClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleCloseClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleAddPeople", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleAddPeople"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleAddPeopleDismiss", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleAddPeopleDismiss"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleAddPersonClick", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleAddPersonClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleSearchInput", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleSearchInput"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleRosterRemove", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "handleRosterRemove"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "doSearch", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "doSearch"), _class.prototype)), _class);
const injectedPropTypes = {
  activityTypes: PropTypes.array.isRequired,
  canEditRoster: PropTypes.bool.isRequired,
  conversation: PropTypes.object.isRequired,
  currentView: PropTypes.string.isRequired,
  isConsumerOrg: PropTypes.bool.isRequired,
  participants: PropTypes.shape({
    hasExternalParticipants: PropTypes.bool.isRequired,
    people: PropTypes.array,
    count: PropTypes.number.isRequired
  }),
  searchResults: PropTypes.object,
  searchTerm: PropTypes.string,
  sparkInstance: PropTypes.object,
  widgetRoster: PropTypes.object.isRequired,
  addParticipantToConversation: PropTypes.func.isRequired,
  fetchAvatarsForUsers: PropTypes.func.isRequired,
  removeParticipantFromConversation: PropTypes.func.isRequired,
  searchForUser: PropTypes.func.isRequired,
  setSearchTerm: PropTypes.func.isRequired,
  setWidgetViewAdd: PropTypes.func.isRequired,
  setWidgetViewMain: PropTypes.func.isRequired
};
const ownPropTypes = {
  onClickClose: PropTypes.func,
  onClickMenu: PropTypes.func,
  onEvent: PropTypes.func,
  spaceId: PropTypes.string,
  eventNames: PropTypes.object
};
RosterWidget.propTypes = { ...ownPropTypes,
  ...injectedPropTypes
};
var ConnectedRoster = compose(wrapConversationMercury, connect(getRosterWidgetProps, dispatch => bindActionCreators({
  addParticipantToConversation,
  fetchAvatarsForUsers,
  removeParticipantFromConversation,
  searchForUser,
  setSearchTerm,
  setWidgetViewAdd,
  setWidgetViewMain
}, dispatch)))(RosterWidget);

var messages = {};

var index = compose(constructWebexEnhancer({
  name: 'roster',
  reducers
}), withIntl({
  locale: 'en',
  messages
}))(ConnectedRoster);

export default index;
export { reducers };
//# sourceMappingURL=index.js.map
