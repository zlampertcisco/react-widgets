import { Component } from 'react';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';
import PropTypes from 'prop-types';
import _ from 'lodash';
import { createSelector } from 'reselect';
import { fromJS } from 'immutable';

const PERMISSION_GRANTED = 'granted';
const PERMISSION_DENIED = 'denied';
/**
 * Returns true if the main browser window is hidden, minimized,
 * or in the background; false otherwise.
 *
 * @returns {boolean} hidden
 */

function isBrowserHidden() {
  return document.webkitHidden || document.mozHidden || document.msHidden || document.hidden || !document.hasFocus();
}
/**
 * Checks if native browser notifications are supported
 *
 * @export
 * @returns {bool}
 */

function isNotificationSupported() {
  return window && window.Notification;
}
function requestPermissionForNotifications(callback) {
  return window.Notification.requestPermission(callback);
}
/**
 * Displays a browser notification and automatically closes after timeout
 *
 * @param {String} theBody body of the notification
 * @param {String} theIcon the url of the icon to display
 * @param {String} theTitle
 * @param {Integer} timeoutLength non-zero amount of time to display the notification
 *
 * @returns {Object} Browser notification object
 *
 */

function spawnNotification(theBody, theIcon, theTitle, timeoutLength) {
  const options = {
    body: theBody,
    icon: theIcon
  };
  const browserNotification = new Notification(theTitle, options);

  if (timeoutLength) {
    setTimeout(() => {
      browserNotification.close();
    }, timeoutLength);
  }

  return browserNotification;
}
var browserUtilities = {
  PERMISSION_GRANTED,
  PERMISSION_DENIED,
  isBrowserHidden,
  isNotificationSupported,
  requestPermissionForNotifications,
  spawnNotification
};

const getNotifications = state => state.notifications.get('items');

const getNotificationSettings = state => state.notifications.get('settings');

const getUnsentNotifications = createSelector([getNotifications], notifications => notifications.toArray().map(notification => {
  const {
    username,
    message,
    avatar,
    alertType
  } = notification.details;
  return Object.assign({}, notification, {
    username,
    message,
    avatar,
    alertType
  });
}));
const getNotificationDetails = createSelector([getNotificationSettings, getUnsentNotifications], (notificationSettings, unsentNotifications) => ({
  isSupported: notificationSettings.get('isSupported'),
  notifications: unsentNotifications,
  permission: notificationSettings.get('permission')
}));

const ADD_NOTIFICATION = 'notifications/ADD_NOTIFICATION';
const DELETE_NOTIFICATION = 'notifications/DELETE_NOTIFICATION';
const UPDATE_NOTIFICATION_SETTING = 'notifications/UPDATE_NOTIFICATION_SETTING';

function addNotification(notification) {
  return {
    type: ADD_NOTIFICATION,
    payload: {
      notification
    }
  };
}

function deleteNotification(notificationId) {
  return {
    type: DELETE_NOTIFICATION,
    payload: {
      notificationId
    }
  };
}

function updateNotificationSetting(setting) {
  return {
    type: UPDATE_NOTIFICATION_SETTING,
    payload: {
      setting
    }
  };
}
/**
 * Creates a new notification for processing
 *
 * @param {string} notificationId
 * @param {object} details
 * @param {string} details.message
 * @param {string} details.avatar
 * @param {string} details.username
 * @returns {function}
 */


function createNotification(notificationId, details) {
  return dispatch => dispatch(addNotification({
    notificationId,
    details
  }));
}
/**
 * Updates an existing notification to indicate that it was sent
 *
 * @param {string} notificationId
 * @returns {function}
 */

function notificationSent(notificationId) {
  return dispatch => dispatch(deleteNotification(notificationId));
}
/**
 * Changes the permission type after we've request notification
 * permissions from the user
 *
 * @param {String} permission
 * @returns {function}
 */

function setNotificationPermission(permission) {
  return dispatch => dispatch(updateNotificationSetting({
    permission
  }));
}
/**
 * Changes the setting for if native notifications are supported
 * by the user's device/browser
 *
 * @export
 * @param {bool} isSupported
 * @returns {function}
 */

function setNotificationSupported(isSupported) {
  return dispatch => dispatch(updateNotificationSetting({
    isSupported
  }));
}

const eventNames = {
  NOTIFICATIONS_CREATED: 'notification:created',
  NOTIFICATIONS_CLICKED: 'notification:clicked'
};
/**
 * Constructs an event detail object for notifications
 * @export
 * @param {Object} notification notification object
 * @param {Object} details event details
 * @returns {Object} constructed event
 */

function constructNotificationEventData(notification, details) {
  return Object.assign({}, details, {
    notification
  });
}

const TIMEOUT_LENGTH = 10000;
const propTypes = {
  notifications: PropTypes.array,
  isSupported: PropTypes.bool,
  isMuted: PropTypes.bool,
  permission: PropTypes.string,
  onEvent: PropTypes.func,
  notificationSent: PropTypes.func,
  setNotificationPermission: PropTypes.func,
  setNotificationSupported: PropTypes.func
};
const defaultProps = {
  notifications: [],
  isSupported: false,
  isMuted: false,
  permission: '',
  onEvent: null,
  notificationSent: null,
  setNotificationPermission: null,
  setNotificationSupported: null
};
class Notifications extends Component {
  componentDidMount() {
    const {
      props
    } = this; // Default state is not supported, once we know it is, don't check any more

    this.setup(props);
    this.displayNotifications();
  }

  shouldComponentUpdate(nextProps) {
    const {
      props
    } = this;
    return nextProps.notifications !== props.notifications || nextProps.isSupported !== props.isSupported || nextProps.permission !== props.permission;
  }

  componentDidUpdate() {
    this.setup(this.props);
    this.displayNotifications();
  }
  /**
   * Check for permissions and support
   *
   * @param {object} props
   * @returns null
   */


  setup(props) {
    if (!props.isSupported) {
      this.checkSupported();
    }

    if (_.isNull(props.permission) && props.isSupported) {
      this.requestPermission();
    }
  }
  /**
   * Requests permission from the browser to allow notifications
   *
   * @returns {Promise}
   */


  requestPermission() {
    const {
      props
    } = this;
    return browserUtilities.requestPermissionForNotifications(permission => props.setNotificationPermission(permission));
  }
  /**
   * Checks if browser notifications are supported and updates store
   *
   */


  checkSupported() {
    const {
      props
    } = this;

    if (!props.isSupported && browserUtilities.isNotificationSupported()) {
      props.setNotificationSupported(true);
    }
  }
  /**
   * Processes notifications and displays them if needed
   *
   */


  displayNotifications() {
    const {
      notifications,
      onEvent,
      permission,
      isMuted
    } = this.props;
    const hasPermission = permission === browserUtilities.PERMISSION_GRANTED;

    if (notifications && notifications.length > 0) {
      notifications.forEach(notification => {
        const {
          username,
          message,
          avatar,
          notificationId,
          alertType
        } = notification;

        if (alertType !== 'none' && !isMuted && hasPermission && browserUtilities.isBrowserHidden()) {
          // Actually display notification
          const n = browserUtilities.spawnNotification(message, avatar, username, TIMEOUT_LENGTH); // If there is an onEvent method

          const details = constructNotificationEventData(n, notification);

          if (onEvent && typeof onEvent === 'function') {
            onEvent(eventNames.NOTIFICATIONS_CREATED, details);
            n.addEventListener('click', () => {
              onEvent(eventNames.NOTIFICATIONS_CLICKED, details);
            });
          }
        }

        this.props.notificationSent(notificationId);
      });
    }
  }

  render() {
    return null;
  }

}
Notifications.propTypes = propTypes;
Notifications.defaultProps = defaultProps;
var container = connect(getNotificationDetails, dispatch => bindActionCreators({
  notificationSent,
  setNotificationPermission,
  setNotificationSupported
}, dispatch))(Notifications);

const initialState = fromJS({
  items: {},
  settings: {
    isSupported: null,
    permission: null
  }
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case ADD_NOTIFICATION:
      {
        const {
          notificationId,
          type,
          details
        } = action.payload.notification;
        const notification = {
          notificationId,
          type,
          details
        };
        return state.setIn(['items', notificationId], notification);
      }

    case DELETE_NOTIFICATION:
      return state.deleteIn(['items', action.payload.notificationId]);

    case UPDATE_NOTIFICATION_SETTING:
      return state.mergeDeepIn(['settings'], action.payload.setting);

    default:
      return state;
  }
}

export default container;
export { ADD_NOTIFICATION, DELETE_NOTIFICATION, Notifications, UPDATE_NOTIFICATION_SETTING, createNotification, notificationSent, reducer, setNotificationPermission, setNotificationSupported };
//# sourceMappingURL=index.js.map
