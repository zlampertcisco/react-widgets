import { sanitize, isImage, constructActivityWithContent, constructActivity } from '@webex/react-component-utils';
import marked from 'marked';
import { filterSync, escapeSync } from '@webex/helper-html';
import { Map, OrderedMap, List } from 'immutable';

/**
 * Create objectURL
 *
 * @param {object} file
 * @returns {string}
 */

function createObjectURL(file) {
  const urlCreator = window.URL || window.webkitURL;
  return urlCreator.createObjectURL(file);
}
/**
 * Revoke objectURL
 *
 * @param {object} file
 * @returns {undefined}
 */

function revokeObjectURL(file) {
  const urlCreator = window.URL || window.webkitURL;
  urlCreator.revokeObjectURL(file);
}
/**
 * Parses react-mention data from input text
 *
 * @param {string} text
 * @param {string} plainText
 * @returns {Object}
 * @returns {Object.mentions}
 * @returns {Object.mentionsText}
 */

function getMentions(text, plainText) {
  const regex = /@\{(.+?)\}\|([a-zA-Z0-9-]+)\|/g;
  const mentions = [];
  const mentionsText = text.replace(regex, (match, display, id) => {
    mentions.push({
      id,
      objectType: 'person'
    });
    return `<spark-mention data-object-type="person" data-object-id="${id}">${display}</spark-mention>`;
  });
  const mentionsPlainText = plainText.replace(regex, (match, display) => display);
  return {
    mentions,
    mentionsPlainText,
    mentionsText
  };
}

function filterMarked(content) {
  return filterSync(() => {}, {
    'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
    a: ['href'],
    b: [],
    blockquote: ['class'],
    strong: [],
    i: [],
    em: [],
    pre: [],
    code: ['class'],
    br: [],
    hr: [],
    p: [],
    ul: [],
    ol: [],
    li: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: []
  }, [], content);
}
/**
 * Creates markdown and stripped text object
 *
 * @param {string} text
 * @returns {object}
 * @returns {object.content} Converted markdown content
 * @returns {object.displayName} Raw text content
 */


function createMessageObject(text) {
  const messageObject = {
    displayName: '',
    objectType: 'comment'
  };

  if (typeof text === 'string') {
    const origContent = text.trim();
    let content = origContent;
    let plainText = origContent;
    let hasContent = false;
    const htmlRegex = /(<([^>]+)>)/ig;
    const markedString = marked(content) || '';
    const cleanedString = markedString // Remove possibly added <p></p> tags and newline
    .replace(/(?:^<p>)|(?:<\/p>$)|(?:<\/p>\n$)/g, '') // Replace new lines between html elements
    .replace(/>\n</g, '><').trim();

    if (cleanedString !== origContent) {
      hasContent = true;
      content = filterMarked(cleanedString); // Generate plain text from markdown

      plainText = cleanedString // insert removed line breaks between li elements
      .replace(/li><li/g, 'li>\n<li') // Strip html for plain text
      .replace(/(<([^>]+)>)/ig, ''); // Convert escaped markdown html back to html for plaintext to remove markdown chars

      plainText = plainText.replace(/(&lt;|&gt;|&amp;|&#39;|&quot;)/g, char => {
        switch (char) {
          case '&lt;':
            return '<';

          case '&gt;':
            return '>';

          case '&amp;':
            return '&';

          case '&#39;':
            return "'";

          case '&quot;':
            return '"';

          default:
            return char;
        }
      }); // After converting back, if nothing changed, we have pure plain text
      // Unless the markdown html has tags (like when sending a raw link)

      if (plainText === origContent && !content.match(htmlRegex)) {
        hasContent = false;
      }
    }

    if (!hasContent && content.match(htmlRegex)) {
      // If it has raw html but no markdown, we need to escape
      content = escapeSync(cleanedString);
      hasContent = true;
    }

    const {
      mentions,
      mentionsPlainText,
      mentionsText
    } = getMentions(content, plainText);

    if (mentions && mentions.length) {
      hasContent = true;
      messageObject.mentions = {
        items: mentions
      };
      content = mentionsText;
      plainText = mentionsPlainText;
    } // If we had to modify the original content, send converted


    if (hasContent) {
      messageObject.content = content;
    }

    messageObject.displayName = plainText;
  }

  return messageObject;
}
/**
* Helper to reset Activity store
*
* @param {Map} activity
* @param {function} dispatch
*/

function cleanupAfterSubmit(activity, dispatch) {
  const files = activity.get('files');

  if (files.size) {
    files.forEach(file => {
      revokeObjectURL(file);
    });
  }

  dispatch(resetActivity());
}

const ADD_FILES_TO_ACTIVITY = 'activity/ADD_FILES_TO_ACTIVITY';
const ADD_INFLIGHT_ACTIVITY = 'activity/ADD_INFLIGHT_ACTIVITY';
const REMOVE_FAILED_ACTIVITY = 'activity/REMOVE_FAILED_ACTIVITY';
const REMOVE_FILE_FROM_ACTIVITY = 'activity/REMOVE_FILE_FROM_ACTIVITY';
const REMOVE_INFLIGHT_ACTIVITY = 'activity/REMOVE_INFLIGHT_ACTIVITY';
const RESET_ACTIVITY = 'activity/RESET_ACTIVITY';
const SAVE_SHARE_ACTIVITY = 'activity/SAVE_SHARE_ACTIVITY';
const SUBMIT_ACTIVITY_START = 'activity/SUBMIT_ACTIVITY_START';
const SUBMIT_ACTIVITY_FAILURE = 'activity/SUBMIT_ACTIVITY_FAILURE';
const UPDATE_ACTIVITY_STATUS = 'activity/UPDATE_ACTIVITY_STATUS';
const STORE_ACTIVITY_TEXT = 'activity/STORE_ACTIVITY_TEXT';
function addFilesToActivity(files) {
  return {
    type: ADD_FILES_TO_ACTIVITY,
    payload: {
      files
    }
  };
}

function addInflightActivity(activity) {
  return {
    type: ADD_INFLIGHT_ACTIVITY,
    payload: {
      activity
    }
  };
}

function removeFailedActivity(id) {
  return {
    type: REMOVE_FAILED_ACTIVITY,
    payload: {
      id
    }
  };
}

function removeFileFromActivity(id) {
  return {
    type: REMOVE_FILE_FROM_ACTIVITY,
    payload: {
      id
    }
  };
}
function removeInflightActivity(id) {
  return {
    type: REMOVE_INFLIGHT_ACTIVITY,
    payload: {
      id
    }
  };
}
function resetActivity() {
  return {
    type: RESET_ACTIVITY
  };
}
function saveShareActivity(shareActivity) {
  return {
    type: SAVE_SHARE_ACTIVITY,
    payload: {
      shareActivity
    }
  };
}
function submitActivityStart() {
  return {
    type: SUBMIT_ACTIVITY_START
  };
}
function submitActivityFailure(activity, error) {
  return {
    type: SUBMIT_ACTIVITY_FAILURE,
    payload: {
      activity,
      error
    }
  };
}
function updateActivityStatus(status) {
  return {
    type: UPDATE_ACTIVITY_STATUS,
    payload: {
      status
    }
  };
}
function storeActivityText(text, cleanText) {
  return {
    type: STORE_ACTIVITY_TEXT,
    payload: {
      text,
      cleanText
    }
  };
}
/**
 * Adds file to message, creates Share activity if not present, starts upload
 *
 * @param {object} conversation - from store
 * @param {Map} activity - from store
 * @param {Array} files
 * @param {object} spark - spark instance
 * @returns {function}
 */

function addFiles(conversation, activity, files, spark) {
  return dispatch => {
    if (files && files.length) {
      let shareActivity = activity.get('shareActivity');

      if (!shareActivity) {
        shareActivity = spark.internal.conversation.makeShare(conversation.toJS()); // Store shareActivity object to be used later

        dispatch(saveShareActivity(shareActivity));
      }

      let cleanFiles;

      if (files && files.length) {
        cleanFiles = files.map(file => {
          const clean = sanitize(file); // Create thumbnail objectURL

          if (isImage(clean)) {
            clean.thumbnail = createObjectURL(clean);
          }

          return clean;
        });
      }

      dispatch(updateActivityStatus({
        isUploadingShare: true
      }));
      dispatch(addFilesToActivity(cleanFiles));
      cleanFiles.forEach(file => shareActivity.add(file));
    }

    return Promise.resolve();
  };
}
/**
* Removes file from ShareActivity and from store
*
* @param {string} id - clientTempId key of stored file
* @param {Map} activity - from store
* @returns {function}
*/

function removeFile(id, activity) {
  return dispatch => {
    const shareActivity = activity.get('shareActivity');
    const file = activity.getIn(['files', id]);
    return shareActivity.remove(file).then(() => {
      revokeObjectURL(file);
      return dispatch(removeFileFromActivity(id));
    });
  };
}
/**
* Constructs and sends activity to server
*
* @param {object} conversation - from store (immutable object)
* @param {Map} activity - from store (immutable object)
* @param {object} user - from store
* @param {object} spark - spark instance from store
* @returns {function}
*/

function submitActivity(conversation, activity, user, spark) {
  return dispatch => {
    if (activity.get('text').length === 0 && activity.get('files').size === 0) {
      return Promise.resolve();
    }

    const activityObject = createMessageObject(activity.get('text'));
    const shareActivity = activity.get('shareActivity');
    const conversationJS = conversation.toJS();

    if (shareActivity && activity.get('files').size) {
      const inFlightActivity = constructActivityWithContent(conversationJS, activityObject, user, activity.get('files').toArray(), shareActivity, true);
      dispatch(addInflightActivity(inFlightActivity)); // map our temp id to the in flight temp id so we can remove it when it is received

      shareActivity.object = {
        displayName: activityObject.displayName,
        content: activityObject.content,
        mentions: activityObject.mentions
      };
      shareActivity.clientTempId = inFlightActivity.clientTempId;
      return spark.internal.conversation.share(conversationJS, shareActivity).then(() => {
        cleanupAfterSubmit(activity, dispatch);
      }).catch(error => {
        cleanupAfterSubmit(activity, dispatch);
        return dispatch(submitActivityFailure(inFlightActivity, error));
      });
    }

    if (activityObject) {
      const inFlightActivity = constructActivity(conversationJS, activityObject, user, true);
      dispatch(addInflightActivity(inFlightActivity));
      dispatch(resetActivity());
      return spark.internal.conversation.post(conversationJS, activityObject, {
        clientTempId: inFlightActivity.clientTempId
      }).catch(error => dispatch(submitActivityFailure(inFlightActivity, error)));
    }

    return Promise.resolve();
  };
}
/**
 * Sets the typing status of the current user
 *
 * @param {boolean} isTyping
 * @param {object} conversation
 * @param {object} spark
 * @returns {function}
 */

function setUserTyping(isTyping, conversation, spark) {
  return (dispatch, getState) => {
    const {
      activity
    } = getState();

    if (activity.getIn(['status', 'isTyping']) !== isTyping) {
      return spark.internal.conversation.updateTypingStatus(conversation.toJS(), {
        typing: isTyping
      }).then(() => dispatch(updateActivityStatus({
        isTyping
      }))).catch(error => {
        // Offline
        if (error.name === 'NetworkOrCORSError') {
          return Promise.resolve();
        }

        throw error;
      });
    }

    return Promise.resolve();
  };
}
/**
 * Re-submits the failed activity to the conversation
 * @param {object} failedActivity
 * @param {object} spark
 * @returns {function}
 */

function retryFailedActivity(failedActivity, spark) {
  return dispatch => {
    // eslint-disable-reason property provided by SDK
    // eslint-disable-next-line no-underscore-dangle
    const {
      conversation,
      shareActivity,
      text
    } = failedActivity._meta;
    dispatch(removeFailedActivity(failedActivity.id));
    dispatch(addInflightActivity(failedActivity));

    if (failedActivity.verb === 'share') {
      return spark.internal.conversation.share(conversation, shareActivity).catch(error => dispatch(submitActivityFailure(failedActivity, error)));
    }

    return spark.internal.conversation.post(conversation, text, {
      clientTempId: failedActivity.clientTempId
    }).catch(error => dispatch(submitActivityFailure(failedActivity, error)));
  };
}

const initialState = new Map({
  status: new Map({
    isSending: false,
    isTyping: false
  }),
  inFlightActivities: new OrderedMap(),
  activityFailures: new OrderedMap(),
  shareActivity: undefined,
  files: new OrderedMap(),
  text: '',
  cleanText: '',
  object: new Map({
    mentions: new List(),
    content: undefined,
    displayName: ''
  })
});
function reducer(state = initialState, action) {
  switch (action.type) {
    case ADD_FILES_TO_ACTIVITY:
      {
        const files = action.payload.files.reduce((o, currentFile) => Object.assign({}, o, {
          [currentFile.id]: currentFile
        }), {});
        return state.mergeIn(['files'], files);
      }

    case ADD_INFLIGHT_ACTIVITY:
      {
        const {
          activity
        } = action.payload;
        const inFlightActivity = new Map([[activity.clientTempId, activity]]);
        return state.mergeIn(['inFlightActivities'], inFlightActivity);
      }

    case REMOVE_FAILED_ACTIVITY:
      {
        const activityId = action.payload.id;
        return state.deleteIn(['activityFailures', activityId]);
      }

    case REMOVE_FILE_FROM_ACTIVITY:
      {
        return state.deleteIn(['files', action.payload.id]);
      }

    case REMOVE_INFLIGHT_ACTIVITY:
      {
        const activityId = action.payload.id;
        return state.deleteIn(['inFlightActivities', activityId]);
      }

    case RESET_ACTIVITY:
      {
        const inFlightActivities = state.get('inFlightActivities');
        const activityFailures = state.get('activityFailures');
        return initialState.set('inFlightActivities', inFlightActivities).set('activityFailures', activityFailures);
      }

    case SAVE_SHARE_ACTIVITY:
      {
        return state.set('shareActivity', action.payload.shareActivity);
      }

    case SUBMIT_ACTIVITY_START:
      {
        return state // Clear the text from the input
        .set('object', initialState.get('object')).setIn(['status', 'isSending'], true);
      }

    case SUBMIT_ACTIVITY_FAILURE:
      {
        const {
          activity
        } = action.payload;
        const failedActivity = new Map([[activity.clientTempId, activity]]);
        return state.deleteIn(['inFlightActivities', activity.id]).mergeIn(['activityFailures'], failedActivity);
      }

    case UPDATE_ACTIVITY_STATUS:
      return state.mergeDeepIn(['status'], action.payload.status);

    case STORE_ACTIVITY_TEXT:
      return state.set('text', action.payload.text).set('cleanText', action.payload.cleanText);

    default:
      return state;
  }
}

export default reducer;
export { ADD_FILES_TO_ACTIVITY, ADD_INFLIGHT_ACTIVITY, REMOVE_FAILED_ACTIVITY, REMOVE_FILE_FROM_ACTIVITY, REMOVE_INFLIGHT_ACTIVITY, RESET_ACTIVITY, SAVE_SHARE_ACTIVITY, STORE_ACTIVITY_TEXT, SUBMIT_ACTIVITY_FAILURE, SUBMIT_ACTIVITY_START, UPDATE_ACTIVITY_STATUS, addFiles, addFilesToActivity, createMessageObject, initialState, removeFile, removeFileFromActivity, removeInflightActivity, resetActivity, retryFailedActivity, saveShareActivity, setUserTyping, storeActivityText, submitActivity, submitActivityFailure, submitActivityStart, updateActivityStatus };
//# sourceMappingURL=index.js.map
